(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict'

const io = require('socket.io-client')
const mediasoupClient = require('mediasoup-client')

const socket = io('http://localhost:3000')
const mediaStream = new MediaStream()
let receiveTransport
let sendTransport

socket.on('connect', () => {
  console.log('Connected!')
})

socket.on('error', () => {
  console.log(error)
})

const createRoom = () => {
  const options = {
    requestTimeout: 10000,
    transportOptions: {
      tcp: false
    }
  }

  const room = new mediasoupClient.Room(options)

  room.on('newpeer', handleNewPeer)
  room.on('notify', handleNotify)
  room.on('request', dispatchRequest)
  room.on('error', handleRoomError)
  return room
}

const joinRoom = () => {
  const room = createRoom()
  const username = documnet.queryElementById('username').value
  console.log(`Joining room as ${username}!`)
  room.join(username).then(peers => {
    console.log('Creating send and receive transports!')
    receiveTransport = room.createTransport('recv')
    sendTransport = room.createTransport('send')
    startMicrophone(room)
    peers.forEach(handleNewPeer)
  })
}

const joinButton = document.getElementById('join')
joinButton.onClick = joinRoom

const handleNewPeer = peer => {
  console.log(`Peer ${peer.name} joined the room!`)
  peer.consumers.forEach(handleConsumer)
  peer.on('newconsumer', handleConsumer)
}

const handleConsumer = consumer => {
  console.log(`Adding new consumer for peer ${consumer.peer.name}!`)
  consumer.receive(receiveTransport).then(track => {
    console.log('Track enabled!')
    mediaStream.addTrack(track)

    const context = new AudioContext()
    const source = context.createMediaStreamSource(mediaStream)
    const processor = context.createScriptProcessor(1024, 1, 1)

    let count = 0
    source.connect(processor)
    processor.onaudioprocess = event => {
      console.log('event!')
      //   if (count % 100 === 0) {
      //     const data = event.inputBuffer.getChannelData(0)
      //     console.log(data)
      //   }
      //   count += 1
    }
  })
}

const handleNotify = notification => {
  console.log('handleNotify')
  fatal('Not implemented')
}

const handleRoomError = error => {
  console.log('Room Error!', error)
}

const startMicrophone = room => {
  console.log('Starting microphone...')
  navigator.mediaDevices
    .getUserMedia({ audio: true, video: false })
    .then(stream => {
      const audio = stream.getAudioTracks()[0]
      const producer = room.createProducer(audio)
      producer.send(sendTransport)
    })
    .then(() => {
      console.log('Sending audio!')
    })
    .catch(handleRoomError)
}

const dispatchRequest = (request, accept, reject) => {
  socket.on('message', message => {
    console.log(`Received response to ${request.method} request`)
    if (message.type === 'mediasoup-response') {
      const response = message.body
      accept(response)
      console.log('Accepted response from server!')
    } else {
      console.warn('Unknown message type!')
    }
  })

  console.log(`Dispatching ${request.method} request`)
  socket.send({ type: 'mediasoup-request', body: request })
}

},{"mediasoup-client":49,"socket.io-client":62}],2:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],3:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],4:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],5:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],6:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],7:[function(require,module,exports){
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(name, definition)
  else root[name] = definition()
}(this, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)os/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    } else if (/opr\/|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , osname: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , osname: 'Chrome OS'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/edg([ea]|ios)/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , osname: 'Sailfish OS'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
        result.osname = 'Firefox OS'
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , osname: 'BlackBerry OS'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , osname: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , osname: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , osname: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && (android || result.silk)) {
      result.android = t
      result.osname = 'Android'
    } else if (!result.windowsphone && iosdevice) {
      result[iosdevice] = t
      result.ios = t
      result.osname = 'iOS'
    } else if (mac) {
      result.mac = t
      result.osname = 'macOS'
    } else if (xbox) {
      result.xbox = t
      result.osname = 'Xbox'
    } else if (windows) {
      result.windows = t
      result.osname = 'Windows'
    } else if (linux) {
      result.linux = t
      result.osname = 'Linux'
    }

    function getWindowsVersion (s) {
      switch (s) {
        case 'NT': return 'NT'
        case 'XP': return 'XP'
        case 'NT 5.0': return '2000'
        case 'NT 5.1': return 'XP'
        case 'NT 5.2': return '2003'
        case 'NT 6.0': return 'Vista'
        case 'NT 6.1': return '7'
        case 'NT 6.2': return '8'
        case 'NT 6.3': return '8.1'
        case 'NT 10.0': return '10'
        default: return undefined
      }
    }

    // OS version extraction
    var osVersion = '';
    if (result.windows) {
      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
    } else if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (result.mac) {
      osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = !result.windows && osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  /*
   * Set our detect public method to the main bowser object
   * This is needed to implement bowser in server side
   */
  bowser.detect = detect;
  return bowser
});

},{}],8:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],9:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],11:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":12,"_process":74}],12:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":54}],13:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":14,"engine.io-parser":22}],14:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports/index');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (global.location && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // other options for Node.js client
  var freeGlobal = typeof global === 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports/index');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0)
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./transport":15,"./transports/index":16,"component-emitter":9,"debug":11,"engine.io-parser":22,"indexof":27,"parseqs":55,"parseuri":56}],15:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":9,"engine.io-parser":22}],16:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling-jsonp":17,"./polling-xhr":18,"./websocket":20,"xmlhttprequest-ssl":21}],17:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":19,"component-inherit":10}],18:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname !== global.location.hostname ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          var contentType;
          try {
            contentType = xhr.getResponseHeader('Content-Type');
          } catch (e) {}
          if (contentType === 'application/octet-stream') {
            xhr.responseType = 'arraybuffer';
          }
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (global.document) {
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":19,"component-emitter":9,"component-inherit":10,"debug":11,"xmlhttprequest-ssl":21}],19:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":15,"component-inherit":10,"debug":11,"engine.io-parser":22,"parseqs":55,"xmlhttprequest-ssl":21,"yeast":71}],20:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
var NodeWebSocket;
if (typeof window === 'undefined') {
  try {
    NodeWebSocket = require('ws');
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  WebSocket = NodeWebSocket;
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocket = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../transport":15,"component-inherit":10,"debug":11,"engine.io-parser":22,"parseqs":55,"ws":72,"yeast":71}],21:[function(require,module,exports){
(function (global){
// browser shim for xmlhttprequest module

var hasCORS = require('has-cors');

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"has-cors":26}],22:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary2');
var sliceBuffer = require('arraybuffer.slice');
var after = require('after');
var utf8 = require('./utf8');

var base64encoder;
if (global && global.ArrayBuffer) {
  base64encoder = require('base64-arraybuffer');
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./keys":23,"./utf8":24,"after":2,"arraybuffer.slice":3,"base64-arraybuffer":5,"blob":6,"has-binary2":25}],23:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],24:[function(require,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint, strict) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			if (strict) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
			return false;
		}
		return true;
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint, strict) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			if (!checkScalarValue(codePoint, strict)) {
				codePoint = 0xFFFD;
			}
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint, strict);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol(strict) {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol(strict)) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],25:[function(require,module,exports){
(function (global){
/* global Blob File */

/*
 * Module requirements.
 */

var isArray = require('isarray');

var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
     (typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
     (withNativeBlob && obj instanceof Blob) ||
     (withNativeFile && obj instanceof File)
    ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":28}],26:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],27:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],28:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var logger = new _Logger2.default('CommandQueue');

var CommandQueue = function (_EventEmitter) {
	_inherits(CommandQueue, _EventEmitter);

	function CommandQueue() {
		_classCallCheck(this, CommandQueue);

		var _this = _possibleConstructorReturn(this, (CommandQueue.__proto__ || Object.getPrototypeOf(CommandQueue)).call(this));

		_this.setMaxListeners(Infinity);

		// Closed flag.
		// @type {Boolean}
		_this._closed = false;

		// Busy running a command.
		// @type {Boolean}
		_this._busy = false;

		// Queue for pending commands. Each command is an Object with method,
		// resolve, reject, and other members (depending the case).
		// @type {Array<Object>}
		_this._queue = [];
		return _this;
	}

	_createClass(CommandQueue, [{
		key: 'close',
		value: function close() {
			this._closed = true;
		}
	}, {
		key: 'push',
		value: function push(method, data) {
			var _this2 = this;

			var command = Object.assign({ method: method }, data);

			logger.debug('push() [method:%s]', method);

			return new Promise(function (resolve, reject) {
				var queue = _this2._queue;

				command.resolve = resolve;
				command.reject = reject;

				// Append command to the queue.
				queue.push(command);
				_this2._handlePendingCommands();
			});
		}
	}, {
		key: '_handlePendingCommands',
		value: function _handlePendingCommands() {
			var _this3 = this;

			if (this._busy) return;

			var queue = this._queue;

			// Take the first command.
			var command = queue[0];

			if (!command) return;

			this._busy = true;

			// Execute it.
			this._handleCommand(command).then(function () {
				_this3._busy = false;

				// Remove the first command (the completed one) from the queue.
				queue.shift();

				// And continue.
				_this3._handlePendingCommands();
			});
		}
	}, {
		key: '_handleCommand',
		value: function _handleCommand(command) {
			var _this4 = this;

			logger.debug('_handleCommand() [method:%s]', command.method);

			if (this._closed) {
				command.reject(new _errors.InvalidStateError('closed'));

				return Promise.resolve();
			}

			var promiseHolder = { promise: null };

			this.emit('exec', command, promiseHolder);

			return Promise.resolve().then(function () {
				return promiseHolder.promise;
			}).then(function (result) {
				logger.debug('_handleCommand() | command succeeded [method:%s]', command.method);

				if (_this4._closed) {
					command.reject(new _errors.InvalidStateError('closed'));

					return;
				}

				// Resolve the command with the given result (if any).
				command.resolve(result);
			}).catch(function (error) {
				logger.error('_handleCommand() | command failed [method:%s]: %o', command.method, error);

				// Reject the command with the error.
				command.reject(error);
			});
		}
	}]);

	return CommandQueue;
}(_events.EventEmitter);

exports.default = CommandQueue;
},{"./Logger":33,"./errors":38,"events":73}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PROFILES = new Set(['default', 'low', 'medium', 'high']);
var DEFAULT_STATS_INTERVAL = 1000;

var logger = new _Logger2.default('Consumer');

var Consumer = function (_EnhancedEventEmitter) {
	_inherits(Consumer, _EnhancedEventEmitter);

	/**
  * @private
  *
  * @emits {originator: String, [appData]: Any} pause
  * @emits {originator: String, [appData]: Any} resume
  * @emits {profile: String} effectiveprofilechange
  * @emits {stats: Object} stats
  * @emits unhandled
  * @emits {originator: String} close
  *
  * @emits @close
  */
	function Consumer(id, kind, rtpParameters, peer, appData) {
		_classCallCheck(this, Consumer);

		// Id.
		// @type {Number}
		var _this = _possibleConstructorReturn(this, (Consumer.__proto__ || Object.getPrototypeOf(Consumer)).call(this, logger));

		_this._id = id;

		// Closed flag.
		// @type {Boolean}
		_this._closed = false;

		// Media kind.
		// @type {String}
		_this._kind = kind;

		// RTP parameters.
		// @type {RTCRtpParameters}
		_this._rtpParameters = rtpParameters;

		// Associated Peer.
		// @type {Peer}
		_this._peer = peer;

		// App custom data.
		// @type {Any}
		_this._appData = appData;

		// Whether we can receive this Consumer (based on our RTP capabilities).
		// @type {Boolean}
		_this._supported = false;

		// Associated Transport.
		// @type {Transport}
		_this._transport = null;

		// Remote track.
		// @type {MediaStreamTrack}
		_this._track = null;

		// Locally paused flag.
		// @type {Boolean}
		_this._locallyPaused = false;

		// Remotely paused flag.
		// @type {Boolean}
		_this._remotelyPaused = false;

		// Periodic stats flag.
		// @type {Boolean}
		_this._statsEnabled = false;

		// Periodic stats gathering interval (milliseconds).
		// @type {Number}
		_this._statsInterval = DEFAULT_STATS_INTERVAL;

		// Preferred profile.
		// @type {String}
		_this._preferredProfile = 'default';

		// Effective profile.
		// @type {String}
		_this._effectiveProfile = null;
		return _this;
	}

	/**
  * Consumer id.
  *
  * @return {Number}
  */


	_createClass(Consumer, [{
		key: 'close',


		/**
   * Closes the Consumer.
   * This is called when the local Room is closed.
   *
   * @private
   */
		value: function close() {
			logger.debug('close()');

			if (this._closed) return;

			this._closed = true;

			if (this._statsEnabled) {
				this._statsEnabled = false;

				if (this.transport) this.transport.disableConsumerStats(this);
			}

			this.emit('@close');
			this.safeEmit('close', 'local');

			this._destroy();
		}

		/**
   * My remote Consumer was closed.
   * Invoked via remote notification.
   *
   * @private
   */

	}, {
		key: 'remoteClose',
		value: function remoteClose() {
			logger.debug('remoteClose()');

			if (this._closed) return;

			this._closed = true;

			if (this._transport) this._transport.removeConsumer(this);

			this._destroy();

			this.emit('@close');
			this.safeEmit('close', 'remote');
		}
	}, {
		key: '_destroy',
		value: function _destroy() {
			this._transport = null;

			try {
				this._track.stop();
			} catch (error) {}

			this._track = null;
		}

		/**
   * Receives RTP.
   *
   * @param {transport} Transport instance.
   *
   * @return {Promise} Resolves with a remote MediaStreamTrack.
   */

	}, {
		key: 'receive',
		value: function receive(transport) {
			var _this2 = this;

			logger.debug('receive() [transport:%o]', transport);

			if (this._closed) return Promise.reject(new _errors.InvalidStateError('Consumer closed'));else if (!this._supported) return Promise.reject(new Error('unsupported codecs'));else if (this._transport) return Promise.reject(new Error('already handled by a Transport'));else if ((typeof transport === 'undefined' ? 'undefined' : _typeof(transport)) !== 'object') return Promise.reject(new TypeError('invalid Transport'));

			this._transport = transport;

			return transport.addConsumer(this).then(function (track) {
				_this2._track = track;

				// If we were paused, disable the track.
				if (_this2.paused) track.enabled = false;

				transport.once('@close', function () {
					if (_this2._closed || _this2._transport !== transport) return;

					_this2._transport = null;

					try {
						_this2._track.stop();
					} catch (error) {}

					_this2._track = null;

					_this2.safeEmit('unhandled');
				});

				_this2.safeEmit('handled');

				if (_this2._statsEnabled) transport.enableConsumerStats(_this2, _this2._statsInterval);

				return track;
			}).catch(function (error) {
				_this2._transport = null;

				throw error;
			});
		}

		/**
   * Pauses receiving media.
   *
   * @param {Any} [appData] - App custom data.
   *
   * @return {Boolean} true if paused.
   */

	}, {
		key: 'pause',
		value: function pause(appData) {
			logger.debug('pause()');

			if (this._closed) {
				logger.error('pause() | Consumer closed');

				return false;
			} else if (this._locallyPaused) {
				return true;
			}

			this._locallyPaused = true;

			if (this._track) this._track.enabled = false;

			if (this._transport) this._transport.pauseConsumer(this, appData);

			this.safeEmit('pause', 'local', appData);

			// Return true if really paused.
			return this.paused;
		}

		/**
   * My remote Consumer was paused.
   * Invoked via remote notification.
   *
   * @private
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'remotePause',
		value: function remotePause(appData) {
			logger.debug('remotePause()');

			if (this._closed || this._remotelyPaused) return;

			this._remotelyPaused = true;

			if (this._track) this._track.enabled = false;

			this.safeEmit('pause', 'remote', appData);
		}

		/**
   * Resumes receiving media.
   *
   * @param {Any} [appData] - App custom data.
   *
   * @return {Boolean} true if not paused.
   */

	}, {
		key: 'resume',
		value: function resume(appData) {
			logger.debug('resume()');

			if (this._closed) {
				logger.error('resume() | Consumer closed');

				return false;
			} else if (!this._locallyPaused) {
				return true;
			}

			this._locallyPaused = false;

			if (this._track && !this._remotelyPaused) this._track.enabled = true;

			if (this._transport) this._transport.resumeConsumer(this, appData);

			this.safeEmit('resume', 'local', appData);

			// Return true if not paused.
			return !this.paused;
		}

		/**
   * My remote Consumer was resumed.
   * Invoked via remote notification.
   *
   * @private
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'remoteResume',
		value: function remoteResume(appData) {
			logger.debug('remoteResume()');

			if (this._closed || !this._remotelyPaused) return;

			this._remotelyPaused = false;

			if (this._track && !this._locallyPaused) this._track.enabled = true;

			this.safeEmit('resume', 'remote', appData);
		}

		/**
   * Set preferred receiving profile.
   *
   * @param {String} profile
   */

	}, {
		key: 'setPreferredProfile',
		value: function setPreferredProfile(profile) {
			logger.debug('setPreferredProfile() [profile:%s]', profile);

			if (this._closed) {
				logger.error('setPreferredProfile() | Consumer closed');

				return;
			} else if (profile === this._preferredProfile) {
				return;
			} else if (!PROFILES.has(profile)) {
				logger.error('setPreferredProfile() | invalid profile "%s"', profile);

				return;
			}

			this._preferredProfile = profile;

			if (this._transport) this._transport.setConsumerPreferredProfile(this, this._preferredProfile);
		}

		/**
   * Preferred receiving profile was set on my remote Consumer.
   *
   * @param {String} profile
   */

	}, {
		key: 'remoteSetPreferredProfile',
		value: function remoteSetPreferredProfile(profile) {
			logger.debug('remoteSetPreferredProfile() [profile:%s]', profile);

			if (this._closed || profile === this._preferredProfile) return;

			this._preferredProfile = profile;
		}

		/**
   * Effective receiving profile changed on my remote Consumer.
   *
   * @param {String} profile
   */

	}, {
		key: 'remoteEffectiveProfileChanged',
		value: function remoteEffectiveProfileChanged(profile) {
			logger.debug('remoteEffectiveProfileChanged() [profile:%s]', profile);

			if (this._closed || profile === this._effectiveProfile) return;

			this._effectiveProfile = profile;

			this.safeEmit('effectiveprofilechange', this._effectiveProfile);
		}

		/**
   * Enables periodic stats retrieval.
   */

	}, {
		key: 'enableStats',
		value: function enableStats() {
			var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATS_INTERVAL;

			logger.debug('enableStats() [interval:%s]', interval);

			if (this._closed) {
				logger.error('enableStats() | Consumer closed');

				return;
			}

			if (this._statsEnabled) return;

			if (typeof interval !== 'number' || interval < 1000) this._statsInterval = DEFAULT_STATS_INTERVAL;else this._statsInterval = interval;

			this._statsEnabled = true;

			if (this._transport) this._transport.enableConsumerStats(this, this._statsInterval);
		}

		/**
   * Disables periodic stats retrieval.
   */

	}, {
		key: 'disableStats',
		value: function disableStats() {
			logger.debug('disableStats()');

			if (this._closed) {
				logger.error('disableStats() | Consumer closed');

				return;
			}

			if (!this._statsEnabled) return;

			this._statsEnabled = false;

			if (this._transport) this._transport.disableConsumerStats(this);
		}

		/**
   * Mark this Consumer as suitable for reception or not.
   *
   * @private
   *
   * @param {Boolean} flag
   */

	}, {
		key: 'setSupported',
		value: function setSupported(flag) {
			this._supported = flag;
		}

		/**
   * Receive remote stats.
   *
   * @private
   *
   * @param {Object} stats
   */

	}, {
		key: 'remoteStats',
		value: function remoteStats(stats) {
			this.safeEmit('stats', stats);
		}
	}, {
		key: 'id',
		get: function get() {
			return this._id;
		}

		/**
   * Whether the Consumer is closed.
   *
   * @return {Boolean}
   */

	}, {
		key: 'closed',
		get: function get() {
			return this._closed;
		}

		/**
   * Media kind.
   *
   * @return {String}
   */

	}, {
		key: 'kind',
		get: function get() {
			return this._kind;
		}

		/**
   * RTP parameters.
   *
   * @return {RTCRtpParameters}
   */

	}, {
		key: 'rtpParameters',
		get: function get() {
			return this._rtpParameters;
		}

		/**
   * Associated Peer.
   *
   * @return {Peer}
   */

	}, {
		key: 'peer',
		get: function get() {
			return this._peer;
		}

		/**
   * App custom data.
   *
   * @return {Any}
   */

	}, {
		key: 'appData',
		get: function get() {
			return this._appData;
		}

		/**
   * Whether we can receive this Consumer (based on our RTP capabilities).
   *
   * @return {Boolean}
   */

	}, {
		key: 'supported',
		get: function get() {
			return this._supported;
		}

		/**
   * Associated Transport.
   *
   * @return {Transport}
   */

	}, {
		key: 'transport',
		get: function get() {
			return this._transport;
		}

		/**
   * The associated track (if any yet).
   *
   * @return {MediaStreamTrack|Null}
   */

	}, {
		key: 'track',
		get: function get() {
			return this._track;
		}

		/**
   * Whether the Consumer is locally paused.
   *
   * @return {Boolean}
   */

	}, {
		key: 'locallyPaused',
		get: function get() {
			return this._locallyPaused;
		}

		/**
   * Whether the Consumer is remotely paused.
   *
   * @return {Boolean}
   */

	}, {
		key: 'remotelyPaused',
		get: function get() {
			return this._remotelyPaused;
		}

		/**
   * Whether the Consumer is paused.
   *
   * @return {Boolean}
   */

	}, {
		key: 'paused',
		get: function get() {
			return this._locallyPaused || this._remotelyPaused;
		}

		/**
   * The preferred profile.
   *
   * @type {String}
   */

	}, {
		key: 'preferredProfile',
		get: function get() {
			return this._preferredProfile;
		}

		/**
   * The effective profile.
   *
   * @type {String}
   */

	}, {
		key: 'effectiveProfile',
		get: function get() {
			return this._effectiveProfile;
		}
	}]);

	return Consumer;
}(_EnhancedEventEmitter3.default);

exports.default = Consumer;
},{"./EnhancedEventEmitter":32,"./Logger":33,"./errors":38}],31:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bowser = require('bowser');

var _bowser2 = _interopRequireDefault(_bowser);

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _Chrome = require('./handlers/Chrome55');

var _Chrome2 = _interopRequireDefault(_Chrome);

var _Safari = require('./handlers/Safari11');

var _Safari2 = _interopRequireDefault(_Safari);

var _Firefox = require('./handlers/Firefox50');

var _Firefox2 = _interopRequireDefault(_Firefox);

var _Edge = require('./handlers/Edge11');

var _Edge2 = _interopRequireDefault(_Edge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logger = new _Logger2.default('Device');

/**
 * Class with static members representing the underlying device or browser.
 */

var Device = function () {
	function Device() {
		_classCallCheck(this, Device);
	}

	_createClass(Device, null, [{
		key: 'isSupported',


		/**
   * Whether this device is supported.
   *
   * @return {Boolean}
   */
		value: function isSupported() {
			if (!Device._detected) Device._detect();

			return Boolean(Device._handlerClass);
		}

		/**
   * Returns a suitable WebRTC handler class.
   *
   * @type {Class}
   */

	}, {
		key: '_detect',


		/**
   * Detects the current device/browser.
   *
   * @private
   */
		value: function _detect() {
			var ua = global.navigator.userAgent;
			var browser = _bowser2.default._detect(ua);

			Device._detected = true;
			Device._flag = undefined;
			Device._name = browser.name || 'unknown device';
			Device._version = browser.version || 'unknown vesion';
			Device._bowser = browser;
			Device._handlerClass = null;

			// Chrome, Chromium (desktop and mobile).
			if (_bowser2.default.check({ chrome: '55', chromium: '55' }, true, ua)) {
				Device._flag = 'chrome';
				Device._handlerClass = _Chrome2.default;
			}
			// Firefox (desktop and mobile).
			else if (_bowser2.default.check({ firefox: '50' }, true, ua)) {
					Device._flag = 'firefox';
					Device._handlerClass = _Firefox2.default;
				}
				// Safari (desktop and mobile).
				else if (_bowser2.default.check({ safari: '11' }, true, ua)) {
						Device._flag = 'safari';
						Device._handlerClass = _Safari2.default;
					}
					// Edge (desktop).
					else if (_bowser2.default.check({ msedge: '11' }, true, ua)) {
							Device._flag = 'msedge';
							Device._handlerClass = _Edge2.default;
						}
			// Opera (desktop and mobile).
			if (_bowser2.default.check({ opera: '44' }, true, ua)) {
				Device._flag = 'opera';
				Device._handlerClass = _Chrome2.default;
			}

			if (Device.isSupported()) {
				logger.debug('device supported [flag:%s, name:"%s", version:%s, handler:%s]', Device._flag, Device._name, Device._version, Device._handlerClass.name);
			} else {
				logger.warn('device not supported [name:%s, version:%s]', Device._name, Device._version);
			}
		}
	}, {
		key: 'flag',

		/**
   * Get the device flag.
   *
   * @return {String}
   */
		get: function get() {
			if (!Device._detected) Device._detect();

			return Device._flag;
		}

		/**
   * Get the device name.
   *
   * @return {String}
   */

	}, {
		key: 'name',
		get: function get() {
			if (!Device._detected) Device._detect();

			return Device._name;
		}

		/**
   * Get the device version.
   *
   * @return {String}
   */

	}, {
		key: 'version',
		get: function get() {
			if (!Device._detected) Device._detect();

			return Device._version;
		}

		/**
   * Get the bowser module Object.
   *
   * @return {Object}
   */

	}, {
		key: 'bowser',
		get: function get() {
			if (!Device._detected) Device._detect();

			return Device._bowser;
		}
	}, {
		key: 'Handler',
		get: function get() {
			if (!Device._detected) Device._detect();

			return Device._handlerClass;
		}
	}]);

	return Device;
}();

// Initialized flag.
// @type {Boolean}


exports.default = Device;
Device._detected = false;

// Device flag.
// @type {String}
Device._flag = undefined;

// Device name.
// @type {String}
Device._name = undefined;

// Device version.
// @type {String}
Device._version = undefined;

// bowser module Object.
// @type {Object}
Device._bowser = undefined;

// WebRTC hander for this device.
// @type {Class}
Device._handlerClass = null;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Logger":33,"./handlers/Chrome55":39,"./handlers/Edge11":40,"./handlers/Firefox50":41,"./handlers/Safari11":42,"bowser":7}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EnhancedEventEmitter = function (_EventEmitter) {
	_inherits(EnhancedEventEmitter, _EventEmitter);

	function EnhancedEventEmitter(logger) {
		_classCallCheck(this, EnhancedEventEmitter);

		var _this = _possibleConstructorReturn(this, (EnhancedEventEmitter.__proto__ || Object.getPrototypeOf(EnhancedEventEmitter)).call(this));

		_this.setMaxListeners(Infinity);

		_this._logger = logger || new _Logger2.default('EnhancedEventEmitter');
		return _this;
	}

	_createClass(EnhancedEventEmitter, [{
		key: 'safeEmit',
		value: function safeEmit(event) {
			try {
				for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					args[_key - 1] = arguments[_key];
				}

				this.emit.apply(this, [event].concat(args));
			} catch (error) {
				this._logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);
			}
		}
	}, {
		key: 'safeEmitAsPromise',
		value: function safeEmitAsPromise(event) {
			var _this2 = this;

			for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				args[_key2 - 1] = arguments[_key2];
			}

			return new Promise(function (resolve, reject) {
				var callback = function callback(result) {
					resolve(result);
				};

				var errback = function errback(error) {
					_this2._logger.error('safeEmitAsPromise() | errback called [event:%s]:%o', event, error);

					reject(error);
				};

				_this2.safeEmit.apply(_this2, [event].concat(args, [callback, errback]));
			});
		}
	}]);

	return EnhancedEventEmitter;
}(_events.EventEmitter);

exports.default = EnhancedEventEmitter;
},{"./Logger":33,"events":73}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var APP_NAME = 'mediasoup-client';

var Logger = function () {
	function Logger(prefix) {
		_classCallCheck(this, Logger);

		if (prefix) {
			this._debug = (0, _debug2.default)(APP_NAME + ':' + prefix);
			this._warn = (0, _debug2.default)(APP_NAME + ':WARN:' + prefix);
			this._error = (0, _debug2.default)(APP_NAME + ':ERROR:' + prefix);
		} else {
			this._debug = (0, _debug2.default)(APP_NAME);
			this._warn = (0, _debug2.default)(APP_NAME + ':WARN');
			this._error = (0, _debug2.default)(APP_NAME + ':ERROR');
		}

		/* eslint-disable no-console */
		this._debug.log = console.info.bind(console);
		this._warn.log = console.warn.bind(console);
		this._error.log = console.error.bind(console);
		/* eslint-enable no-console */
	}

	_createClass(Logger, [{
		key: 'debug',
		get: function get() {
			return this._debug;
		}
	}, {
		key: 'warn',
		get: function get() {
			return this._warn;
		}
	}, {
		key: 'error',
		get: function get() {
			return this._error;
		}
	}]);

	return Logger;
}();

exports.default = Logger;
},{"debug":52}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var logger = new _Logger2.default('Peer');

var Peer = function (_EnhancedEventEmitter) {
	_inherits(Peer, _EnhancedEventEmitter);

	/**
  * @private
  *
  * @emits {consumer: Consumer} newconsumer
  * @emits {originator: String, [appData]: Any} close
  *
  * @emits @close
  */
	function Peer(name, appData) {
		_classCallCheck(this, Peer);

		// Name.
		// @type {String}
		var _this = _possibleConstructorReturn(this, (Peer.__proto__ || Object.getPrototypeOf(Peer)).call(this, logger));

		_this._name = name;

		// Closed flag.
		// @type {Boolean}
		_this._closed = false;

		// App custom data.
		// @type {Any}
		_this._appData = appData;

		// Map of Consumers indexed by id.
		// @type {map<Number, Consumer>}
		_this._consumers = new Map();
		return _this;
	}

	/**
  * Peer name.
  *
  * @return {String}
  */


	_createClass(Peer, [{
		key: 'close',


		/**
   * Closes the Peer.
   * This is called when the local Room is closed.
   *
   * @private
   */
		value: function close() {
			logger.debug('close()');

			if (this._closed) return;

			this._closed = true;

			this.emit('@close');
			this.safeEmit('close', 'local');

			// Close all the Consumers.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this._consumers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var consumer = _step.value;

					consumer.close();
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		/**
   * The remote Peer or Room was closed.
   * Invoked via remote notification.
   *
   * @private
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'remoteClose',
		value: function remoteClose(appData) {
			logger.debug('remoteClose()');

			if (this._closed) return;

			this._closed = true;

			this.emit('@close');
			this.safeEmit('close', 'remote', appData);

			// Close all the Consumers.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._consumers.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var consumer = _step2.value;

					consumer.remoteClose();
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}

		/**
   * Get the Consumer with the given id.
   *
   * @param {Number} id
   *
   * @return {Consumer}
   */

	}, {
		key: 'getConsumerById',
		value: function getConsumerById(id) {
			return this._consumers.get(id);
		}

		/**
   * Add an associated Consumer.
   *
   * @private
   *
   * @param {Consumer} consumer
   */

	}, {
		key: 'addConsumer',
		value: function addConsumer(consumer) {
			var _this2 = this;

			if (this._consumers.has(consumer.id)) throw new Error('Consumer already exists [id:' + consumer.id + ']');

			// Store it.
			this._consumers.set(consumer.id, consumer);

			// Handle it.
			consumer.on('@close', function () {
				_this2._consumers.delete(consumer.id);
			});

			// Emit event.
			this.safeEmit('newconsumer', consumer);
		}
	}, {
		key: 'name',
		get: function get() {
			return this._name;
		}

		/**
   * Whether the Peer is closed.
   *
   * @return {Boolean}
   */

	}, {
		key: 'closed',
		get: function get() {
			return this._closed;
		}

		/**
   * App custom data.
   *
   * @return {Any}
   */

	}, {
		key: 'appData',
		get: function get() {
			return this._appData;
		}

		/**
   * The list of Consumers.
   *
   * @return {Array<Consumer>}
   */

	}, {
		key: 'consumers',
		get: function get() {
			return Array.from(this._consumers.values());
		}
	}]);

	return Peer;
}(_EnhancedEventEmitter3.default);

exports.default = Peer;
},{"./EnhancedEventEmitter":32,"./Logger":33}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

var _errors = require('./errors');

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_STATS_INTERVAL = 1000;
var SIMULCAST_DEFAULT = {
	low: 100000,
	medium: 300000,
	high: 1500000
};

var logger = new _Logger2.default('Producer');

var Producer = function (_EnhancedEventEmitter) {
	_inherits(Producer, _EnhancedEventEmitter);

	/**
  * @private
  *
  * @emits {originator: String, [appData]: Any} pause
  * @emits {originator: String, [appData]: Any} resume
  * @emits {stats: Object} stats
  * @emits unhandled
  * @emits trackended
  * @emits {originator: String, [appData]: Any} close
  *
  * @emits {originator: String, [appData]: Any} @close
  */
	function Producer(track, options, appData) {
		_classCallCheck(this, Producer);

		// Id.
		// @type {Number}
		var _this = _possibleConstructorReturn(this, (Producer.__proto__ || Object.getPrototypeOf(Producer)).call(this, logger));

		_this._id = utils.randomNumber();

		// Closed flag.
		// @type {Boolean}
		_this._closed = false;

		// Original track.
		// @type {MediaStreamTrack}
		_this._originalTrack = track;

		// Track cloned from the original one.
		// @type {MediaStreamTrack}
		_this._track = track.clone();

		// App custom data.
		// @type {Any}
		_this._appData = appData;

		// Simulcast.
		// @type {Object|false}
		_this._simulcast = false;

		if (options.simulcast) _this._simulcast = Object.assign({}, SIMULCAST_DEFAULT, options.simulcast);

		// Associated Transport.
		// @type {Transport}
		_this._transport = null;

		// RTP parameters.
		// @type {RTCRtpParameters}
		_this._rtpParameters = null;

		// Locally paused flag.
		// @type {Boolean}
		_this._locallyPaused = !_this._track.enabled;

		// Remotely paused flag.
		// @type {Boolean}
		_this._remotelyPaused = false;

		// Periodic stats flag.
		// @type {Boolean}
		_this._statsEnabled = false;

		// Periodic stats gathering interval (milliseconds).
		// @type {Number}
		_this._statsInterval = DEFAULT_STATS_INTERVAL;

		// Handle the effective track.
		_this._handleTrack();
		return _this;
	}

	/**
  * Producer id.
  *
  * @return {Number}
  */


	_createClass(Producer, [{
		key: 'close',


		/**
   * Closes the Producer.
   *
   * @param {Any} [appData] - App custom data.
   */
		value: function close(appData) {
			logger.debug('close()');

			if (this._closed) return;

			this._closed = true;

			if (this._statsEnabled) {
				this._statsEnabled = false;

				if (this.transport) {
					this.transport.disableProducerStats(this);
				}
			}

			if (this._transport) this._transport.removeProducer(this, 'local', appData);

			this._destroy();

			this.emit('@close', 'local', appData);
			this.safeEmit('close', 'local', appData);
		}

		/**
   * My remote Producer was closed.
   * Invoked via remote notification.
   *
   * @private
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'remoteClose',
		value: function remoteClose(appData) {
			logger.debug('remoteClose()');

			if (this._closed) return;

			this._closed = true;

			if (this._transport) this._transport.removeProducer(this, 'remote', appData);

			this._destroy();

			this.emit('@close', 'remote', appData);
			this.safeEmit('close', 'remote', appData);
		}
	}, {
		key: '_destroy',
		value: function _destroy() {
			this._transport = false;
			this._rtpParameters = null;

			try {
				this._track.stop();
			} catch (error) {}
		}

		/**
   * Sends RTP.
   *
   * @param {transport} Transport instance.
   *
   * @return {Promise}
   */

	}, {
		key: 'send',
		value: function send(transport) {
			var _this2 = this;

			logger.debug('send() [transport:%o]', transport);

			if (this._closed) return Promise.reject(new _errors.InvalidStateError('Producer closed'));else if (this._transport) return Promise.reject(new Error('already handled by a Transport'));else if ((typeof transport === 'undefined' ? 'undefined' : _typeof(transport)) !== 'object') return Promise.reject(new TypeError('invalid Transport'));

			this._transport = transport;

			return transport.addProducer(this).then(function () {
				transport.once('@close', function () {
					if (_this2._closed || _this2._transport !== transport) return;

					_this2._transport.removeProducer(_this2, 'local');

					_this2._transport = null;
					_this2._rtpParameters = null;

					_this2.safeEmit('unhandled');
				});

				_this2.safeEmit('handled');

				if (_this2._statsEnabled) transport.enableProducerStats(_this2, _this2._statsInterval);
			}).catch(function (error) {
				_this2._transport = null;

				throw error;
			});
		}

		/**
   * Pauses sending media.
   *
   * @param {Any} [appData] - App custom data.
   *
   * @return {Boolean} true if paused.
   */

	}, {
		key: 'pause',
		value: function pause(appData) {
			logger.debug('pause()');

			if (this._closed) {
				logger.error('pause() | Producer closed');

				return false;
			} else if (this._locallyPaused) {
				return true;
			}

			this._locallyPaused = true;
			this._track.enabled = false;

			if (this._transport) this._transport.pauseProducer(this, appData);

			this.safeEmit('pause', 'local', appData);

			// Return true if really paused.
			return this.paused;
		}

		/**
   * My remote Producer was paused.
   * Invoked via remote notification.
   *
   * @private
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'remotePause',
		value: function remotePause(appData) {
			logger.debug('remotePause()');

			if (this._closed || this._remotelyPaused) return;

			this._remotelyPaused = true;
			this._track.enabled = false;

			this.safeEmit('pause', 'remote', appData);
		}

		/**
   * Resumes sending media.
   *
   * @param {Any} [appData] - App custom data.
   *
   * @return {Boolean} true if not paused.
   */

	}, {
		key: 'resume',
		value: function resume(appData) {
			logger.debug('resume()');

			if (this._closed) {
				logger.error('resume() | Producer closed');

				return false;
			} else if (!this._locallyPaused) {
				return true;
			}

			this._locallyPaused = false;

			if (!this._remotelyPaused) this._track.enabled = true;

			if (this._transport) this._transport.resumeProducer(this, appData);

			this.safeEmit('resume', 'local', appData);

			// Return true if not paused.
			return !this.paused;
		}

		/**
   * My remote Producer was resumed.
   * Invoked via remote notification.
   *
   * @private
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'remoteResume',
		value: function remoteResume(appData) {
			logger.debug('remoteResume()');

			if (this._closed || !this._remotelyPaused) return;

			this._remotelyPaused = false;

			if (!this._locallyPaused) this._track.enabled = true;

			this.safeEmit('resume', 'remote', appData);
		}

		/**
   * Replaces the current track with a new one.
   *
   * @param {MediaStreamTrack} track - New track.
   *
   * @return {Promise} Resolves with the new track itself.
   */

	}, {
		key: 'replaceTrack',
		value: function replaceTrack(track) {
			var _this3 = this;

			logger.debug('replaceTrack() [track:%o]', track);

			if (this._closed) return Promise.reject(new _errors.InvalidStateError('Producer closed'));else if (!(track instanceof MediaStreamTrack)) return Promise.reject(new TypeError('track is not a MediaStreamTrack'));else if (track.readyState === 'ended') return Promise.reject(new Error('track.readyState is "ended"'));

			var clonedTrack = track.clone();

			return Promise.resolve().then(function () {
				// If this Producer is handled by a Transport, we need to tell it about
				// the new track.
				if (_this3._transport) return _this3._transport.replaceProducerTrack(_this3, clonedTrack);
			}).then(function () {
				// Stop the previous track.
				try {
					_this3._track.onended = null;_this3._track.stop();
				} catch (error) {}

				// If this Producer was locally paused/resumed and the state of the new
				// track does not match, fix it.
				if (!_this3.paused) clonedTrack.enabled = true;else clonedTrack.enabled = false;

				// Set the new tracks.
				_this3._originalTrack = track;
				_this3._track = clonedTrack;

				// Handle the effective track.
				_this3._handleTrack();

				// Return the new track.
				return _this3._track;
			});
		}

		/**
   * Set/update RTP parameters.
   *
   * @private
   *
   * @param {RTCRtpParameters} rtpParameters
   */

	}, {
		key: 'setRtpParameters',
		value: function setRtpParameters(rtpParameters) {
			this._rtpParameters = rtpParameters;
		}

		/**
   * Enables periodic stats retrieval.
   */

	}, {
		key: 'enableStats',
		value: function enableStats() {
			var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATS_INTERVAL;

			logger.debug('enableStats() [interval:%s]', interval);

			if (this._closed) {
				logger.error('enableStats() | Producer closed');

				return;
			}

			if (this._statsEnabled) return;

			if (typeof interval !== 'number' || interval < 1000) this._statsInterval = DEFAULT_STATS_INTERVAL;else this._statsInterval = interval;

			this._statsEnabled = true;

			if (this._transport) this._transport.enableProducerStats(this, this._statsInterval);
		}

		/**
   * Disables periodic stats retrieval.
   */

	}, {
		key: 'disableStats',
		value: function disableStats() {
			logger.debug('disableStats()');

			if (this._closed) {
				logger.error('disableStats() | Producer closed');

				return;
			}

			if (!this._statsEnabled) return;

			this._statsEnabled = false;

			if (this._transport) this._transport.disableProducerStats(this);
		}

		/**
   * Receive remote stats.
   *
   * @private
   *
   * @param {Object} stats
   */

	}, {
		key: 'remoteStats',
		value: function remoteStats(stats) {
			this.safeEmit('stats', stats);
		}

		/**
   * @private
   */

	}, {
		key: '_handleTrack',
		value: function _handleTrack() {
			var _this4 = this;

			// If the cloned track is closed (for example if the desktop sharing is closed
			// via chrome UI) close the Producer.
			this._track.onended = function () {
				if (_this4._closed) return;

				logger.warn('track "ended" event, closing Producer');

				_this4.safeEmit('trackended');
				_this4.close();
			};
		}
	}, {
		key: 'id',
		get: function get() {
			return this._id;
		}

		/**
   * Whether the Producer is closed.
   *
   * @return {Boolean}
   */

	}, {
		key: 'closed',
		get: function get() {
			return this._closed;
		}

		/**
   * Media kind.
   *
   * @return {String}
   */

	}, {
		key: 'kind',
		get: function get() {
			return this._track.kind;
		}

		/**
   * The associated track.
   *
   * @return {MediaStreamTrack}
   */

	}, {
		key: 'track',
		get: function get() {
			return this._track;
		}

		/**
   * The associated original track.
   *
   * @return {MediaStreamTrack}
   */

	}, {
		key: 'originalTrack',
		get: function get() {
			return this._originalTrack;
		}

		/**
   * Simulcast settings.
   *
   * @return {Object|false}
   */

	}, {
		key: 'simulcast',
		get: function get() {
			return this._simulcast;
		}

		/**
   * App custom data.
   *
   * @return {Any}
   */

	}, {
		key: 'appData',
		get: function get() {
			return this._appData;
		}

		/**
   * Associated Transport.
   *
   * @return {Transport}
   */

	}, {
		key: 'transport',
		get: function get() {
			return this._transport;
		}

		/**
   * RTP parameters.
   *
   * @return {RTCRtpParameters}
   */

	}, {
		key: 'rtpParameters',
		get: function get() {
			return this._rtpParameters;
		}

		/**
   * Whether the Producer is locally paused.
   *
   * @return {Boolean}
   */

	}, {
		key: 'locallyPaused',
		get: function get() {
			return this._locallyPaused;
		}

		/**
   * Whether the Producer is remotely paused.
   *
   * @return {Boolean}
   */

	}, {
		key: 'remotelyPaused',
		get: function get() {
			return this._remotelyPaused;
		}

		/**
   * Whether the Producer is paused.
   *
   * @return {Boolean}
   */

	}, {
		key: 'paused',
		get: function get() {
			return this._locallyPaused || this._remotelyPaused;
		}
	}]);

	return Producer;
}(_EnhancedEventEmitter3.default);

exports.default = Producer;
},{"./EnhancedEventEmitter":32,"./Logger":33,"./errors":38,"./utils":51}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

var _errors = require('./errors');

var _ortc = require('./ortc');

var ortc = _interopRequireWildcard(_ortc);

var _Device = require('./Device');

var _Device2 = _interopRequireDefault(_Device);

var _Transport = require('./Transport');

var _Transport2 = _interopRequireDefault(_Transport);

var _Producer = require('./Producer');

var _Producer2 = _interopRequireDefault(_Producer);

var _Peer = require('./Peer');

var _Peer2 = _interopRequireDefault(_Peer);

var _Consumer = require('./Consumer');

var _Consumer2 = _interopRequireDefault(_Consumer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var logger = new _Logger2.default('Room');

var RoomState = {
	new: 'new',
	joining: 'joining',
	joined: 'joined',
	closed: 'closed'
};

/**
 * An instance of Room represents a remote multi conference and a local
 * peer that joins it.
 */

var Room = function (_EnhancedEventEmitter) {
	_inherits(Room, _EnhancedEventEmitter);

	/**
  * Room class.
  *
  * @param {Object} [options]
  * @param {Object} [roomSettings] Remote room settings, including its RTP
  * capabilities, mandatory codecs, etc. If given, no 'queryRoom' request is sent
  * to the server to discover them.
  * @param {Number} [options.requestTimeout=10000] - Timeout for sent requests
  * (in milliseconds). Defaults to 10000 (10 seconds).
  * @param {Object} [options.transportOptions] - Options for Transport created in mediasoup.
  * @param {Array<RTCIceServer>} [options.turnServers] - Array of TURN servers.
  *
  * @throws {Error} if device is not supported.
  *
  * @emits {request: Object, callback: Function, errback: Function} request
  * @emits {notification: Object} notify
  * @emits {peer: Peer} newpeer
  * @emits {originator: String, [appData]: Any} close
  */
	function Room(options) {
		_classCallCheck(this, Room);

		var _this = _possibleConstructorReturn(this, (Room.__proto__ || Object.getPrototypeOf(Room)).call(this, logger));

		logger.debug('constructor() [options:%o]', options);

		if (!_Device2.default.isSupported()) throw new Error('current browser/device not supported');

		options = options || {};

		// Computed settings.
		// @type {Object}
		_this._settings = {
			roomSettings: options.roomSettings,
			requestTimeout: options.requestTimeout || 10000,
			transportOptions: options.transportOptions || {},
			turnServers: options.turnServers || []
		};

		// Room state.
		// @type {Boolean}
		_this._state = RoomState.new;

		// My mediasoup Peer name.
		// @type {String}
		_this._peerName = null;

		// Map of Transports indexed by id.
		// @type {map<Number, Transport>}
		_this._transports = new Map();

		// Map of Producers indexed by id.
		// @type {map<Number, Producer>}
		_this._producers = new Map();

		// Map of Peers indexed by name.
		// @type {map<String, Peer>}
		_this._peers = new Map();

		// Extended RTP capabilities.
		// @type {Object}
		_this._extendedRtpCapabilities = null;

		// Whether we can send audio/video based on computed extended RTP
		// capabilities.
		// @type {Object}
		_this._canSendByKind = {
			audio: false,
			video: false
		};
		return _this;
	}

	/**
  * Whether the Room is joined.
  *
  * @return {Boolean}
  */


	_createClass(Room, [{
		key: 'getTransportById',


		/**
   * Get the Transport with the given id.
   *
   * @param {Number} id
   *
   * @return {Transport}
   */
		value: function getTransportById(id) {
			return this._transports.get(id);
		}

		/**
   * Get the Producer with the given id.
   *
   * @param {Number} id
   *
   * @return {Producer}
   */

	}, {
		key: 'getProducerById',
		value: function getProducerById(id) {
			return this._producers.get(id);
		}

		/**
   * Get the Peer with the given name.
   *
   * @param {String} name
   *
   * @return {Peer}
   */

	}, {
		key: 'getPeerByName',
		value: function getPeerByName(name) {
			return this._peers.get(name);
		}

		/**
   * Start the procedures to join a remote room.
   * @param {String} peerName - My mediasoup Peer name.
   * @param {Any} [appData] - App custom data.
   * @return {Promise}
   */

	}, {
		key: 'join',
		value: function join(peerName, appData) {
			var _this2 = this;

			logger.debug('join() [peerName:"%s"]', peerName);

			if (typeof peerName !== 'string') return Promise.reject(new TypeError('invalid peerName'));

			if (this._state !== RoomState.new && this._state !== RoomState.closed) {
				return Promise.reject(new _errors.InvalidStateError('invalid state "' + this._state + '"'));
			}

			this._peerName = peerName;
			this._state = RoomState.joining;

			var roomSettings = void 0;

			return Promise.resolve().then(function () {
				// If Room settings are provided don't query them.
				if (_this2._settings.roomSettings) {
					roomSettings = _this2._settings.roomSettings;

					return;
				} else {
					return _this2._sendRequest('queryRoom', { target: 'room' }).then(function (response) {
						roomSettings = response;

						logger.debug('join() | got Room settings:%o', roomSettings);
					});
				}
			}).then(function () {
				return _Device2.default.Handler.getNativeRtpCapabilities();
			}).then(function (nativeRtpCapabilities) {
				logger.debug('join() | native RTP capabilities:%o', nativeRtpCapabilities);

				// Get extended RTP capabilities.
				_this2._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, roomSettings.rtpCapabilities);

				logger.debug('join() | extended RTP capabilities:%o', _this2._extendedRtpCapabilities);

				// Check unsupported codecs.
				var unsupportedRoomCodecs = ortc.getUnsupportedCodecs(roomSettings.rtpCapabilities, roomSettings.mandatoryCodecPayloadTypes, _this2._extendedRtpCapabilities);

				if (unsupportedRoomCodecs.length > 0) {
					logger.error('%s mandatory room codecs not supported:%o', unsupportedRoomCodecs.length, unsupportedRoomCodecs);

					throw new _errors.UnsupportedError('mandatory room codecs not supported', unsupportedRoomCodecs);
				}

				// Check whether we can send audio/video.
				_this2._canSendByKind.audio = ortc.canSend('audio', _this2._extendedRtpCapabilities);
				_this2._canSendByKind.video = ortc.canSend('video', _this2._extendedRtpCapabilities);

				// Generate our effective RTP capabilities for receiving media.
				var effectiveLocalRtpCapabilities = ortc.getRtpCapabilities(_this2._extendedRtpCapabilities);

				logger.debug('join() | effective local RTP capabilities for receiving:%o', effectiveLocalRtpCapabilities);

				var data = {
					target: 'room',
					peerName: _this2._peerName,
					rtpCapabilities: effectiveLocalRtpCapabilities,
					appData: appData
				};

				return _this2._sendRequest('join', data).then(function (response) {
					return response.peers;
				});
			}).then(function (peers) {
				// Handle Peers already existing in the room.
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = (peers || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var peerData = _step.value;

						try {
							_this2._handlePeerData(peerData);
						} catch (error) {
							logger.error('join() | error handling Peer:%o', error);
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				_this2._state = RoomState.joined;

				logger.debug('join() | joined the Room');

				// Return the list of already existing Peers.
				return _this2.peers;
			}).catch(function (error) {
				_this2._state = RoomState.new;

				throw error;
			});
		}

		/**
   * Leave the Room.
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'leave',
		value: function leave(appData) {
			logger.debug('leave()');

			if (this.closed) return;

			// Send a notification.
			this._sendNotification('leave', { appData: appData });

			// Set closed state after sending the notification (otherwise the
			// notification won't be sent).
			this._state = RoomState.closed;

			this.safeEmit('close', 'local', appData);

			// Close all the Transports.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._transports.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var transport = _step2.value;

					transport.close();
				}

				// Close all the Producers.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this._producers.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var producer = _step3.value;

					producer.close();
				}

				// Close all the Peers.
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = this._peers.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var peer = _step4.value;

					peer.close();
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}
		}

		/**
   * The remote Room was closed or our remote Peer has been closed.
   * Invoked via remote notification or via API.
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'remoteClose',
		value: function remoteClose(appData) {
			logger.debug('remoteClose()');

			if (this.closed) return;

			this._state = RoomState.closed;

			this.safeEmit('close', 'remote', appData);

			// Close all the Transports.
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = this._transports.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var transport = _step5.value;

					transport.remoteClose();
				}

				// Close all the Producers.
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = this._producers.values()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					var producer = _step6.value;

					producer.remoteClose();
				}

				// Close all the Peers.
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 && _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}

			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = this._peers.values()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var peer = _step7.value;

					peer.remoteClose();
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}
		}

		/**
   * Whether we can send audio/video.
   *
   * @param {String} kind - 'audio' or 'video'.
   *
   * @return {Boolean}
   */

	}, {
		key: 'canSend',
		value: function canSend(kind) {
			if (!this.joined) throw new _errors.InvalidStateError('invalid state "' + this._state + '"');else if (kind !== 'audio' && kind !== 'video') throw new TypeError('invalid kind "' + kind + '"');

			return this._canSendByKind[kind];
		}

		/**
   * Creates a Transport.
   *
   * @param {String} direction - Must be 'send' or 'recv'.
   * @param {Any} [appData] - App custom data.
   *
   * @return {Transport}
   *
   * @throws {InvalidStateError} if not joined.
   * @throws {TypeError} if wrong arguments.
   */

	}, {
		key: 'createTransport',
		value: function createTransport(direction, appData) {
			var _this3 = this;

			logger.debug('createTransport() [direction:%s]', direction);

			if (!this.joined) throw new _errors.InvalidStateError('invalid state "' + this._state + '"');else if (direction !== 'send' && direction !== 'recv') throw new TypeError('invalid direction "' + direction + '"');

			// Create a new Transport.
			var transport = new _Transport2.default(direction, this._extendedRtpCapabilities, this._settings, appData);

			// Store it.
			this._transports.set(transport.id, transport);

			transport.on('@request', function (method, data, callback, errback) {
				_this3._sendRequest(method, data).then(callback).catch(errback);
			});

			transport.on('@notify', function (method, data) {
				_this3._sendNotification(method, data);
			});

			transport.on('@close', function () {
				_this3._transports.delete(transport.id);
			});

			return transport;
		}

		/**
   * Creates a Producer.
   *
   * @param {MediaStreamTrack} track
   * @param {Object} [options]
   * @param {Object} [options.simulcast]
   * @param {Any} [appData] - App custom data.
   *
   * @return {Producer}
   *
   * @throws {InvalidStateError} if not joined.
   * @throws {TypeError} if wrong arguments.
   * @throws {Error} if cannot send the given kind.
   */

	}, {
		key: 'createProducer',
		value: function createProducer(track, options, appData) {
			var _this4 = this;

			logger.debug('createProducer() [track:%o, options:%o]', track, options);

			if (!this.joined) throw new _errors.InvalidStateError('invalid state "' + this._state + '"');else if (!(track instanceof MediaStreamTrack)) throw new TypeError('track is not a MediaStreamTrack');else if (!this._canSendByKind[track.kind]) throw new Error('cannot send ' + track.kind);else if (track.readyState === 'ended') throw new Error('track.readyState is "ended"');

			options = options || {};

			// Create a new Producer.
			var producer = new _Producer2.default(track, options, appData);

			// Store it.
			this._producers.set(producer.id, producer);

			producer.on('@close', function () {
				_this4._producers.delete(producer.id);
			});

			return producer;
		}

		/**
   * Produce a ICE restart in all the Transports.
   */

	}, {
		key: 'restartIce',
		value: function restartIce() {
			if (!this.joined) throw new _errors.InvalidStateError('invalid state "' + this._state + '"');

			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = this._transports.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var transport = _step8.value;

					transport.restartIce();
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}
		}

		/**
   * Provide the local Room with a notification generated by mediasoup server.
   *
   * @param {Object} notification
   */

	}, {
		key: 'receiveNotification',
		value: function receiveNotification(notification) {
			var _this5 = this;

			if (this.closed) return Promise.reject(new _errors.InvalidStateError('Room closed'));else if ((typeof notification === 'undefined' ? 'undefined' : _typeof(notification)) !== 'object') return Promise.reject(new TypeError('wrong notification Object'));else if (notification.notification !== true) return Promise.reject(new TypeError('not a notification'));else if (typeof notification.method !== 'string') return Promise.reject(new TypeError('wrong/missing notification method'));

			var method = notification.method;


			logger.debug('receiveNotification() [method:%s, notification:%o]', method, notification);

			return Promise.resolve().then(function () {
				switch (method) {
					case 'closed':
						{
							var appData = notification.appData;


							_this5.remoteClose(appData);

							break;
						}

					case 'transportClosed':
						{
							var id = notification.id,
							    _appData = notification.appData;

							var transport = _this5._transports.get(id);

							if (!transport) throw new Error('Transport not found [id:"' + id + '"]');

							transport.remoteClose(_appData);

							break;
						}

					case 'transportStats':
						{
							var _id = notification.id,
							    stats = notification.stats;

							var _transport = _this5._transports.get(_id);

							if (!_transport) throw new Error('transport not found [id:' + _id + ']');

							_transport.remoteStats(stats);

							break;
						}

					case 'newPeer':
						{
							var name = notification.name;


							if (_this5._peers.has(name)) throw new Error('Peer already exists [name:"' + name + '"]');

							var peerData = notification;

							_this5._handlePeerData(peerData);

							break;
						}

					case 'peerClosed':
						{
							var peerName = notification.name;
							var _appData2 = notification.appData;

							var peer = _this5._peers.get(peerName);

							if (!peer) throw new Error('no Peer found [name:"' + peerName + '"]');

							peer.remoteClose(_appData2);

							break;
						}

					case 'producerPaused':
						{
							var _id2 = notification.id,
							    _appData3 = notification.appData;

							var producer = _this5._producers.get(_id2);

							if (!producer) throw new Error('Producer not found [id:' + _id2 + ']');

							producer.remotePause(_appData3);

							break;
						}

					case 'producerResumed':
						{
							var _id3 = notification.id,
							    _appData4 = notification.appData;

							var _producer = _this5._producers.get(_id3);

							if (!_producer) throw new Error('Producer not found [id:' + _id3 + ']');

							_producer.remoteResume(_appData4);

							break;
						}

					case 'producerClosed':
						{
							var _id4 = notification.id,
							    _appData5 = notification.appData;

							var _producer2 = _this5._producers.get(_id4);

							if (!_producer2) throw new Error('Producer not found [id:' + _id4 + ']');

							_producer2.remoteClose(_appData5);

							break;
						}

					case 'producerStats':
						{
							var _id5 = notification.id,
							    _stats = notification.stats;

							var _producer3 = _this5._producers.get(_id5);

							if (!_producer3) throw new Error('Producer not found [id:' + _id5 + ']');

							_producer3.remoteStats(_stats);

							break;
						}

					case 'newConsumer':
						{
							var _peerName = notification.peerName;

							var _peer = _this5._peers.get(_peerName);

							if (!_peer) throw new Error('no Peer found [name:"' + _peerName + '"]');

							var consumerData = notification;

							_this5._handleConsumerData(consumerData, _peer);

							break;
						}

					case 'consumerClosed':
						{
							var _id6 = notification.id,
							    _peerName2 = notification.peerName,
							    _appData6 = notification.appData;

							var _peer2 = _this5._peers.get(_peerName2);

							if (!_peer2) throw new Error('no Peer found [name:"' + _peerName2 + '"]');

							var consumer = _peer2.getConsumerById(_id6);

							if (!consumer) throw new Error('Consumer not found [id:' + _id6 + ']');

							consumer.remoteClose(_appData6);

							break;
						}

					case 'consumerPaused':
						{
							var _id7 = notification.id,
							    _peerName3 = notification.peerName,
							    _appData7 = notification.appData;

							var _peer3 = _this5._peers.get(_peerName3);

							if (!_peer3) throw new Error('no Peer found [name:"' + _peerName3 + '"]');

							var _consumer = _peer3.getConsumerById(_id7);

							if (!_consumer) throw new Error('Consumer not found [id:' + _id7 + ']');

							_consumer.remotePause(_appData7);

							break;
						}

					case 'consumerResumed':
						{
							var _id8 = notification.id,
							    _peerName4 = notification.peerName,
							    _appData8 = notification.appData;

							var _peer4 = _this5._peers.get(_peerName4);

							if (!_peer4) throw new Error('no Peer found [name:"' + _peerName4 + '"]');

							var _consumer2 = _peer4.getConsumerById(_id8);

							if (!_consumer2) throw new Error('Consumer not found [id:' + _id8 + ']');

							_consumer2.remoteResume(_appData8);

							break;
						}

					case 'consumerPreferredProfileSet':
						{
							var _id9 = notification.id,
							    _peerName5 = notification.peerName,
							    profile = notification.profile;

							var _peer5 = _this5._peers.get(_peerName5);

							if (!_peer5) throw new Error('no Peer found [name:"' + _peerName5 + '"]');

							var _consumer3 = _peer5.getConsumerById(_id9);

							if (!_consumer3) throw new Error('Consumer not found [id:' + _id9 + ']');

							_consumer3.remoteSetPreferredProfile(profile);

							break;
						}

					case 'consumerEffectiveProfileChanged':
						{
							var _id10 = notification.id,
							    _peerName6 = notification.peerName,
							    _profile = notification.profile;

							var _peer6 = _this5._peers.get(_peerName6);

							if (!_peer6) throw new Error('no Peer found [name:"' + _peerName6 + '"]');

							var _consumer4 = _peer6.getConsumerById(_id10);

							if (!_consumer4) throw new Error('Consumer not found [id:' + _id10 + ']');

							_consumer4.remoteEffectiveProfileChanged(_profile);

							break;
						}

					case 'consumerStats':
						{
							var _id11 = notification.id,
							    _peerName7 = notification.peerName,
							    _stats2 = notification.stats;

							var _peer7 = _this5._peers.get(_peerName7);

							if (!_peer7) throw new Error('no Peer found [name:"' + _peerName7 + '"]');

							var _consumer5 = _peer7.getConsumerById(_id11);

							if (!_consumer5) throw new Error('Consumer not found [id:' + _id11 + ']');

							_consumer5.remoteStats(_stats2);

							break;
						}

					default:
						throw new Error('unknown notification method "' + method + '"');
				}
			}).catch(function (error) {
				logger.error('receiveNotification() failed [notification:%o]: %s', notification, error);
			});
		}
	}, {
		key: '_sendRequest',
		value: function _sendRequest(method, data) {
			var _this6 = this;

			var request = Object.assign({ method: method, target: 'peer' }, data);

			// Should never happen.
			// Ignore if closed.
			if (this.closed) {
				logger.error('_sendRequest() | Room closed [method:%s, request:%o]', method, request);

				return Promise.reject(new _errors.InvalidStateError('Room closed'));
			}

			logger.debug('_sendRequest() [method:%s, request:%o]', method, request);

			return new Promise(function (resolve, reject) {
				var done = false;

				var timer = setTimeout(function () {
					logger.error('request failed [method:%s]: timeout', method);

					done = true;
					reject(new _errors.TimeoutError('timeout'));
				}, _this6._settings.requestTimeout);

				var callback = function callback(response) {
					if (done) return;

					done = true;
					clearTimeout(timer);

					if (_this6.closed) {
						logger.error('request failed [method:%s]: Room closed', method);

						reject(new Error('Room closed'));

						return;
					}

					logger.debug('request succeeded [method:%s, response:%o]', method, response);

					resolve(response);
				};

				var errback = function errback(error) {
					if (done) return;

					done = true;
					clearTimeout(timer);

					if (_this6.closed) {
						logger.error('request failed [method:%s]: Room closed', method);

						reject(new Error('Room closed'));

						return;
					}

					// Make sure message is an Error.
					if (!(error instanceof Error)) error = new Error(String(error));

					logger.error('request failed [method:%s]:%o', method, error);

					reject(error);
				};

				_this6.safeEmit('request', request, callback, errback);
			});
		}
	}, {
		key: '_sendNotification',
		value: function _sendNotification(method, data) {
			// Ignore if closed.
			if (this.closed) return;

			var notification = Object.assign({ method: method, target: 'peer', notification: true }, data);

			logger.debug('_sendNotification() [method:%s, notification:%o]', method, notification);

			this.safeEmit('notify', notification);
		}
	}, {
		key: '_handlePeerData',
		value: function _handlePeerData(peerData) {
			var _this7 = this;

			var name = peerData.name,
			    consumers = peerData.consumers,
			    appData = peerData.appData;

			var peer = new _Peer2.default(name, appData);

			// Store it.
			this._peers.set(peer.name, peer);

			peer.on('@close', function () {
				_this7._peers.delete(peer.name);
			});

			// Add consumers.
			var _iteratorNormalCompletion9 = true;
			var _didIteratorError9 = false;
			var _iteratorError9 = undefined;

			try {
				for (var _iterator9 = consumers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
					var consumerData = _step9.value;

					try {
						this._handleConsumerData(consumerData, peer);
					} catch (error) {
						logger.error('error handling existing Consumer in Peer:%o', error);
					}
				}

				// If already joined emit event.
			} catch (err) {
				_didIteratorError9 = true;
				_iteratorError9 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion9 && _iterator9.return) {
						_iterator9.return();
					}
				} finally {
					if (_didIteratorError9) {
						throw _iteratorError9;
					}
				}
			}

			if (this.joined) this.safeEmit('newpeer', peer);
		}
	}, {
		key: '_handleConsumerData',
		value: function _handleConsumerData(producerData, peer) {
			var id = producerData.id,
			    kind = producerData.kind,
			    rtpParameters = producerData.rtpParameters,
			    paused = producerData.paused,
			    appData = producerData.appData;

			var consumer = new _Consumer2.default(id, kind, rtpParameters, peer, appData);
			var supported = ortc.canReceive(consumer.rtpParameters, this._extendedRtpCapabilities);

			if (supported) consumer.setSupported(true);

			if (paused) consumer.remotePause();

			peer.addConsumer(consumer);
		}
	}, {
		key: 'joined',
		get: function get() {
			return this._state === RoomState.joined;
		}

		/**
   * Whether the Room is closed.
   *
   * @return {Boolean}
   */

	}, {
		key: 'closed',
		get: function get() {
			return this._state === RoomState.closed;
		}

		/**
   * My mediasoup Peer name.
   *
   * @return {String}
   */

	}, {
		key: 'peerName',
		get: function get() {
			return this._peerName;
		}

		/**
   * The list of Transports.
   *
   * @return {Array<Transport>}
   */

	}, {
		key: 'transports',
		get: function get() {
			return Array.from(this._transports.values());
		}

		/**
   * The list of Producers.
   *
   * @return {Array<Producer>}
   */

	}, {
		key: 'producers',
		get: function get() {
			return Array.from(this._producers.values());
		}

		/**
   * The list of Peers.
   *
   * @return {Array<Peer>}
   */

	}, {
		key: 'peers',
		get: function get() {
			return Array.from(this._peers.values());
		}
	}]);

	return Room;
}(_EnhancedEventEmitter3.default);

exports.default = Room;
},{"./Consumer":30,"./Device":31,"./EnhancedEventEmitter":32,"./Logger":33,"./Peer":34,"./Producer":35,"./Transport":37,"./errors":38,"./ortc":50}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

var _errors = require('./errors');

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _Device = require('./Device');

var _Device2 = _interopRequireDefault(_Device);

var _CommandQueue = require('./CommandQueue');

var _CommandQueue2 = _interopRequireDefault(_CommandQueue);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_STATS_INTERVAL = 1000;

var logger = new _Logger2.default('Transport');

var Transport = function (_EnhancedEventEmitter) {
	_inherits(Transport, _EnhancedEventEmitter);

	/**
  * @private
  *
  * @emits {state: String} connectionstatechange
  * @emits {stats: Object} stats
  * @emits {originator: String, [appData]: Any} close
  *
  * @emits {method: String, [data]: Object, callback: Function, errback: Function} @request
  * @emits {method: String, [data]: Object} @notify
  * @emits @close
  */
	function Transport(direction, extendedRtpCapabilities, settings, appData) {
		_classCallCheck(this, Transport);

		var _this = _possibleConstructorReturn(this, (Transport.__proto__ || Object.getPrototypeOf(Transport)).call(this, logger));

		logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);

		// Id.
		// @type {Number}
		_this._id = utils.randomNumber();

		// Closed flag.
		// @type {Boolean}
		_this._closed = false;

		// Direction.
		// @type {String}
		_this._direction = direction;

		// Room settings.
		// @type {Object}
		_this._settings = settings;

		// App custom data.
		// @type {Any}
		_this._appData = appData;

		// Periodic stats flag.
		// @type {Boolean}
		_this._statsEnabled = false;

		// Commands handler.
		// @type {CommandQueue}
		_this._commandQueue = new _CommandQueue2.default();

		// Device specific handler.
		_this._handler = new _Device2.default.Handler(direction, extendedRtpCapabilities, settings);

		// Transport state. Values can be:
		// 'new'/'connecting'/'connected'/'failed'/'disconnected'/'closed'
		// @type {String}
		_this._connectionState = 'new';

		_this._commandQueue.on('exec', _this._execCommand.bind(_this));

		_this._handleHandler();
		return _this;
	}

	/**
  * Transport id.
  *
  * @return {Number}
  */


	_createClass(Transport, [{
		key: 'close',


		/**
   * Close the Transport.
   *
   * @param {Any} [appData] - App custom data.
   */
		value: function close(appData) {
			logger.debug('close()');

			if (this._closed) return;

			this._closed = true;

			if (this._statsEnabled) {
				this._statsEnabled = false;
				this.disableStats();
			}

			this.safeEmit('@notify', 'closeTransport', { id: this._id, appData: appData });

			this.emit('@close');
			this.safeEmit('close', 'local', appData);

			this._destroy();
		}

		/**
   * My remote Transport was closed.
   * Invoked via remote notification.
   *
   * @private
   *
   * @param {Any} [appData] - App custom data.
   */

	}, {
		key: 'remoteClose',
		value: function remoteClose(appData) {
			logger.debug('remoteClose()');

			if (this._closed) return;

			this._closed = true;

			this.emit('@close');
			this.safeEmit('close', 'remote', appData);

			this._destroy();
		}
	}, {
		key: '_destroy',
		value: function _destroy() {
			// Close the CommandQueue.
			this._commandQueue.close();

			// Close the handler.
			this._handler.close();
		}
	}, {
		key: 'restartIce',
		value: function restartIce() {
			var _this2 = this;

			logger.debug('restartIce()');

			if (this._closed) return;else if (this._connectionState === 'new') return;

			Promise.resolve().then(function () {
				var data = {
					id: _this2._id
				};

				return _this2.safeEmitAsPromise('@request', 'restartTransport', data);
			}).then(function (response) {
				var remoteIceParameters = response.iceParameters;

				// Enqueue command.
				return _this2._commandQueue.push('restartIce', { remoteIceParameters: remoteIceParameters });
			}).catch(function (error) {
				logger.error('restartIce() | failed: %o', error);
			});
		}
	}, {
		key: 'enableStats',
		value: function enableStats() {
			var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATS_INTERVAL;

			logger.debug('enableStats() [interval:%s]', interval);

			if (typeof interval !== 'number' || interval < 1000) interval = DEFAULT_STATS_INTERVAL;

			this._statsEnabled = true;

			var data = {
				id: this._id,
				interval: interval
			};

			this.safeEmit('@notify', 'enableTransportStats', data);
		}
	}, {
		key: 'disableStats',
		value: function disableStats() {
			logger.debug('disableStats()');

			this._statsEnabled = false;

			var data = {
				id: this._id
			};

			this.safeEmit('@notify', 'disableTransportStats', data);
		}
	}, {
		key: '_handleHandler',
		value: function _handleHandler() {
			var _this3 = this;

			var handler = this._handler;

			handler.on('@connectionstatechange', function (state) {
				if (_this3._connectionState === state) return;

				logger.debug('Transport connection state changed to %s', state);

				_this3._connectionState = state;

				if (!_this3._closed) _this3.safeEmit('connectionstatechange', state);
			});

			handler.on('@needcreatetransport', function (transportLocalParameters, callback, errback) {
				var data = {
					id: _this3._id,
					direction: _this3._direction,
					options: _this3._settings.transportOptions,
					appData: _this3._appData
				};

				if (transportLocalParameters) data.dtlsParameters = transportLocalParameters.dtlsParameters;

				_this3.safeEmit('@request', 'createTransport', data, callback, errback);
			});

			handler.on('@needupdatetransport', function (transportLocalParameters) {
				var data = {
					id: _this3._id,
					dtlsParameters: transportLocalParameters.dtlsParameters
				};

				_this3.safeEmit('@notify', 'updateTransport', data);
			});

			handler.on('@needupdateproducer', function (producer, rtpParameters) {
				var data = {
					id: producer.id,
					rtpParameters: rtpParameters
				};

				// Update Producer RTP parameters.
				producer.setRtpParameters(rtpParameters);

				// Notify the server.
				_this3.safeEmit('@notify', 'updateProducer', data);
			});
		}

		/**
   * Send the given Producer over this Transport.
   *
   * @private
   *
   * @param {Producer} producer
   *
   * @return {Promise}
   */

	}, {
		key: 'addProducer',
		value: function addProducer(producer) {
			logger.debug('addProducer() [producer:%o]', producer);

			if (this._closed) return Promise.reject(new _errors.InvalidStateError('Transport closed'));
			if (this._direction !== 'send') return Promise.reject(new Error('not a sending Transport'));

			// Enqueue command.
			return this._commandQueue.push('addProducer', { producer: producer });
		}

		/**
   * @private
   */

	}, {
		key: 'removeProducer',
		value: function removeProducer(producer, originator, appData) {
			logger.debug('removeProducer() [producer:%o]', producer);

			// Enqueue command.
			if (!this._closed) {
				this._commandQueue.push('removeProducer', { producer: producer }).catch(function () {});
			}

			if (originator === 'local') this.safeEmit('@notify', 'closeProducer', { id: producer.id, appData: appData });
		}

		/**
   * @private
   */

	}, {
		key: 'pauseProducer',
		value: function pauseProducer(producer, appData) {
			logger.debug('pauseProducer() [producer:%o]', producer);

			var data = {
				id: producer.id,
				appData: appData
			};

			this.safeEmit('@notify', 'pauseProducer', data);
		}

		/**
   * @private
   */

	}, {
		key: 'resumeProducer',
		value: function resumeProducer(producer, appData) {
			logger.debug('resumeProducer() [producer:%o]', producer);

			var data = {
				id: producer.id,
				appData: appData
			};

			this.safeEmit('@notify', 'resumeProducer', data);
		}

		/**
   * @private
   *
   * @return {Promise}
   */

	}, {
		key: 'replaceProducerTrack',
		value: function replaceProducerTrack(producer, track) {
			logger.debug('replaceProducerTrack() [producer:%o]', producer);

			return this._commandQueue.push('replaceProducerTrack', { producer: producer, track: track });
		}

		/**
   * @private
   */

	}, {
		key: 'enableProducerStats',
		value: function enableProducerStats(producer, interval) {
			logger.debug('enableProducerStats() [producer:%o]', producer);

			var data = {
				id: producer.id,
				interval: interval
			};

			this.safeEmit('@notify', 'enableProducerStats', data);
		}

		/**
   * @private
   */

	}, {
		key: 'disableProducerStats',
		value: function disableProducerStats(producer) {
			logger.debug('disableProducerStats() [producer:%o]', producer);

			var data = {
				id: producer.id
			};

			this.safeEmit('@notify', 'disableProducerStats', data);
		}

		/**
   * Receive the given Consumer over this Transport.
   *
   * @private
   *
   * @param {Consumer} consumer
   *
   * @return {Promise} Resolves to a remote MediaStreamTrack.
   */

	}, {
		key: 'addConsumer',
		value: function addConsumer(consumer) {
			logger.debug('addConsumer() [consumer:%o]', consumer);

			if (this._closed) return Promise.reject(new _errors.InvalidStateError('Transport closed'));
			if (this._direction !== 'recv') return Promise.reject(new Error('not a receiving Transport'));

			// Enqueue command.
			return this._commandQueue.push('addConsumer', { consumer: consumer });
		}

		/**
   * @private
   */

	}, {
		key: 'removeConsumer',
		value: function removeConsumer(consumer) {
			logger.debug('removeConsumer() [consumer:%o]', consumer);

			// Enqueue command.
			this._commandQueue.push('removeConsumer', { consumer: consumer }).catch(function () {});
		}

		/**
   * @private
   */

	}, {
		key: 'pauseConsumer',
		value: function pauseConsumer(consumer, appData) {
			logger.debug('pauseConsumer() [consumer:%o]', consumer);

			var data = {
				id: consumer.id,
				appData: appData
			};

			this.safeEmit('@notify', 'pauseConsumer', data);
		}

		/**
   * @private
   */

	}, {
		key: 'resumeConsumer',
		value: function resumeConsumer(consumer, appData) {
			logger.debug('resumeConsumer() [consumer:%o]', consumer);

			var data = {
				id: consumer.id,
				appData: appData
			};

			this.safeEmit('@notify', 'resumeConsumer', data);
		}

		/**
   * @private
   */

	}, {
		key: 'setConsumerPreferredProfile',
		value: function setConsumerPreferredProfile(consumer, profile) {
			logger.debug('setConsumerPreferredProfile() [consumer:%o]', consumer);

			var data = {
				id: consumer.id,
				profile: profile
			};

			this.safeEmit('@notify', 'setConsumerPreferredProfile', data);
		}

		/**
   * @private
   */

	}, {
		key: 'enableConsumerStats',
		value: function enableConsumerStats(consumer, interval) {
			logger.debug('enableConsumerStats() [consumer:%o]', consumer);

			var data = {
				id: consumer.id,
				interval: interval
			};

			this.safeEmit('@notify', 'enableConsumerStats', data);
		}

		/**
   * @private
   */

	}, {
		key: 'disableConsumerStats',
		value: function disableConsumerStats(consumer) {
			logger.debug('disableConsumerStats() [consumer:%o]', consumer);

			var data = {
				id: consumer.id
			};

			this.safeEmit('@notify', 'disableConsumerStats', data);
		}

		/**
   * Receive remote stats.
   *
   * @private
   *
   * @param {Object} stats
   */

	}, {
		key: 'remoteStats',
		value: function remoteStats(stats) {
			this.safeEmit('stats', stats);
		}
	}, {
		key: '_execCommand',
		value: function _execCommand(command, promiseHolder) {
			var promise = void 0;

			try {
				switch (command.method) {
					case 'addProducer':
						{
							var producer = command.producer;


							promise = this._execAddProducer(producer);
							break;
						}

					case 'removeProducer':
						{
							var _producer = command.producer;


							promise = this._execRemoveProducer(_producer);
							break;
						}

					case 'replaceProducerTrack':
						{
							var _producer2 = command.producer,
							    track = command.track;


							promise = this._execReplaceProducerTrack(_producer2, track);
							break;
						}

					case 'addConsumer':
						{
							var consumer = command.consumer;


							promise = this._execAddConsumer(consumer);
							break;
						}

					case 'removeConsumer':
						{
							var _consumer = command.consumer;


							promise = this._execRemoveConsumer(_consumer);
							break;
						}

					case 'restartIce':
						{
							var remoteIceParameters = command.remoteIceParameters;


							promise = this._execRestartIce(remoteIceParameters);
							break;
						}

					default:
						{
							promise = Promise.reject(new Error('unknown command method "' + command.method + '"'));
						}
				}
			} catch (error) {
				promise = Promise.reject(error);
			}

			// Fill the given Promise holder.
			promiseHolder.promise = promise;
		}
	}, {
		key: '_execAddProducer',
		value: function _execAddProducer(producer) {
			var _this4 = this;

			logger.debug('_execAddProducer()');

			var producerRtpParameters = void 0;

			// Call the handler.
			return Promise.resolve().then(function () {
				return _this4._handler.addProducer(producer);
			}).then(function (rtpParameters) {
				producerRtpParameters = rtpParameters;

				var data = {
					id: producer.id,
					kind: producer.kind,
					transportId: _this4._id,
					rtpParameters: rtpParameters,
					paused: producer.locallyPaused,
					appData: producer.appData
				};

				return _this4.safeEmitAsPromise('@request', 'createProducer', data);
			}).then(function () {
				producer.setRtpParameters(producerRtpParameters);
			});
		}
	}, {
		key: '_execRemoveProducer',
		value: function _execRemoveProducer(producer) {
			logger.debug('_execRemoveProducer()');

			// Call the handler.
			return this._handler.removeProducer(producer);
		}
	}, {
		key: '_execReplaceProducerTrack',
		value: function _execReplaceProducerTrack(producer, track) {
			logger.debug('_execReplaceProducerTrack()');

			// Call the handler.
			return this._handler.replaceProducerTrack(producer, track);
		}
	}, {
		key: '_execAddConsumer',
		value: function _execAddConsumer(consumer) {
			var _this5 = this;

			logger.debug('_execAddConsumer()');

			var consumerTrack = void 0;

			// Call the handler.
			return Promise.resolve().then(function () {
				return _this5._handler.addConsumer(consumer);
			}).then(function (track) {
				consumerTrack = track;

				var data = {
					id: consumer.id,
					transportId: _this5.id,
					paused: consumer.locallyPaused,
					preferredProfile: consumer.preferredProfile
				};

				return _this5.safeEmitAsPromise('@request', 'enableConsumer', data);
			}).then(function (response) {
				var paused = response.paused,
				    preferredProfile = response.preferredProfile,
				    effectiveProfile = response.effectiveProfile;


				if (paused) consumer.remotePause();

				if (preferredProfile) consumer.remoteSetPreferredProfile(preferredProfile);

				if (effectiveProfile) consumer.remoteEffectiveProfileChanged(effectiveProfile);

				return consumerTrack;
			});
		}
	}, {
		key: '_execRemoveConsumer',
		value: function _execRemoveConsumer(consumer) {
			logger.debug('_execRemoveConsumer()');

			// Call the handler.
			return this._handler.removeConsumer(consumer);
		}
	}, {
		key: '_execRestartIce',
		value: function _execRestartIce(remoteIceParameters) {
			logger.debug('_execRestartIce()');

			// Call the handler.
			return this._handler.restartIce(remoteIceParameters);
		}
	}, {
		key: 'id',
		get: function get() {
			return this._id;
		}

		/**
   * Whether the Transport is closed.
   *
   * @return {Boolean}
   */

	}, {
		key: 'closed',
		get: function get() {
			return this._closed;
		}

		/**
   * Transport direction.
   *
   * @return {String}
   */

	}, {
		key: 'direction',
		get: function get() {
			return this._direction;
		}

		/**
   * App custom data.
   *
   * @return {Any}
   */

	}, {
		key: 'appData',
		get: function get() {
			return this._appData;
		}

		/**
   * Connection state.
   *
   * @return {String}
   */

	}, {
		key: 'connectionState',
		get: function get() {
			return this._connectionState;
		}
	}]);

	return Transport;
}(_EnhancedEventEmitter3.default);

exports.default = Transport;
},{"./CommandQueue":29,"./Device":31,"./EnhancedEventEmitter":32,"./Logger":33,"./errors":38,"./utils":51}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Error produced when calling a method in an invalid state.
 */
var InvalidStateError = exports.InvalidStateError = function (_Error) {
	_inherits(InvalidStateError, _Error);

	function InvalidStateError(message) {
		_classCallCheck(this, InvalidStateError);

		var _this = _possibleConstructorReturn(this, (InvalidStateError.__proto__ || Object.getPrototypeOf(InvalidStateError)).call(this, message));

		Object.defineProperty(_this, 'name', {
			enumerable: false,
			writable: false,
			value: 'InvalidStateError'
		});

		if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
			{
				Error.captureStackTrace(_this, InvalidStateError);
			} else {
			Object.defineProperty(_this, 'stack', {
				enumerable: false,
				writable: false,
				value: new Error(message).stack
			});
		}
		return _this;
	}

	return InvalidStateError;
}(Error);

/**
 * Error produced when a Promise is rejected due to a timeout.
 */


var TimeoutError = exports.TimeoutError = function (_Error2) {
	_inherits(TimeoutError, _Error2);

	function TimeoutError(message) {
		_classCallCheck(this, TimeoutError);

		var _this2 = _possibleConstructorReturn(this, (TimeoutError.__proto__ || Object.getPrototypeOf(TimeoutError)).call(this, message));

		Object.defineProperty(_this2, 'name', {
			enumerable: false,
			writable: false,
			value: 'TimeoutError'
		});

		if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
			{
				Error.captureStackTrace(_this2, TimeoutError);
			} else {
			Object.defineProperty(_this2, 'stack', {
				enumerable: false,
				writable: false,
				value: new Error(message).stack
			});
		}
		return _this2;
	}

	return TimeoutError;
}(Error);

/**
 * Error indicating not support for something.
 */


var UnsupportedError = exports.UnsupportedError = function (_Error3) {
	_inherits(UnsupportedError, _Error3);

	function UnsupportedError(message, data) {
		_classCallCheck(this, UnsupportedError);

		var _this3 = _possibleConstructorReturn(this, (UnsupportedError.__proto__ || Object.getPrototypeOf(UnsupportedError)).call(this, message));

		Object.defineProperty(_this3, 'name', {
			enumerable: false,
			writable: false,
			value: 'UnsupportedError'
		});

		Object.defineProperty(_this3, 'data', {
			enumerable: true,
			writable: false,
			value: data
		});

		if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
			{
				Error.captureStackTrace(_this3, UnsupportedError);
			} else {
			Object.defineProperty(_this3, 'stack', {
				enumerable: false,
				writable: false,
				value: new Error(message).stack
			});
		}
		return _this3;
	}

	return UnsupportedError;
}(Error);
},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _Logger = require('../Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _ortc = require('../ortc');

var ortc = _interopRequireWildcard(_ortc);

var _commonUtils = require('./sdp/commonUtils');

var sdpCommonUtils = _interopRequireWildcard(_commonUtils);

var _planBUtils = require('./sdp/planBUtils');

var sdpPlanBUtils = _interopRequireWildcard(_planBUtils);

var _RemotePlanBSdp = require('./sdp/RemotePlanBSdp');

var _RemotePlanBSdp2 = _interopRequireDefault(_RemotePlanBSdp);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var logger = new _Logger2.default('Chrome55');

var Handler = function (_EnhancedEventEmitter) {
	_inherits(Handler, _EnhancedEventEmitter);

	function Handler(direction, rtpParametersByKind, settings) {
		_classCallCheck(this, Handler);

		// RTCPeerConnection instance.
		// @type {RTCPeerConnection}
		var _this = _possibleConstructorReturn(this, (Handler.__proto__ || Object.getPrototypeOf(Handler)).call(this, logger));

		_this._pc = new RTCPeerConnection({
			iceServers: settings.turnServers || [],
			iceTransportPolicy: 'all',
			bundlePolicy: 'max-bundle',
			rtcpMuxPolicy: 'require'
		});

		// Generic sending RTP parameters for audio and video.
		// @type {Object}
		_this._rtpParametersByKind = rtpParametersByKind;

		// Remote SDP handler.
		// @type {RemotePlanBSdp}
		_this._remoteSdp = new _RemotePlanBSdp2.default(direction, rtpParametersByKind);

		// Handle RTCPeerConnection connection status.
		_this._pc.addEventListener('iceconnectionstatechange', function () {
			switch (_this._pc.iceConnectionState) {
				case 'checking':
					_this.emit('@connectionstatechange', 'connecting');
					break;
				case 'connected':
				case 'completed':
					_this.emit('@connectionstatechange', 'connected');
					break;
				case 'failed':
					_this.emit('@connectionstatechange', 'failed');
					break;
				case 'disconnected':
					_this.emit('@connectionstatechange', 'disconnected');
					break;
				case 'closed':
					_this.emit('@connectionstatechange', 'closed');
					break;
			}
		});
		return _this;
	}

	_createClass(Handler, [{
		key: 'close',
		value: function close() {
			logger.debug('close()');

			// Close RTCPeerConnection.
			try {
				this._pc.close();
			} catch (error) {}
		}
	}]);

	return Handler;
}(_EnhancedEventEmitter3.default);

var SendHandler = function (_Handler) {
	_inherits(SendHandler, _Handler);

	function SendHandler(rtpParametersByKind, settings) {
		_classCallCheck(this, SendHandler);

		// Got transport local and remote parameters.
		// @type {Boolean}
		var _this2 = _possibleConstructorReturn(this, (SendHandler.__proto__ || Object.getPrototypeOf(SendHandler)).call(this, 'send', rtpParametersByKind, settings));

		_this2._transportReady = false;

		// Local stream.
		// @type {MediaStream}
		_this2._stream = new MediaStream();
		return _this2;
	}

	_createClass(SendHandler, [{
		key: 'addProducer',
		value: function addProducer(producer) {
			var _this3 = this;

			var track = producer.track;


			logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			if (this._stream.getTrackById(track.id)) return Promise.reject('track already added');

			var localSdpObj = void 0;

			return Promise.resolve().then(function () {
				// Add the track to the local stream.
				_this3._stream.addTrack(track);

				// Add the stream to the PeerConnection.
				_this3._pc.addStream(_this3._stream);

				return _this3._pc.createOffer();
			}).then(function (offer) {
				// If simulcast is set, mangle the offer.
				if (producer.simulcast) {
					logger.debug('addProducer() | enabling simulcast');

					var sdpObject = _sdpTransform2.default.parse(offer.sdp);

					sdpPlanBUtils.addSimulcastForTrack(sdpObject, track);

					var offerSdp = _sdpTransform2.default.write(sdpObject);

					offer = { type: 'offer', sdp: offerSdp };
				}

				logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this3._pc.setLocalDescription(offer);
			}).then(function () {
				if (!_this3._transportReady) return _this3._setupTransport();
			}).then(function () {
				localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);

				var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this3._pc.setRemoteDescription(answer);
			}).then(function () {
				var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);

				// Fill the RTP parameters for this track.
				sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);

				return rtpParameters;
			}).catch(function (error) {
				// Panic here. Try to undo things.

				_this3._stream.removeTrack(track);
				_this3._pc.addStream(_this3._stream);

				throw error;
			});
		}
	}, {
		key: 'removeProducer',
		value: function removeProducer(producer) {
			var _this4 = this;

			var track = producer.track;


			logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			return Promise.resolve().then(function () {
				// Remove the track from the local stream.
				_this4._stream.removeTrack(track);

				// Add the stream to the PeerConnection.
				_this4._pc.addStream(_this4._stream);

				return _this4._pc.createOffer();
			}).then(function (offer) {
				logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this4._pc.setLocalDescription(offer);
			}).catch(function (error) {
				// NOTE: If there are no sending tracks, setLocalDescription() will fail with
				// "Failed to create channels". If so, ignore it.
				if (_this4._stream.getTracks().length === 0) {
					logger.warn('removeProducer() | ignoring expected error due no sending tracks: %s', error.toString());

					return;
				}

				throw error;
			}).then(function () {
				if (_this4._pc.signalingState === 'stable') return;

				var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
				var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this4._pc.setRemoteDescription(answer);
			});
		}
	}, {
		key: 'replaceProducerTrack',
		value: function replaceProducerTrack(producer, track) {
			var _this5 = this;

			logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			var oldTrack = producer.track;
			var localSdpObj = void 0;

			return Promise.resolve().then(function () {
				// Remove the old track from the local stream.
				_this5._stream.removeTrack(oldTrack);

				// Add the new track to the local stream.
				_this5._stream.addTrack(track);

				// Add the stream to the PeerConnection.
				_this5._pc.addStream(_this5._stream);

				return _this5._pc.createOffer();
			}).then(function (offer) {
				// If simulcast is set, mangle the offer.
				if (producer.simulcast) {
					logger.debug('addProducer() | enabling simulcast');

					var sdpObject = _sdpTransform2.default.parse(offer.sdp);

					sdpPlanBUtils.addSimulcastForTrack(sdpObject, track);

					var offerSdp = _sdpTransform2.default.write(sdpObject);

					offer = { type: 'offer', sdp: offerSdp };
				}

				logger.debug('replaceProducerTrack() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this5._pc.setLocalDescription(offer);
			}).then(function () {
				localSdpObj = _sdpTransform2.default.parse(_this5._pc.localDescription.sdp);

				var remoteSdp = _this5._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('replaceProducerTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this5._pc.setRemoteDescription(answer);
			}).then(function () {
				var rtpParameters = utils.clone(_this5._rtpParametersByKind[producer.kind]);

				// Fill the RTP parameters for the new track.
				sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);

				// We need to provide new RTP parameters.
				_this5.safeEmit('@needupdateproducer', producer, rtpParameters);
			}).catch(function (error) {
				// Panic here. Try to undo things.

				_this5._stream.removeTrack(track);
				_this5._stream.addTrack(oldTrack);
				_this5._pc.addStream(_this5._stream);

				throw error;
			});
		}
	}, {
		key: 'restartIce',
		value: function restartIce(remoteIceParameters) {
			var _this6 = this;

			logger.debug('restartIce()');

			// Provide the remote SDP handler with new remote ICE parameters.
			this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);

			return Promise.resolve().then(function () {
				return _this6._pc.createOffer({ iceRestart: true });
			}).then(function (offer) {
				logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this6._pc.setLocalDescription(offer);
			}).then(function () {
				var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
				var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this6._pc.setRemoteDescription(answer);
			});
		}
	}, {
		key: '_setupTransport',
		value: function _setupTransport() {
			var _this7 = this;

			logger.debug('_setupTransport()');

			return Promise.resolve().then(function () {
				// Get our local DTLS parameters.
				var transportLocalParameters = {};
				var sdp = _this7._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);

				// Let's decide that we'll be DTLS server (because we can).
				dtlsParameters.role = 'server';

				transportLocalParameters.dtlsParameters = dtlsParameters;

				// Provide the remote SDP handler with transport local parameters.
				_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);

				// We need transport remote parameters.
				return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
			}).then(function (transportRemoteParameters) {
				// Provide the remote SDP handler with transport remote parameters.
				_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);

				_this7._transportReady = true;
			});
		}
	}]);

	return SendHandler;
}(Handler);

var RecvHandler = function (_Handler2) {
	_inherits(RecvHandler, _Handler2);

	function RecvHandler(rtpParametersByKind, settings) {
		_classCallCheck(this, RecvHandler);

		// Got transport remote parameters.
		// @type {Boolean}
		var _this8 = _possibleConstructorReturn(this, (RecvHandler.__proto__ || Object.getPrototypeOf(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));

		_this8._transportCreated = false;

		// Got transport local parameters.
		// @type {Boolean}
		_this8._transportUpdated = false;

		// Seen media kinds.
		// @type {Set<String>}
		_this8._kinds = new Set();

		// Map of Consumers information indexed by consumer.id.
		// - kind {String}
		// - trackId {String}
		// - ssrc {Number}
		// - rtxSsrc {Number}
		// - cname {String}
		// @type {Map<Number, Object>}
		_this8._consumerInfos = new Map();
		return _this8;
	}

	_createClass(RecvHandler, [{
		key: 'addConsumer',
		value: function addConsumer(consumer) {
			var _this9 = this;

			logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);

			if (this._consumerInfos.has(consumer.id)) return Promise.reject('Consumer already added');

			var encoding = consumer.rtpParameters.encodings[0];
			var cname = consumer.rtpParameters.rtcp.cname;
			var consumerInfo = {
				kind: consumer.kind,
				trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
				ssrc: encoding.ssrc,
				cname: cname
			};

			if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;

			this._consumerInfos.set(consumer.id, consumerInfo);
			this._kinds.add(consumer.kind);

			return Promise.resolve().then(function () {
				if (!_this9._transportCreated) return _this9._setupTransport();
			}).then(function () {
				var remoteSdp = _this9._remoteSdp.createOfferSdp(Array.from(_this9._kinds), Array.from(_this9._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this9._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this9._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this9._pc.setLocalDescription(answer);
			}).then(function () {
				if (!_this9._transportUpdated) return _this9._updateTransport();
			}).then(function () {
				var stream = _this9._pc.getRemoteStreams()[0];
				var track = stream.getTrackById(consumerInfo.trackId);

				if (!track) throw new Error('remote track not found');

				return track;
			});
		}
	}, {
		key: 'removeConsumer',
		value: function removeConsumer(consumer) {
			var _this10 = this;

			logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);

			if (!this._consumerInfos.has(consumer.id)) return Promise.reject('Consumer not found');

			this._consumerInfos.delete(consumer.id);

			return Promise.resolve().then(function () {
				var remoteSdp = _this10._remoteSdp.createOfferSdp(Array.from(_this10._kinds), Array.from(_this10._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this10._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this10._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this10._pc.setLocalDescription(answer);
			});
		}
	}, {
		key: 'restartIce',
		value: function restartIce(remoteIceParameters) {
			var _this11 = this;

			logger.debug('restartIce()');

			// Provide the remote SDP handler with new remote ICE parameters.
			this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);

			return Promise.resolve().then(function () {
				var remoteSdp = _this11._remoteSdp.createOfferSdp(Array.from(_this11._kinds), Array.from(_this11._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this11._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this11._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this11._pc.setLocalDescription(answer);
			});
		}
	}, {
		key: '_setupTransport',
		value: function _setupTransport() {
			var _this12 = this;

			logger.debug('_setupTransport()');

			return Promise.resolve().then(function () {
				// We need transport remote parameters.
				return _this12.safeEmitAsPromise('@needcreatetransport', null);
			}).then(function (transportRemoteParameters) {
				// Provide the remote SDP handler with transport remote parameters.
				_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);

				_this12._transportCreated = true;
			});
		}
	}, {
		key: '_updateTransport',
		value: function _updateTransport() {
			logger.debug('_updateTransport()');

			// Get our local DTLS parameters.
			// const transportLocalParameters = {};
			var sdp = this._pc.localDescription.sdp;
			var sdpObj = _sdpTransform2.default.parse(sdp);
			var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
			var transportLocalParameters = { dtlsParameters: dtlsParameters };

			// We need to provide transport local parameters.
			this.safeEmit('@needupdatetransport', transportLocalParameters);

			this._transportUpdated = true;
		}
	}]);

	return RecvHandler;
}(Handler);

var Chrome55 = function () {
	_createClass(Chrome55, null, [{
		key: 'getNativeRtpCapabilities',
		value: function getNativeRtpCapabilities() {
			logger.debug('getNativeRtpCapabilities()');

			var pc = new RTCPeerConnection({
				iceServers: [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});

			return pc.createOffer({
				offerToReceiveAudio: true,
				offerToReceiveVideo: true
			}).then(function (offer) {
				try {
					pc.close();
				} catch (error) {}

				var sdpObj = _sdpTransform2.default.parse(offer.sdp);
				var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);

				return nativeRtpCapabilities;
			}).catch(function (error) {
				try {
					pc.close();
				} catch (error2) {}

				throw error;
			});
		}
	}, {
		key: 'name',
		get: function get() {
			return 'Chrome55';
		}
	}]);

	function Chrome55(direction, extendedRtpCapabilities, settings) {
		_classCallCheck(this, Chrome55);

		logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);

		var rtpParametersByKind = void 0;

		switch (direction) {
			case 'send':
				{
					rtpParametersByKind = {
						audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
						video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
					};

					return new SendHandler(rtpParametersByKind, settings);
				}
			case 'recv':
				{
					rtpParametersByKind = {
						audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
						video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
					};

					return new RecvHandler(rtpParametersByKind, settings);
				}
		}
	}

	return Chrome55;
}();

exports.default = Chrome55;
},{"../EnhancedEventEmitter":32,"../Logger":33,"../ortc":50,"../utils":51,"./sdp/RemotePlanBSdp":44,"./sdp/commonUtils":46,"./sdp/planBUtils":47,"sdp-transform":59}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Logger = require('../Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _ortc = require('../ortc');

var ortc = _interopRequireWildcard(_ortc);

var _edgeUtils = require('./ortc/edgeUtils');

var edgeUtils = _interopRequireWildcard(_edgeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global RTCIceGatherer, RTCIceTransport, RTCDtlsTransport, RTCRtpReceiver, RTCRtpSender */

var CNAME = 'CNAME-EDGE-' + utils.randomNumber();

var logger = new _Logger2.default('Edge11');

var Edge11 = function (_EnhancedEventEmitter) {
	_inherits(Edge11, _EnhancedEventEmitter);

	_createClass(Edge11, null, [{
		key: 'getNativeRtpCapabilities',
		value: function getNativeRtpCapabilities() {
			logger.debug('getNativeRtpCapabilities()');

			return edgeUtils.getCapabilities();
		}
	}, {
		key: 'name',
		get: function get() {
			return 'Edge11';
		}
	}]);

	function Edge11(direction, extendedRtpCapabilities, settings) {
		_classCallCheck(this, Edge11);

		var _this = _possibleConstructorReturn(this, (Edge11.__proto__ || Object.getPrototypeOf(Edge11)).call(this, logger));

		logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);

		// Generic sending RTP parameters for audio and video.
		// @type {Object}
		_this._rtpParametersByKind = {
			audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
			video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
		};

		// Got transport local and remote parameters.
		// @type {Boolean}
		_this._transportReady = false;

		// ICE gatherer.
		_this._iceGatherer = null;

		// ICE transport.
		_this._iceTransport = null;

		// DTLS transport.
		// @type {RTCDtlsTransport}
		_this._dtlsTransport = null;

		// Map of RTCRtpSenders indexed by Producer.id.
		// @type {Map<Number, RTCRtpSender}
		_this._rtpSenders = new Map();

		// Map of RTCRtpReceivers indexed by Consumer.id.
		// @type {Map<Number, RTCRtpReceiver}
		_this._rtpReceivers = new Map();

		// Remote Transport parameters.
		// @type {Object}
		_this._transportRemoteParameters = null;

		_this._setIceGatherer(settings);
		_this._setIceTransport();
		_this._setDtlsTransport();
		return _this;
	}

	_createClass(Edge11, [{
		key: 'close',
		value: function close() {
			logger.debug('close()');

			// Close the ICE gatherer.
			// NOTE: Not yet implemented by Edge.
			try {
				this._iceGatherer.close();
			} catch (error) {}

			// Close the ICE transport.
			try {
				this._iceTransport.stop();
			} catch (error) {}

			// Close the DTLS transport.
			try {
				this._dtlsTransport.stop();
			} catch (error) {}

			// Close RTCRtpSenders.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this._rtpSenders.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var rtpSender = _step.value;

					try {
						rtpSender.stop();
					} catch (error) {}
				}

				// Close RTCRtpReceivers.
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._rtpReceivers.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var rtpReceiver = _step2.value;

					try {
						rtpReceiver.stop();
					} catch (error) {}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	}, {
		key: 'addProducer',
		value: function addProducer(producer) {
			var _this2 = this;

			var track = producer.track;


			logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			if (this._rtpSenders.has(producer.id)) return Promise.reject('Producer already added');

			return Promise.resolve().then(function () {
				if (!_this2._transportReady) return _this2._setupTransport();
			}).then(function () {
				logger.debug('addProducer() | calling new RTCRtpSender()');

				var rtpSender = new RTCRtpSender(track, _this2._dtlsTransport);
				var rtpParameters = utils.clone(_this2._rtpParametersByKind[producer.kind]);

				// Fill RTCRtpParameters.encodings.
				var encoding = {
					ssrc: utils.randomNumber()
				};

				if (rtpParameters.codecs.some(function (codec) {
					return codec.name === 'rtx';
				})) {
					encoding.rtx = {
						ssrc: utils.randomNumber()
					};
				}

				rtpParameters.encodings.push(encoding);

				// Fill RTCRtpParameters.rtcp.
				rtpParameters.rtcp = {
					cname: CNAME,
					reducedSize: true,
					mux: true
				};

				// NOTE: Convert our standard RTCRtpParameters into those that Edge
				// expects.
				var edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);

				logger.debug('addProducer() | calling rtpSender.send() [params:%o]', edgeRtpParameters);

				rtpSender.send(edgeRtpParameters);

				// Store it.
				_this2._rtpSenders.set(producer.id, rtpSender);

				return rtpParameters;
			});
		}
	}, {
		key: 'removeProducer',
		value: function removeProducer(producer) {
			var _this3 = this;

			var track = producer.track;


			logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			return Promise.resolve().then(function () {
				var rtpSender = _this3._rtpSenders.get(producer.id);

				if (!rtpSender) throw new Error('RTCRtpSender not found');

				_this3._rtpSenders.delete(producer.id);

				try {
					logger.debug('removeProducer() | calling rtpSender.stop()');

					rtpSender.stop();
				} catch (error) {
					logger.warn('rtpSender.stop() failed:%o', error);
				}
			});
		}
	}, {
		key: 'replaceProducerTrack',
		value: function replaceProducerTrack(producer, track) {
			var _this4 = this;

			logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			return Promise.resolve().then(function () {
				var rtpSender = _this4._rtpSenders.get(producer.id);

				if (!rtpSender) throw new Error('RTCRtpSender not found');

				rtpSender.setTrack(track);
			});
		}
	}, {
		key: 'addConsumer',
		value: function addConsumer(consumer) {
			var _this5 = this;

			logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);

			if (this._rtpReceivers.has(consumer.id)) return Promise.reject('Consumer already added');

			return Promise.resolve().then(function () {
				logger.debug('addProducer() | calling new RTCRtpReceiver()');

				var rtpReceiver = new RTCRtpReceiver(_this5._dtlsTransport, consumer.kind);

				rtpReceiver.addEventListener('error', function (event) {
					logger.error('iceGatherer "error" event [event:%o]', event);
				});

				// NOTE: Convert our standard RTCRtpParameters into those that Edge
				// expects.
				var edgeRtpParameters = edgeUtils.mangleRtpParameters(consumer.rtpParameters);

				logger.debug('addProducer() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);

				rtpReceiver.receive(edgeRtpParameters);

				// Store it.
				_this5._rtpReceivers.set(consumer.id, rtpReceiver);
			});
		}
	}, {
		key: 'removeConsumer',
		value: function removeConsumer(consumer) {
			var _this6 = this;

			logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);

			return Promise.resolve().then(function () {
				var rtpReceiver = _this6._rtpReceivers.get(consumer.id);

				if (!rtpReceiver) throw new Error('RTCRtpReceiver not found');

				_this6._rtpReceivers.delete(consumer.id);

				try {
					logger.debug('removeConsumer() | calling rtpReceiver.stop()');

					rtpReceiver.stop();
				} catch (error) {
					logger.warn('rtpReceiver.stop() failed:%o', error);
				}
			});
		}
	}, {
		key: 'restartIce',
		value: function restartIce(remoteIceParameters) {
			var _this7 = this;

			logger.debug('restartIce()');

			Promise.resolve().then(function () {
				_this7._transportRemoteParameters.iceParameters = remoteIceParameters;

				var remoteIceCandidates = _this7._transportRemoteParameters.iceCandidates;

				logger.debug('restartIce() | calling iceTransport.start()');

				_this7._iceTransport.start(_this7._iceGatherer, remoteIceParameters, 'controlling');

				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = remoteIceCandidates[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var candidate = _step3.value;

						_this7._iceTransport.addRemoteCandidate(candidate);
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				_this7._iceTransport.addRemoteCandidate({});
			});
		}
	}, {
		key: '_setIceGatherer',
		value: function _setIceGatherer(settings) {
			var iceGatherer = new RTCIceGatherer({
				iceServers: settings.turnServers || [],
				gatherPolicy: 'all'
			});

			iceGatherer.addEventListener('error', function (event) {
				logger.error('iceGatherer "error" event [event:%o]', event);
			});

			// NOTE: Not yet implemented by Edge, which starts gathering automatically.
			try {
				iceGatherer.gather();
			} catch (error) {
				logger.debug('iceGatherer.gather() failed: %s', error.toString());
			}

			this._iceGatherer = iceGatherer;
		}
	}, {
		key: '_setIceTransport',
		value: function _setIceTransport() {
			var _this8 = this;

			var iceTransport = new RTCIceTransport(this._iceGatherer);

			// NOTE: Not yet implemented by Edge.
			iceTransport.addEventListener('statechange', function () {
				switch (iceTransport.state) {
					case 'checking':
						_this8.emit('@connectionstatechange', 'connecting');
						break;
					case 'connected':
					case 'completed':
						_this8.emit('@connectionstatechange', 'connected');
						break;
					case 'failed':
						_this8.emit('@connectionstatechange', 'failed');
						break;
					case 'disconnected':
						_this8.emit('@connectionstatechange', 'disconnected');
						break;
					case 'closed':
						_this8.emit('@connectionstatechange', 'closed');
						break;
				}
			});

			// NOTE: Not standard, but implemented by Edge.
			iceTransport.addEventListener('icestatechange', function () {
				switch (iceTransport.state) {
					case 'checking':
						_this8.emit('@connectionstatechange', 'connecting');
						break;
					case 'connected':
					case 'completed':
						_this8.emit('@connectionstatechange', 'connected');
						break;
					case 'failed':
						_this8.emit('@connectionstatechange', 'failed');
						break;
					case 'disconnected':
						_this8.emit('@connectionstatechange', 'disconnected');
						break;
					case 'closed':
						_this8.emit('@connectionstatechange', 'closed');
						break;
				}
			});

			iceTransport.addEventListener('candidatepairchange', function (event) {
				logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
			});

			this._iceTransport = iceTransport;
		}
	}, {
		key: '_setDtlsTransport',
		value: function _setDtlsTransport() {
			var dtlsTransport = new RTCDtlsTransport(this._iceTransport);

			// NOTE: Not yet implemented by Edge.
			dtlsTransport.addEventListener('statechange', function () {
				logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
			});

			// NOTE: Not standard, but implemented by Edge.
			dtlsTransport.addEventListener('dtlsstatechange', function () {
				logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
			});

			dtlsTransport.addEventListener('error', function (event) {
				logger.error('dtlsTransport "error" event [event:%o]', event);
			});

			this._dtlsTransport = dtlsTransport;
		}
	}, {
		key: '_setupTransport',
		value: function _setupTransport() {
			var _this9 = this;

			logger.debug('_setupTransport()');

			return Promise.resolve().then(function () {
				// Get our local DTLS parameters.
				var transportLocalParameters = {};
				var dtlsParameters = _this9._dtlsTransport.getLocalParameters();

				// Let's decide that we'll be DTLS server (because we can).
				dtlsParameters.role = 'server';

				transportLocalParameters.dtlsParameters = dtlsParameters;

				// We need transport remote parameters.
				return _this9.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
			}).then(function (transportRemoteParameters) {
				_this9._transportRemoteParameters = transportRemoteParameters;

				var remoteIceParameters = transportRemoteParameters.iceParameters;
				var remoteIceCandidates = transportRemoteParameters.iceCandidates;
				var remoteDtlsParameters = transportRemoteParameters.dtlsParameters;

				// Start the RTCIceTransport.
				_this9._iceTransport.start(_this9._iceGatherer, remoteIceParameters, 'controlling');

				// Add remote ICE candidates.
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = remoteIceCandidates[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var candidate = _step4.value;

						_this9._iceTransport.addRemoteCandidate(candidate);
					}

					// Also signal a 'complete' candidate as per spec.
					// NOTE: It should be {complete: true} but Edge prefers {}.
					// NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
					// won't enter the 'completed' state.
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				_this9._iceTransport.addRemoteCandidate({});

				// NOTE: Edge does not like SHA less than 256.
				remoteDtlsParameters.fingerprints = remoteDtlsParameters.fingerprints.filter(function (fingerprint) {
					return fingerprint.algorithm === 'sha-256' || fingerprint.algorithm === 'sha-384' || fingerprint.algorithm === 'sha-512';
				});

				// Start the RTCDtlsTransport.
				_this9._dtlsTransport.start(remoteDtlsParameters);

				_this9._transportReady = true;
			});
		}
	}]);

	return Edge11;
}(_EnhancedEventEmitter3.default);

exports.default = Edge11;
},{"../EnhancedEventEmitter":32,"../Logger":33,"../ortc":50,"../utils":51,"./ortc/edgeUtils":43}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _Logger = require('../Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _ortc = require('../ortc');

var ortc = _interopRequireWildcard(_ortc);

var _commonUtils = require('./sdp/commonUtils');

var sdpCommonUtils = _interopRequireWildcard(_commonUtils);

var _unifiedPlanUtils = require('./sdp/unifiedPlanUtils');

var sdpUnifiedPlanUtils = _interopRequireWildcard(_unifiedPlanUtils);

var _RemoteUnifiedPlanSdp = require('./sdp/RemoteUnifiedPlanSdp');

var _RemoteUnifiedPlanSdp2 = _interopRequireDefault(_RemoteUnifiedPlanSdp);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var logger = new _Logger2.default('Firefox50');

var Handler = function (_EnhancedEventEmitter) {
	_inherits(Handler, _EnhancedEventEmitter);

	function Handler(direction, rtpParametersByKind, settings) {
		_classCallCheck(this, Handler);

		// RTCPeerConnection instance.
		// @type {RTCPeerConnection}
		var _this = _possibleConstructorReturn(this, (Handler.__proto__ || Object.getPrototypeOf(Handler)).call(this, logger));

		_this._pc = new RTCPeerConnection({
			iceServers: settings.turnServers || [],
			iceTransportPolicy: 'all',
			bundlePolicy: 'max-bundle',
			rtcpMuxPolicy: 'require'
		});

		// Generic sending RTP parameters for audio and video.
		// @type {Object}
		_this._rtpParametersByKind = rtpParametersByKind;

		// Remote SDP handler.
		// @type {RemoteUnifiedPlanSdp}
		_this._remoteSdp = new _RemoteUnifiedPlanSdp2.default(direction, rtpParametersByKind);

		// Handle RTCPeerConnection connection status.
		_this._pc.addEventListener('iceconnectionstatechange', function () {
			switch (_this._pc.iceConnectionState) {
				case 'checking':
					_this.emit('@connectionstatechange', 'connecting');
					break;
				case 'connected':
				case 'completed':
					_this.emit('@connectionstatechange', 'connected');
					break;
				case 'failed':
					_this.emit('@connectionstatechange', 'failed');
					break;
				case 'disconnected':
					_this.emit('@connectionstatechange', 'disconnected');
					break;
				case 'closed':
					_this.emit('@connectionstatechange', 'closed');
					break;
			}
		});
		return _this;
	}

	_createClass(Handler, [{
		key: 'close',
		value: function close() {
			logger.debug('close()');

			// Close RTCPeerConnection.
			try {
				this._pc.close();
			} catch (error) {}
		}
	}]);

	return Handler;
}(_EnhancedEventEmitter3.default);

var SendHandler = function (_Handler) {
	_inherits(SendHandler, _Handler);

	function SendHandler(rtpParametersByKind, settings) {
		_classCallCheck(this, SendHandler);

		// Got transport local and remote parameters.
		// @type {Boolean}
		var _this2 = _possibleConstructorReturn(this, (SendHandler.__proto__ || Object.getPrototypeOf(SendHandler)).call(this, 'send', rtpParametersByKind, settings));

		_this2._transportReady = false;

		// Local stream.
		// @type {MediaStream}
		_this2._stream = new MediaStream();

		// RID value counter for simulcast (so they never match).
		// @type {Number}
		_this2._nextRid = 1;
		return _this2;
	}

	_createClass(SendHandler, [{
		key: 'addProducer',
		value: function addProducer(producer) {
			var _this3 = this;

			var track = producer.track;


			logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			if (this._stream.getTrackById(track.id)) return Promise.reject('track already added');

			var rtpSender = void 0;
			var localSdpObj = void 0;

			return Promise.resolve().then(function () {
				_this3._stream.addTrack(track);

				// Add the stream to the PeerConnection.
				rtpSender = _this3._pc.addTrack(track, _this3._stream);
			}).then(function () {
				// If simulcast is not enabled, do nothing.
				if (!producer.simulcast) return;

				logger.debug('addProducer() | enabling simulcast');

				var encodings = [];

				if (producer.simulcast.high) {
					encodings.push({
						rid: 'high' + _this3._nextRid,
						active: true,
						priority: 'high',
						maxBitrate: producer.simulcast.high
					});
				}

				if (producer.simulcast.medium) {
					encodings.push({
						rid: 'medium' + _this3._nextRid,
						active: true,
						priority: 'medium',
						maxBitrate: producer.simulcast.medium
					});
				}

				if (producer.simulcast.low) {
					encodings.push({
						rid: 'low' + _this3._nextRid,
						active: true,
						priority: 'low',
						maxBitrate: producer.simulcast.low
					});
				}

				// Update RID counter for future ones.
				_this3._nextRid++;

				return rtpSender.setParameters({ encodings: encodings });
			}).then(function () {
				return _this3._pc.createOffer();
			}).then(function (offer) {
				logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this3._pc.setLocalDescription(offer);
			}).then(function () {
				if (!_this3._transportReady) return _this3._setupTransport();
			}).then(function () {
				localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);

				var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this3._pc.setRemoteDescription(answer);
			}).then(function () {
				var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);

				// Fill the RTP parameters for this track.
				sdpUnifiedPlanUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);

				return rtpParameters;
			}).catch(function (error) {
				// Panic here. Try to undo things.

				try {
					_this3._pc.removeTrack(rtpSender);
				} catch (error2) {}

				_this3._stream.removeTrack(track);

				throw error;
			});
		}
	}, {
		key: 'removeProducer',
		value: function removeProducer(producer) {
			var _this4 = this;

			var track = producer.track;


			logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			return Promise.resolve().then(function () {
				// Get the associated RTCRtpSender.
				var rtpSender = _this4._pc.getSenders().find(function (s) {
					return s.track === track;
				});

				if (!rtpSender) throw new Error('RTCRtpSender found');

				// Remove the associated RtpSender.
				_this4._pc.removeTrack(rtpSender);

				// Remove the track from the local stream.
				_this4._stream.removeTrack(track);

				// NOTE: If there are no sending tracks, setLocalDescription() will cause
				// Firefox to close DTLS. This is fixed for the receiving PeerConnection
				// (by adding a fake DataChannel) but not for the sending one.
				//
				// ISSUE: https://github.com/versatica/mediasoup-client/issues/2
				return Promise.resolve().then(function () {
					return _this4._pc.createOffer();
				}).then(function (offer) {
					logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);

					return _this4._pc.setLocalDescription(offer);
				});
			}).then(function () {
				var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
				var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this4._pc.setRemoteDescription(answer);
			});
		}
	}, {
		key: 'replaceProducerTrack',
		value: function replaceProducerTrack(producer, track) {
			var _this5 = this;

			logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			var oldTrack = producer.track;

			return Promise.resolve().then(function () {
				// Get the associated RTCRtpSender.
				var rtpSender = _this5._pc.getSenders().find(function (s) {
					return s.track === oldTrack;
				});

				if (!rtpSender) throw new Error('local track not found');

				return rtpSender.replaceTrack(track);
			}).then(function () {
				// Remove the old track from the local stream.
				_this5._stream.removeTrack(oldTrack);

				// Add the new track to the local stream.
				_this5._stream.addTrack(track);
			});
		}
	}, {
		key: 'restartIce',
		value: function restartIce(remoteIceParameters) {
			var _this6 = this;

			logger.debug('restartIce()');

			// Provide the remote SDP handler with new remote ICE parameters.
			this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);

			return Promise.resolve().then(function () {
				return _this6._pc.createOffer({ iceRestart: true });
			}).then(function (offer) {
				logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this6._pc.setLocalDescription(offer);
			}).then(function () {
				var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
				var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this6._pc.setRemoteDescription(answer);
			});
		}
	}, {
		key: '_setupTransport',
		value: function _setupTransport() {
			var _this7 = this;

			logger.debug('_setupTransport()');

			return Promise.resolve().then(function () {
				// Get our local DTLS parameters.
				var transportLocalParameters = {};
				var sdp = _this7._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);

				// Let's decide that we'll be DTLS server (because we can).
				dtlsParameters.role = 'server';

				transportLocalParameters.dtlsParameters = dtlsParameters;

				// Provide the remote SDP handler with transport local parameters.
				_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);

				// We need transport remote parameters.
				return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
			}).then(function (transportRemoteParameters) {
				// Provide the remote SDP handler with transport remote parameters.
				_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);

				_this7._transportReady = true;
			});
		}
	}]);

	return SendHandler;
}(Handler);

var RecvHandler = function (_Handler2) {
	_inherits(RecvHandler, _Handler2);

	function RecvHandler(rtpParametersByKind, settings) {
		_classCallCheck(this, RecvHandler);

		// Got transport remote parameters.
		// @type {Boolean}
		var _this8 = _possibleConstructorReturn(this, (RecvHandler.__proto__ || Object.getPrototypeOf(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));

		_this8._transportCreated = false;

		// Got transport local parameters.
		// @type {Boolean}
		_this8._transportUpdated = false;

		// Map of Consumers information indexed by consumer.id.
		// - mid {String}
		// - kind {String}
		// - closed {Boolean}
		// - trackId {String}
		// - ssrc {Number}
		// - rtxSsrc {Number}
		// - cname {String}
		// @type {Map<Number, Object>}
		_this8._consumerInfos = new Map();

		// Add an entry into consumers info to hold a fake DataChannel, so
		// the first m= section of the remote SDP is always "active" and Firefox
		// does not close the transport when there is no remote audio/video Consumers.
		//
		// ISSUE: https://github.com/versatica/mediasoup-client/issues/2
		var fakeDataChannelConsumerInfo = {
			mid: 'fake-datachannel-consumer',
			kind: 'application',
			closed: false,
			cname: null
		};

		_this8._consumerInfos.set(555, fakeDataChannelConsumerInfo);
		return _this8;
	}

	_createClass(RecvHandler, [{
		key: 'addConsumer',
		value: function addConsumer(consumer) {
			var _this9 = this;

			logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);

			if (this._consumerInfos.has(consumer.id)) return Promise.reject('Consumer already added');

			var encoding = consumer.rtpParameters.encodings[0];
			var cname = consumer.rtpParameters.rtcp.cname;
			var consumerInfo = {
				mid: 'consumer-' + consumer.kind + '-' + consumer.id,
				kind: consumer.kind,
				closed: consumer.closed,
				trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
				ssrc: encoding.ssrc,
				cname: cname
			};

			if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;

			this._consumerInfos.set(consumer.id, consumerInfo);

			return Promise.resolve().then(function () {
				if (!_this9._transportCreated) return _this9._setupTransport();
			}).then(function () {
				var remoteSdp = _this9._remoteSdp.createOfferSdp(Array.from(_this9._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this9._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this9._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this9._pc.setLocalDescription(answer);
			}).then(function () {
				if (!_this9._transportUpdated) return _this9._updateTransport();
			}).then(function () {
				var newRtpReceiver = _this9._pc.getReceivers().find(function (rtpReceiver) {
					var track = rtpReceiver.track;


					if (!track) return false;

					return track.id === consumerInfo.trackId;
				});

				if (!newRtpReceiver) throw new Error('remote track not found');

				return newRtpReceiver.track;
			});
		}
	}, {
		key: 'removeConsumer',
		value: function removeConsumer(consumer) {
			var _this10 = this;

			logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);

			var consumerInfo = this._consumerInfos.get(consumer.id);

			if (!consumerInfo) return Promise.reject('Consumer not found');

			consumerInfo.closed = true;

			return Promise.resolve().then(function () {
				var remoteSdp = _this10._remoteSdp.createOfferSdp(Array.from(_this10._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this10._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this10._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this10._pc.setLocalDescription(answer);
			});
		}
	}, {
		key: 'restartIce',
		value: function restartIce(remoteIceParameters) {
			var _this11 = this;

			logger.debug('restartIce()');

			// Provide the remote SDP handler with new remote ICE parameters.
			this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);

			return Promise.resolve().then(function () {
				var remoteSdp = _this11._remoteSdp.createOfferSdp(Array.from(_this11._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this11._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this11._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this11._pc.setLocalDescription(answer);
			});
		}
	}, {
		key: '_setupTransport',
		value: function _setupTransport() {
			var _this12 = this;

			logger.debug('_setupTransport()');

			return Promise.resolve().then(function () {
				// We need transport remote parameters.
				return _this12.safeEmitAsPromise('@needcreatetransport', null);
			}).then(function (transportRemoteParameters) {
				// Provide the remote SDP handler with transport remote parameters.
				_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);

				_this12._transportCreated = true;
			});
		}
	}, {
		key: '_updateTransport',
		value: function _updateTransport() {
			logger.debug('_updateTransport()');

			// Get our local DTLS parameters.
			// const transportLocalParameters = {};
			var sdp = this._pc.localDescription.sdp;
			var sdpObj = _sdpTransform2.default.parse(sdp);
			var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
			var transportLocalParameters = { dtlsParameters: dtlsParameters };

			// We need to provide transport local parameters.
			this.safeEmit('@needupdatetransport', transportLocalParameters);

			this._transportUpdated = true;
		}
	}]);

	return RecvHandler;
}(Handler);

var Firefox50 = function () {
	_createClass(Firefox50, null, [{
		key: 'getNativeRtpCapabilities',
		value: function getNativeRtpCapabilities() {
			logger.debug('getNativeRtpCapabilities()');

			var pc = new RTCPeerConnection({
				iceServers: [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});

			// NOTE: We need to add a real video track to get the RID extension mapping.
			var canvas = document.createElement('canvas');

			// NOTE: Otherwise Firefox fails in next line.
			canvas.getContext('2d');

			var fakeStream = canvas.captureStream();
			var fakeVideoTrack = fakeStream.getVideoTracks()[0];
			var rtpSender = pc.addTrack(fakeVideoTrack, fakeStream);

			rtpSender.setParameters({
				encodings: [{ rid: 'RID1', maxBitrate: 40000 }, { rid: 'RID2', maxBitrate: 10000 }]
			});

			return pc.createOffer({
				offerToReceiveAudio: true,
				offerToReceiveVideo: true
			}).then(function (offer) {
				try {
					canvas.remove();
				} catch (error) {}

				try {
					pc.close();
				} catch (error) {}

				var sdpObj = _sdpTransform2.default.parse(offer.sdp);
				var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);

				return nativeRtpCapabilities;
			}).catch(function (error) {
				try {
					canvas.remove();
				} catch (error2) {}

				try {
					pc.close();
				} catch (error2) {}

				throw error;
			});
		}
	}, {
		key: 'name',
		get: function get() {
			return 'Firefox50';
		}
	}]);

	function Firefox50(direction, extendedRtpCapabilities, settings) {
		_classCallCheck(this, Firefox50);

		logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);

		var rtpParametersByKind = void 0;

		switch (direction) {
			case 'send':
				{
					rtpParametersByKind = {
						audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
						video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
					};

					return new SendHandler(rtpParametersByKind, settings);
				}
			case 'recv':
				{
					rtpParametersByKind = {
						audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
						video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
					};

					return new RecvHandler(rtpParametersByKind, settings);
				}
		}
	}

	return Firefox50;
}();

exports.default = Firefox50;
},{"../EnhancedEventEmitter":32,"../Logger":33,"../ortc":50,"../utils":51,"./sdp/RemoteUnifiedPlanSdp":45,"./sdp/commonUtils":46,"./sdp/unifiedPlanUtils":48,"sdp-transform":59}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _Logger = require('../Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');

var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _ortc = require('../ortc');

var ortc = _interopRequireWildcard(_ortc);

var _commonUtils = require('./sdp/commonUtils');

var sdpCommonUtils = _interopRequireWildcard(_commonUtils);

var _planBUtils = require('./sdp/planBUtils');

var sdpPlanBUtils = _interopRequireWildcard(_planBUtils);

var _RemotePlanBSdp = require('./sdp/RemotePlanBSdp');

var _RemotePlanBSdp2 = _interopRequireDefault(_RemotePlanBSdp);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var logger = new _Logger2.default('Safari11');

var Handler = function (_EnhancedEventEmitter) {
	_inherits(Handler, _EnhancedEventEmitter);

	function Handler(direction, rtpParametersByKind, settings) {
		_classCallCheck(this, Handler);

		// RTCPeerConnection instance.
		// @type {RTCPeerConnection}
		var _this = _possibleConstructorReturn(this, (Handler.__proto__ || Object.getPrototypeOf(Handler)).call(this, logger));

		_this._pc = new RTCPeerConnection({
			iceServers: settings.turnServers || [],
			iceTransportPolicy: 'all',
			bundlePolicy: 'max-bundle',
			rtcpMuxPolicy: 'require'
		});

		// Generic sending RTP parameters for audio and video.
		// @type {Object}
		_this._rtpParametersByKind = rtpParametersByKind;

		// Remote SDP handler.
		// @type {RemotePlanBSdp}
		_this._remoteSdp = new _RemotePlanBSdp2.default(direction, rtpParametersByKind);

		// Handle RTCPeerConnection connection status.
		_this._pc.addEventListener('iceconnectionstatechange', function () {
			switch (_this._pc.iceConnectionState) {
				case 'checking':
					_this.emit('@connectionstatechange', 'connecting');
					break;
				case 'connected':
				case 'completed':
					_this.emit('@connectionstatechange', 'connected');
					break;
				case 'failed':
					_this.emit('@connectionstatechange', 'failed');
					break;
				case 'disconnected':
					_this.emit('@connectionstatechange', 'disconnected');
					break;
				case 'closed':
					_this.emit('@connectionstatechange', 'closed');
					break;
			}
		});
		return _this;
	}

	_createClass(Handler, [{
		key: 'close',
		value: function close() {
			logger.debug('close()');

			// Close RTCPeerConnection.
			try {
				this._pc.close();
			} catch (error) {}
		}
	}]);

	return Handler;
}(_EnhancedEventEmitter3.default);

var SendHandler = function (_Handler) {
	_inherits(SendHandler, _Handler);

	function SendHandler(rtpParametersByKind, settings) {
		_classCallCheck(this, SendHandler);

		// Got transport local and remote parameters.
		// @type {Boolean}
		var _this2 = _possibleConstructorReturn(this, (SendHandler.__proto__ || Object.getPrototypeOf(SendHandler)).call(this, 'send', rtpParametersByKind, settings));

		_this2._transportReady = false;

		// Local stream.
		// @type {MediaStream}
		_this2._stream = new MediaStream();
		return _this2;
	}

	_createClass(SendHandler, [{
		key: 'addProducer',
		value: function addProducer(producer) {
			var _this3 = this;

			var track = producer.track;


			logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			if (this._stream.getTrackById(track.id)) return Promise.reject('track already added');

			var rtpSender = void 0;
			var localSdpObj = void 0;

			return Promise.resolve().then(function () {
				_this3._stream.addTrack(track);

				// Add the stream to the PeerConnection.
				rtpSender = _this3._pc.addTrack(track, _this3._stream);

				return _this3._pc.createOffer();
			}).then(function (offer) {
				logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this3._pc.setLocalDescription(offer);
			}).then(function () {
				if (!_this3._transportReady) return _this3._setupTransport();
			}).then(function () {
				localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);

				var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this3._pc.setRemoteDescription(answer);
			}).then(function () {
				var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);

				// Fill the RTP parameters for this track.
				sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);

				return rtpParameters;
			}).catch(function (error) {
				// Panic here. Try to undo things.

				try {
					_this3._pc.removeTrack(rtpSender);
				} catch (error2) {}

				_this3._stream.removeTrack(track);

				throw error;
			});
		}
	}, {
		key: 'removeProducer',
		value: function removeProducer(producer) {
			var _this4 = this;

			var track = producer.track;


			logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			return Promise.resolve().then(function () {
				// Get the associated RTCRtpSender.
				var rtpSender = _this4._pc.getSenders().find(function (s) {
					return s.track === track;
				});

				if (!rtpSender) throw new Error('RTCRtpSender found');

				// Remove the associated RtpSender.
				_this4._pc.removeTrack(rtpSender);

				// Remove the track from the local stream.
				_this4._stream.removeTrack(track);

				return _this4._pc.createOffer();
			}).then(function (offer) {
				logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this4._pc.setLocalDescription(offer);
			}).catch(function (error) {
				// NOTE: If there are no sending tracks, setLocalDescription() will fail with
				// "Failed to create channels". If so, ignore it.
				if (_this4._stream.getTracks().length === 0) {
					logger.warn('removeLocalTrack() | ignoring expected error due no sending tracks: %s', error.toString());

					return;
				}

				throw error;
			}).then(function () {
				if (_this4._pc.signalingState === 'stable') return;

				var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
				var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this4._pc.setRemoteDescription(answer);
			});
		}
	}, {
		key: 'replaceProducerTrack',
		value: function replaceProducerTrack(producer, track) {
			var _this5 = this;

			logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);

			var oldTrack = producer.track;

			return Promise.resolve().then(function () {
				// Get the associated RTCRtpSender.
				var rtpSender = _this5._pc.getSenders().find(function (s) {
					return s.track === oldTrack;
				});

				if (!rtpSender) throw new Error('local track not found');

				return rtpSender.replaceTrack(track);
			}).then(function () {
				// Remove the old track from the local stream.
				_this5._stream.removeTrack(oldTrack);

				// Add the new track to the local stream.
				_this5._stream.addTrack(track);
			});
		}
	}, {
		key: 'restartIce',
		value: function restartIce(remoteIceParameters) {
			var _this6 = this;

			logger.debug('restartIce()');

			// Provide the remote SDP handler with new remote ICE parameters.
			this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);

			return Promise.resolve().then(function () {
				return _this6._pc.createOffer({ iceRestart: true });
			}).then(function (offer) {
				logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);

				return _this6._pc.setLocalDescription(offer);
			}).then(function () {
				var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
				var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
				var answer = { type: 'answer', sdp: remoteSdp };

				logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);

				return _this6._pc.setRemoteDescription(answer);
			});
		}
	}, {
		key: '_setupTransport',
		value: function _setupTransport() {
			var _this7 = this;

			logger.debug('_setupTransport()');

			return Promise.resolve().then(function () {
				// Get our local DTLS parameters.
				var transportLocalParameters = {};
				var sdp = _this7._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);

				// Let's decide that we'll be DTLS server (because we can).
				dtlsParameters.role = 'server';

				transportLocalParameters.dtlsParameters = dtlsParameters;

				// Provide the remote SDP handler with transport local parameters.
				_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);

				// We need transport remote parameters.
				return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
			}).then(function (transportRemoteParameters) {
				// Provide the remote SDP handler with transport remote parameters.
				_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);

				_this7._transportReady = true;
			});
		}
	}]);

	return SendHandler;
}(Handler);

var RecvHandler = function (_Handler2) {
	_inherits(RecvHandler, _Handler2);

	function RecvHandler(rtpParametersByKind, settings) {
		_classCallCheck(this, RecvHandler);

		// Got transport remote parameters.
		// @type {Boolean}
		var _this8 = _possibleConstructorReturn(this, (RecvHandler.__proto__ || Object.getPrototypeOf(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));

		_this8._transportCreated = false;

		// Got transport local parameters.
		// @type {Boolean}
		_this8._transportUpdated = false;

		// Seen media kinds.
		// @type {Set<String>}
		_this8._kinds = new Set();

		// Map of Consumers information indexed by consumer.id.
		// - kind {String}
		// - trackId {String}
		// - ssrc {Number}
		// - rtxSsrc {Number}
		// - cname {String}
		// @type {Map<Number, Object>}
		_this8._consumerInfos = new Map();
		return _this8;
	}

	_createClass(RecvHandler, [{
		key: 'addConsumer',
		value: function addConsumer(consumer) {
			var _this9 = this;

			logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);

			if (this._consumerInfos.has(consumer.id)) return Promise.reject('Consumer already added');

			var encoding = consumer.rtpParameters.encodings[0];
			var cname = consumer.rtpParameters.rtcp.cname;
			var consumerInfo = {
				kind: consumer.kind,
				trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
				ssrc: encoding.ssrc,
				cname: cname
			};

			if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;

			this._consumerInfos.set(consumer.id, consumerInfo);
			this._kinds.add(consumer.kind);

			return Promise.resolve().then(function () {
				if (!_this9._transportCreated) return _this9._setupTransport();
			}).then(function () {
				var remoteSdp = _this9._remoteSdp.createOfferSdp(Array.from(_this9._kinds), Array.from(_this9._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this9._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this9._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this9._pc.setLocalDescription(answer);
			}).then(function () {
				if (!_this9._transportUpdated) return _this9._updateTransport();
			}).then(function () {
				var newRtpReceiver = _this9._pc.getReceivers().find(function (rtpReceiver) {
					var track = rtpReceiver.track;


					if (!track) return false;

					return track.id === consumerInfo.trackId;
				});

				if (!newRtpReceiver) throw new Error('remote track not found');

				return newRtpReceiver.track;
			});
		}
	}, {
		key: 'removeConsumer',
		value: function removeConsumer(consumer) {
			var _this10 = this;

			logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);

			if (!this._consumerInfos.has(consumer.id)) return Promise.reject('Consumer not found');

			this._consumerInfos.delete(consumer.id);

			return Promise.resolve().then(function () {
				var remoteSdp = _this10._remoteSdp.createOfferSdp(Array.from(_this10._kinds), Array.from(_this10._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this10._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this10._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this10._pc.setLocalDescription(answer);
			});
		}
	}, {
		key: 'restartIce',
		value: function restartIce(remoteIceParameters) {
			var _this11 = this;

			logger.debug('restartIce()');

			// Provide the remote SDP handler with new remote ICE parameters.
			this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);

			return Promise.resolve().then(function () {
				var remoteSdp = _this11._remoteSdp.createOfferSdp(Array.from(_this11._kinds), Array.from(_this11._consumerInfos.values()));
				var offer = { type: 'offer', sdp: remoteSdp };

				logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);

				return _this11._pc.setRemoteDescription(offer);
			}).then(function () {
				return _this11._pc.createAnswer();
			}).then(function (answer) {
				logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);

				return _this11._pc.setLocalDescription(answer);
			});
		}
	}, {
		key: '_setupTransport',
		value: function _setupTransport() {
			var _this12 = this;

			logger.debug('_setupTransport()');

			return Promise.resolve().then(function () {
				// We need transport remote parameters.
				return _this12.safeEmitAsPromise('@needcreatetransport', null);
			}).then(function (transportRemoteParameters) {
				// Provide the remote SDP handler with transport remote parameters.
				_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);

				_this12._transportCreated = true;
			});
		}
	}, {
		key: '_updateTransport',
		value: function _updateTransport() {
			logger.debug('_updateTransport()');

			// Get our local DTLS parameters.
			// const transportLocalParameters = {};
			var sdp = this._pc.localDescription.sdp;
			var sdpObj = _sdpTransform2.default.parse(sdp);
			var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
			var transportLocalParameters = { dtlsParameters: dtlsParameters };

			// We need to provide transport local parameters.
			this.safeEmit('@needupdatetransport', transportLocalParameters);

			this._transportUpdated = true;
		}
	}]);

	return RecvHandler;
}(Handler);

var Safari11 = function () {
	_createClass(Safari11, null, [{
		key: 'getNativeRtpCapabilities',
		value: function getNativeRtpCapabilities() {
			logger.debug('getNativeRtpCapabilities()');

			var pc = new RTCPeerConnection({
				iceServers: [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});

			pc.addTransceiver('audio');
			pc.addTransceiver('video');

			return pc.createOffer().then(function (offer) {
				try {
					pc.close();
				} catch (error) {}

				var sdpObj = _sdpTransform2.default.parse(offer.sdp);
				var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);

				return nativeRtpCapabilities;
			}).catch(function (error) {
				try {
					pc.close();
				} catch (error2) {}

				throw error;
			});
		}
	}, {
		key: 'name',
		get: function get() {
			return 'Safari11';
		}
	}]);

	function Safari11(direction, extendedRtpCapabilities, settings) {
		_classCallCheck(this, Safari11);

		logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);

		var rtpParametersByKind = void 0;

		switch (direction) {
			case 'send':
				{
					rtpParametersByKind = {
						audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
						video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
					};

					return new SendHandler(rtpParametersByKind, settings);
				}
			case 'recv':
				{
					rtpParametersByKind = {
						audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
						video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
					};

					return new RecvHandler(rtpParametersByKind, settings);
				}
		}
	}

	return Safari11;
}();

exports.default = Safari11;
},{"../EnhancedEventEmitter":32,"../Logger":33,"../ortc":50,"../utils":51,"./sdp/RemotePlanBSdp":44,"./sdp/commonUtils":46,"./sdp/planBUtils":47,"sdp-transform":59}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getCapabilities = getCapabilities;
exports.mangleRtpParameters = mangleRtpParameters;

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Normalize Edge's RTCRtpReceiver.getCapabilities() to produce a full
 * compliant ORTC RTCRtpCapabilities.
 *
 * @return {RTCRtpCapabilities}
 */
function getCapabilities() {
	var nativeCaps = RTCRtpReceiver.getCapabilities();
	var caps = utils.clone(nativeCaps);

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = caps.codecs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var codec = _step.value;

			// Rename numChannels to channels.
			codec.channels = codec.numChannels;
			delete codec.numChannels;

			// Normalize channels.
			if (codec.kind !== 'audio') delete codec.channels;else if (!codec.channels) codec.channels = 1;

			// Add mimeType.
			codec.mimeType = codec.kind + '/' + codec.name;

			// NOTE: Edge sets parameters.apt as String rather than Number. Fix it.
			if (codec.name === 'rtx') codec.parameters.apt = Number(codec.parameters.apt);

			// Delete emty parameter String in rtcpFeedback.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = (codec.rtcpFeedback || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var feedback = _step2.value;

					if (!feedback.parameter) delete feedback.parameter;
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return caps;
}

/**
 * Generate RTCRtpParameters as Edge like them.
 *
 * @param  {RTCRtpParameters} rtpParameters
 * @return {RTCRtpParameters}
 */
/* global RTCRtpReceiver */

function mangleRtpParameters(rtpParameters) {
	var params = utils.clone(rtpParameters);

	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = params.codecs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var codec = _step3.value;

			// Rename channels to numChannels.
			if (codec.channels) {
				codec.numChannels = codec.channels;
				delete codec.channels;
			}

			// Remove mimeType.
			delete codec.mimeType;
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	return params;
}
},{"../../utils":51}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _Logger = require('../../Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logger = new _Logger2.default('RemotePlanBSdp');

var RemoteSdp = function () {
	function RemoteSdp(rtpParametersByKind) {
		_classCallCheck(this, RemoteSdp);

		// Generic sending RTP parameters for audio and video.
		// @type {Object}
		this._rtpParametersByKind = rtpParametersByKind;

		// Transport local parameters, including DTLS parameteres.
		// @type {Object}
		this._transportLocalParameters = null;

		// Transport remote parameters, including ICE parameters, ICE candidates
		// and DTLS parameteres.
		// @type {Object}
		this._transportRemoteParameters = null;

		// SDP global fields.
		// @type {Object}
		this._sdpGlobalFields = {
			id: utils.randomNumber(),
			version: 0
		};
	}

	_createClass(RemoteSdp, [{
		key: 'setTransportLocalParameters',
		value: function setTransportLocalParameters(transportLocalParameters) {
			logger.debug('setTransportLocalParameters() [transportLocalParameters:%o]', transportLocalParameters);

			this._transportLocalParameters = transportLocalParameters;
		}
	}, {
		key: 'setTransportRemoteParameters',
		value: function setTransportRemoteParameters(transportRemoteParameters) {
			logger.debug('setTransportRemoteParameters() [transportRemoteParameters:%o]', transportRemoteParameters);

			this._transportRemoteParameters = transportRemoteParameters;
		}
	}, {
		key: 'updateTransportRemoteIceParameters',
		value: function updateTransportRemoteIceParameters(remoteIceParameters) {
			logger.debug('updateTransportRemoteIceParameters() [remoteIceParameters:%o]', remoteIceParameters);

			this._transportRemoteParameters.iceParameters = remoteIceParameters;
		}
	}]);

	return RemoteSdp;
}();

var SendRemoteSdp = function (_RemoteSdp) {
	_inherits(SendRemoteSdp, _RemoteSdp);

	function SendRemoteSdp(rtpParametersByKind) {
		_classCallCheck(this, SendRemoteSdp);

		return _possibleConstructorReturn(this, (SendRemoteSdp.__proto__ || Object.getPrototypeOf(SendRemoteSdp)).call(this, rtpParametersByKind));
	}

	_createClass(SendRemoteSdp, [{
		key: 'createAnswerSdp',
		value: function createAnswerSdp(localSdpObj) {
			logger.debug('createAnswerSdp()');

			if (!this._transportLocalParameters) throw new Error('no transport local parameters');else if (!this._transportRemoteParameters) throw new Error('no transport remote parameters');

			var remoteIceParameters = this._transportRemoteParameters.iceParameters;
			var remoteIceCandidates = this._transportRemoteParameters.iceCandidates;
			var remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;
			var sdpObj = {};
			var mids = (localSdpObj.media || []).map(function (m) {
				return m.mid;
			});

			// Increase our SDP version.
			this._sdpGlobalFields.version++;

			sdpObj.version = 0;
			sdpObj.origin = {
				address: '0.0.0.0',
				ipVer: 4,
				netType: 'IN',
				sessionId: this._sdpGlobalFields.id,
				sessionVersion: this._sdpGlobalFields.version,
				username: 'mediasoup-client'
			};
			sdpObj.name = '-';
			sdpObj.timing = { start: 0, stop: 0 };
			sdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;
			sdpObj.msidSemantic = {
				semantic: 'WMS',
				token: '*'
			};
			sdpObj.groups = [{
				type: 'BUNDLE',
				mids: mids.join(' ')
			}];
			sdpObj.media = [];

			// NOTE: We take the latest fingerprint.
			var numFingerprints = remoteDtlsParameters.fingerprints.length;

			sdpObj.fingerprint = {
				type: remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,
				hash: remoteDtlsParameters.fingerprints[numFingerprints - 1].value
			};

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = (localSdpObj.media || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var localMediaObj = _step.value;

					var kind = localMediaObj.type;
					var codecs = this._rtpParametersByKind[kind].codecs;
					var headerExtensions = this._rtpParametersByKind[kind].headerExtensions;
					var remoteMediaObj = {};

					remoteMediaObj.type = localMediaObj.type;
					remoteMediaObj.port = 7;
					remoteMediaObj.protocol = 'RTP/SAVPF';
					remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
					remoteMediaObj.mid = localMediaObj.mid;

					remoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;
					remoteMediaObj.icePwd = remoteIceParameters.password;
					remoteMediaObj.candidates = [];

					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = remoteIceCandidates[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var candidate = _step2.value;

							var candidateObj = {};

							// mediasoup does not support non rtcp-mux so candidates component is
							// always RTP (1).
							candidateObj.component = 1;
							candidateObj.foundation = candidate.foundation;
							candidateObj.ip = candidate.ip;
							candidateObj.port = candidate.port;
							candidateObj.priority = candidate.priority;
							candidateObj.transport = candidate.protocol;
							candidateObj.type = candidate.type;
							if (candidate.tcpType) candidateObj.tcptype = candidate.tcpType;

							remoteMediaObj.candidates.push(candidateObj);
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}

					remoteMediaObj.endOfCandidates = 'end-of-candidates';

					// Announce support for ICE renomination.
					// https://tools.ietf.org/html/draft-thatcher-ice-renomination
					remoteMediaObj.iceOptions = 'renomination';

					switch (remoteDtlsParameters.role) {
						case 'client':
							remoteMediaObj.setup = 'active';
							break;
						case 'server':
							remoteMediaObj.setup = 'passive';
							break;
					}

					switch (localMediaObj.direction) {
						case 'sendrecv':
						case 'sendonly':
							remoteMediaObj.direction = 'recvonly';
							break;
						case 'recvonly':
						case 'inactive':
							remoteMediaObj.direction = 'inactive';
							break;
					}

					// If video, be ready for simulcast.
					if (kind === 'video') remoteMediaObj.xGoogleFlag = 'conference';

					remoteMediaObj.rtp = [];
					remoteMediaObj.rtcpFb = [];
					remoteMediaObj.fmtp = [];

					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = codecs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var codec = _step3.value;

							var rtp = {
								payload: codec.payloadType,
								codec: codec.name,
								rate: codec.clockRate
							};

							if (codec.channels > 1) rtp.encoding = codec.channels;

							remoteMediaObj.rtp.push(rtp);

							if (codec.parameters) {
								var paramFmtp = {
									payload: codec.payloadType,
									config: ''
								};

								var _iteratorNormalCompletion5 = true;
								var _didIteratorError5 = false;
								var _iteratorError5 = undefined;

								try {
									for (var _iterator5 = Object.keys(codec.parameters)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
										var key = _step5.value;

										if (paramFmtp.config) paramFmtp.config += ';';

										paramFmtp.config += key + '=' + codec.parameters[key];
									}
								} catch (err) {
									_didIteratorError5 = true;
									_iteratorError5 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion5 && _iterator5.return) {
											_iterator5.return();
										}
									} finally {
										if (_didIteratorError5) {
											throw _iteratorError5;
										}
									}
								}

								if (paramFmtp.config) remoteMediaObj.fmtp.push(paramFmtp);
							}

							if (codec.rtcpFeedback) {
								var _iteratorNormalCompletion6 = true;
								var _didIteratorError6 = false;
								var _iteratorError6 = undefined;

								try {
									for (var _iterator6 = codec.rtcpFeedback[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
										var fb = _step6.value;

										remoteMediaObj.rtcpFb.push({
											payload: codec.payloadType,
											type: fb.type,
											subtype: fb.parameter || ''
										});
									}
								} catch (err) {
									_didIteratorError6 = true;
									_iteratorError6 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion6 && _iterator6.return) {
											_iterator6.return();
										}
									} finally {
										if (_didIteratorError6) {
											throw _iteratorError6;
										}
									}
								}
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}

					remoteMediaObj.payloads = codecs.map(function (codec) {
						return codec.payloadType;
					}).join(' ');

					remoteMediaObj.ext = [];

					var _loop = function _loop(ext) {
						// Don't add a header extension if not present in the offer.
						var matchedLocalExt = (localMediaObj.ext || []).find(function (localExt) {
							return localExt.uri === ext.uri;
						});

						if (!matchedLocalExt) return 'continue';

						remoteMediaObj.ext.push({
							uri: ext.uri,
							value: ext.id
						});
					};

					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = headerExtensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var ext = _step4.value;

							var _ret = _loop(ext);

							if (_ret === 'continue') continue;
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}

					remoteMediaObj.rtcpMux = 'rtcp-mux';
					remoteMediaObj.rtcpRsize = 'rtcp-rsize';

					// Push it.
					sdpObj.media.push(remoteMediaObj);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var sdp = _sdpTransform2.default.write(sdpObj);

			return sdp;
		}
	}]);

	return SendRemoteSdp;
}(RemoteSdp);

var RecvRemoteSdp = function (_RemoteSdp2) {
	_inherits(RecvRemoteSdp, _RemoteSdp2);

	function RecvRemoteSdp(rtpParametersByKind) {
		_classCallCheck(this, RecvRemoteSdp);

		// Id of the unique MediaStream for all the remote tracks.
		var _this2 = _possibleConstructorReturn(this, (RecvRemoteSdp.__proto__ || Object.getPrototypeOf(RecvRemoteSdp)).call(this, rtpParametersByKind));

		_this2._streamId = 'recv-stream-' + utils.randomNumber();
		return _this2;
	}

	/**
  * @param {Array<String>} kinds - Media kinds.
  * @param {Array<Object>} consumerInfos - Consumer informations.
  * @return {String}
  */


	_createClass(RecvRemoteSdp, [{
		key: 'createOfferSdp',
		value: function createOfferSdp(kinds, consumerInfos) {
			var _this3 = this;

			logger.debug('createOfferSdp()');

			if (!this._transportRemoteParameters) throw new Error('no transport remote parameters');

			var remoteIceParameters = this._transportRemoteParameters.iceParameters;
			var remoteIceCandidates = this._transportRemoteParameters.iceCandidates;
			var remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;
			var sdpObj = {};
			var mids = kinds;

			// Increase our SDP version.
			this._sdpGlobalFields.version++;

			sdpObj.version = 0;
			sdpObj.origin = {
				address: '0.0.0.0',
				ipVer: 4,
				netType: 'IN',
				sessionId: this._sdpGlobalFields.id,
				sessionVersion: this._sdpGlobalFields.version,
				username: 'mediasoup-client'
			};
			sdpObj.name = '-';
			sdpObj.timing = { start: 0, stop: 0 };
			sdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;
			sdpObj.msidSemantic = {
				semantic: 'WMS',
				token: '*'
			};
			sdpObj.groups = [{
				type: 'BUNDLE',
				mids: mids.join(' ')
			}];
			sdpObj.media = [];

			// NOTE: We take the latest fingerprint.
			var numFingerprints = remoteDtlsParameters.fingerprints.length;

			sdpObj.fingerprint = {
				type: remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,
				hash: remoteDtlsParameters.fingerprints[numFingerprints - 1].value
			};

			var _loop2 = function _loop2(kind) {
				var codecs = _this3._rtpParametersByKind[kind].codecs;
				var headerExtensions = _this3._rtpParametersByKind[kind].headerExtensions;
				var remoteMediaObj = {};

				remoteMediaObj.type = kind;
				remoteMediaObj.port = 7;
				remoteMediaObj.protocol = 'RTP/SAVPF';
				remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
				remoteMediaObj.mid = kind;

				remoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;
				remoteMediaObj.icePwd = remoteIceParameters.password;
				remoteMediaObj.candidates = [];

				var _iteratorNormalCompletion8 = true;
				var _didIteratorError8 = false;
				var _iteratorError8 = undefined;

				try {
					for (var _iterator8 = remoteIceCandidates[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
						var candidate = _step8.value;

						var candidateObj = {};

						// mediasoup does not support non rtcp-mux so candidates component is
						// always RTP (1).
						candidateObj.component = 1;
						candidateObj.foundation = candidate.foundation;
						candidateObj.ip = candidate.ip;
						candidateObj.port = candidate.port;
						candidateObj.priority = candidate.priority;
						candidateObj.transport = candidate.protocol;
						candidateObj.type = candidate.type;
						if (candidate.tcpType) candidateObj.tcptype = candidate.tcpType;

						remoteMediaObj.candidates.push(candidateObj);
					}
				} catch (err) {
					_didIteratorError8 = true;
					_iteratorError8 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion8 && _iterator8.return) {
							_iterator8.return();
						}
					} finally {
						if (_didIteratorError8) {
							throw _iteratorError8;
						}
					}
				}

				remoteMediaObj.endOfCandidates = 'end-of-candidates';

				// Announce support for ICE renomination.
				// https://tools.ietf.org/html/draft-thatcher-ice-renomination
				remoteMediaObj.iceOptions = 'renomination';

				remoteMediaObj.setup = 'actpass';

				if (consumerInfos.some(function (info) {
					return info.kind === kind;
				})) remoteMediaObj.direction = 'sendonly';else remoteMediaObj.direction = 'inactive';

				remoteMediaObj.rtp = [];
				remoteMediaObj.rtcpFb = [];
				remoteMediaObj.fmtp = [];

				var _iteratorNormalCompletion9 = true;
				var _didIteratorError9 = false;
				var _iteratorError9 = undefined;

				try {
					for (var _iterator9 = codecs[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
						var codec = _step9.value;

						var rtp = {
							payload: codec.payloadType,
							codec: codec.name,
							rate: codec.clockRate
						};

						if (codec.channels > 1) rtp.encoding = codec.channels;

						remoteMediaObj.rtp.push(rtp);

						if (codec.parameters) {
							var paramFmtp = {
								payload: codec.payloadType,
								config: ''
							};

							var _iteratorNormalCompletion12 = true;
							var _didIteratorError12 = false;
							var _iteratorError12 = undefined;

							try {
								for (var _iterator12 = Object.keys(codec.parameters)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
									var key = _step12.value;

									if (paramFmtp.config) paramFmtp.config += ';';

									paramFmtp.config += key + '=' + codec.parameters[key];
								}
							} catch (err) {
								_didIteratorError12 = true;
								_iteratorError12 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion12 && _iterator12.return) {
										_iterator12.return();
									}
								} finally {
									if (_didIteratorError12) {
										throw _iteratorError12;
									}
								}
							}

							if (paramFmtp.config) remoteMediaObj.fmtp.push(paramFmtp);
						}

						if (codec.rtcpFeedback) {
							var _iteratorNormalCompletion13 = true;
							var _didIteratorError13 = false;
							var _iteratorError13 = undefined;

							try {
								for (var _iterator13 = codec.rtcpFeedback[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
									var fb = _step13.value;

									remoteMediaObj.rtcpFb.push({
										payload: codec.payloadType,
										type: fb.type,
										subtype: fb.parameter || ''
									});
								}
							} catch (err) {
								_didIteratorError13 = true;
								_iteratorError13 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion13 && _iterator13.return) {
										_iterator13.return();
									}
								} finally {
									if (_didIteratorError13) {
										throw _iteratorError13;
									}
								}
							}
						}
					}
				} catch (err) {
					_didIteratorError9 = true;
					_iteratorError9 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion9 && _iterator9.return) {
							_iterator9.return();
						}
					} finally {
						if (_didIteratorError9) {
							throw _iteratorError9;
						}
					}
				}

				remoteMediaObj.payloads = codecs.map(function (codec) {
					return codec.payloadType;
				}).join(' ');

				remoteMediaObj.ext = [];

				var _iteratorNormalCompletion10 = true;
				var _didIteratorError10 = false;
				var _iteratorError10 = undefined;

				try {
					for (var _iterator10 = headerExtensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
						var ext = _step10.value;

						remoteMediaObj.ext.push({
							uri: ext.uri,
							value: ext.id
						});
					}
				} catch (err) {
					_didIteratorError10 = true;
					_iteratorError10 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion10 && _iterator10.return) {
							_iterator10.return();
						}
					} finally {
						if (_didIteratorError10) {
							throw _iteratorError10;
						}
					}
				}

				remoteMediaObj.rtcpMux = 'rtcp-mux';
				remoteMediaObj.rtcpRsize = 'rtcp-rsize';

				remoteMediaObj.ssrcs = [];
				remoteMediaObj.ssrcGroups = [];

				var _iteratorNormalCompletion11 = true;
				var _didIteratorError11 = false;
				var _iteratorError11 = undefined;

				try {
					for (var _iterator11 = consumerInfos[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
						var info = _step11.value;

						if (info.kind !== kind) continue;

						remoteMediaObj.ssrcs.push({
							id: info.ssrc,
							attribute: 'msid',
							value: _this3._streamId + ' ' + info.trackId
						});

						remoteMediaObj.ssrcs.push({
							id: info.ssrc,
							attribute: 'mslabel',
							value: _this3._streamId
						});

						remoteMediaObj.ssrcs.push({
							id: info.ssrc,
							attribute: 'label',
							value: info.trackId
						});

						remoteMediaObj.ssrcs.push({
							id: info.ssrc,
							attribute: 'cname',
							value: info.cname
						});

						if (info.rtxSsrc) {
							remoteMediaObj.ssrcs.push({
								id: info.rtxSsrc,
								attribute: 'msid',
								value: _this3._streamId + ' ' + info.trackId
							});

							remoteMediaObj.ssrcs.push({
								id: info.rtxSsrc,
								attribute: 'mslabel',
								value: _this3._streamId
							});

							remoteMediaObj.ssrcs.push({
								id: info.rtxSsrc,
								attribute: 'label',
								value: info.trackId
							});

							remoteMediaObj.ssrcs.push({
								id: info.rtxSsrc,
								attribute: 'cname',
								value: info.cname
							});

							// Associate original and retransmission SSRC.
							remoteMediaObj.ssrcGroups.push({
								semantics: 'FID',
								ssrcs: info.ssrc + ' ' + info.rtxSsrc
							});
						}
					}

					// Push it.
				} catch (err) {
					_didIteratorError11 = true;
					_iteratorError11 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion11 && _iterator11.return) {
							_iterator11.return();
						}
					} finally {
						if (_didIteratorError11) {
							throw _iteratorError11;
						}
					}
				}

				sdpObj.media.push(remoteMediaObj);
			};

			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = kinds[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var kind = _step7.value;

					_loop2(kind);
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			var sdp = _sdpTransform2.default.write(sdpObj);

			return sdp;
		}
	}]);

	return RecvRemoteSdp;
}(RemoteSdp);

var RemotePlanBSdp = function RemotePlanBSdp(direction, rtpParametersByKind) {
	_classCallCheck(this, RemotePlanBSdp);

	logger.debug('constructor() [direction:%s, rtpParametersByKind:%o]', direction, rtpParametersByKind);

	switch (direction) {
		case 'send':
			return new SendRemoteSdp(rtpParametersByKind);
		case 'recv':
			return new RecvRemoteSdp(rtpParametersByKind);
	}
};

exports.default = RemotePlanBSdp;
},{"../../Logger":33,"../../utils":51,"sdp-transform":59}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _Logger = require('../../Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logger = new _Logger2.default('RemoteUnifiedPlanSdp');

var RemoteSdp = function () {
	function RemoteSdp(rtpParametersByKind) {
		_classCallCheck(this, RemoteSdp);

		// Generic sending RTP parameters for audio and video.
		// @type {Object}
		this._rtpParametersByKind = rtpParametersByKind;

		// Transport local parameters, including DTLS parameteres.
		// @type {Object}
		this._transportLocalParameters = null;

		// Transport remote parameters, including ICE parameters, ICE candidates
		// and DTLS parameteres.
		// @type {Object}
		this._transportRemoteParameters = null;

		// SDP global fields.
		// @type {Object}
		this._sdpGlobalFields = {
			id: utils.randomNumber(),
			version: 0
		};
	}

	_createClass(RemoteSdp, [{
		key: 'setTransportLocalParameters',
		value: function setTransportLocalParameters(transportLocalParameters) {
			logger.debug('setTransportLocalParameters() [transportLocalParameters:%o]', transportLocalParameters);

			this._transportLocalParameters = transportLocalParameters;
		}
	}, {
		key: 'setTransportRemoteParameters',
		value: function setTransportRemoteParameters(transportRemoteParameters) {
			logger.debug('setTransportRemoteParameters() [transportRemoteParameters:%o]', transportRemoteParameters);

			this._transportRemoteParameters = transportRemoteParameters;
		}
	}, {
		key: 'updateTransportRemoteIceParameters',
		value: function updateTransportRemoteIceParameters(remoteIceParameters) {
			logger.debug('updateTransportRemoteIceParameters() [remoteIceParameters:%o]', remoteIceParameters);

			this._transportRemoteParameters.iceParameters = remoteIceParameters;
		}
	}]);

	return RemoteSdp;
}();

var SendRemoteSdp = function (_RemoteSdp) {
	_inherits(SendRemoteSdp, _RemoteSdp);

	function SendRemoteSdp(rtpParametersByKind) {
		_classCallCheck(this, SendRemoteSdp);

		return _possibleConstructorReturn(this, (SendRemoteSdp.__proto__ || Object.getPrototypeOf(SendRemoteSdp)).call(this, rtpParametersByKind));
	}

	_createClass(SendRemoteSdp, [{
		key: 'createAnswerSdp',
		value: function createAnswerSdp(localSdpObj) {
			logger.debug('createAnswerSdp()');

			if (!this._transportLocalParameters) throw new Error('no transport local parameters');else if (!this._transportRemoteParameters) throw new Error('no transport remote parameters');

			var remoteIceParameters = this._transportRemoteParameters.iceParameters;
			var remoteIceCandidates = this._transportRemoteParameters.iceCandidates;
			var remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;
			var sdpObj = {};
			var mids = (localSdpObj.media || []).filter(function (m) {
				return m.mid;
			}).map(function (m) {
				return m.mid;
			});

			// Increase our SDP version.
			this._sdpGlobalFields.version++;

			sdpObj.version = 0;
			sdpObj.origin = {
				address: '0.0.0.0',
				ipVer: 4,
				netType: 'IN',
				sessionId: this._sdpGlobalFields.id,
				sessionVersion: this._sdpGlobalFields.version,
				username: 'mediasoup-client'
			};
			sdpObj.name = '-';
			sdpObj.timing = { start: 0, stop: 0 };
			sdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;
			sdpObj.msidSemantic = {
				semantic: 'WMS',
				token: '*'
			};

			if (mids.length > 0) {
				sdpObj.groups = [{
					type: 'BUNDLE',
					mids: mids.join(' ')
				}];
			}

			sdpObj.media = [];

			// NOTE: We take the latest fingerprint.
			var numFingerprints = remoteDtlsParameters.fingerprints.length;

			sdpObj.fingerprint = {
				type: remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,
				hash: remoteDtlsParameters.fingerprints[numFingerprints - 1].value
			};

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = (localSdpObj.media || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var localMediaObj = _step.value;

					var closed = localMediaObj.direction === 'inactive';
					var kind = localMediaObj.type;
					var codecs = this._rtpParametersByKind[kind].codecs;
					var headerExtensions = this._rtpParametersByKind[kind].headerExtensions;
					var remoteMediaObj = {};

					remoteMediaObj.type = localMediaObj.type;
					remoteMediaObj.port = 7;
					remoteMediaObj.protocol = 'RTP/SAVPF';
					remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
					remoteMediaObj.mid = localMediaObj.mid;

					remoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;
					remoteMediaObj.icePwd = remoteIceParameters.password;
					remoteMediaObj.candidates = [];

					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = remoteIceCandidates[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var candidate = _step2.value;

							var candidateObj = {};

							// mediasoup does not support non rtcp-mux so candidates component is
							// always RTP (1).
							candidateObj.component = 1;
							candidateObj.foundation = candidate.foundation;
							candidateObj.ip = candidate.ip;
							candidateObj.port = candidate.port;
							candidateObj.priority = candidate.priority;
							candidateObj.transport = candidate.protocol;
							candidateObj.type = candidate.type;
							if (candidate.tcpType) candidateObj.tcptype = candidate.tcpType;

							remoteMediaObj.candidates.push(candidateObj);
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}

					remoteMediaObj.endOfCandidates = 'end-of-candidates';

					// Announce support for ICE renomination.
					// https://tools.ietf.org/html/draft-thatcher-ice-renomination
					remoteMediaObj.iceOptions = 'renomination';

					switch (remoteDtlsParameters.role) {
						case 'client':
							remoteMediaObj.setup = 'active';
							break;
						case 'server':
							remoteMediaObj.setup = 'passive';
							break;
					}

					switch (localMediaObj.direction) {
						case 'sendrecv':
						case 'sendonly':
							remoteMediaObj.direction = 'recvonly';
							break;
						case 'recvonly':
						case 'inactive':
							remoteMediaObj.direction = 'inactive';
							break;
					}

					remoteMediaObj.rtp = [];
					remoteMediaObj.rtcpFb = [];
					remoteMediaObj.fmtp = [];

					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = codecs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var codec = _step3.value;

							var rtp = {
								payload: codec.payloadType,
								codec: codec.name,
								rate: codec.clockRate
							};

							if (codec.channels > 1) rtp.encoding = codec.channels;

							remoteMediaObj.rtp.push(rtp);

							if (codec.parameters) {
								var paramFmtp = {
									payload: codec.payloadType,
									config: ''
								};

								var _iteratorNormalCompletion6 = true;
								var _didIteratorError6 = false;
								var _iteratorError6 = undefined;

								try {
									for (var _iterator6 = Object.keys(codec.parameters)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
										var key = _step6.value;

										if (paramFmtp.config) paramFmtp.config += ';';

										paramFmtp.config += key + '=' + codec.parameters[key];
									}
								} catch (err) {
									_didIteratorError6 = true;
									_iteratorError6 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion6 && _iterator6.return) {
											_iterator6.return();
										}
									} finally {
										if (_didIteratorError6) {
											throw _iteratorError6;
										}
									}
								}

								if (paramFmtp.config) remoteMediaObj.fmtp.push(paramFmtp);
							}

							if (codec.rtcpFeedback) {
								var _iteratorNormalCompletion7 = true;
								var _didIteratorError7 = false;
								var _iteratorError7 = undefined;

								try {
									for (var _iterator7 = codec.rtcpFeedback[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
										var fb = _step7.value;

										remoteMediaObj.rtcpFb.push({
											payload: codec.payloadType,
											type: fb.type,
											subtype: fb.parameter || ''
										});
									}
								} catch (err) {
									_didIteratorError7 = true;
									_iteratorError7 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion7 && _iterator7.return) {
											_iterator7.return();
										}
									} finally {
										if (_didIteratorError7) {
											throw _iteratorError7;
										}
									}
								}
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}

					remoteMediaObj.payloads = codecs.map(function (codec) {
						return codec.payloadType;
					}).join(' ');

					// NOTE: Firefox does not like a=extmap lines if a=inactive.
					if (!closed) {
						remoteMediaObj.ext = [];

						var _loop = function _loop(ext) {
							// Don't add a header extension if not present in the offer.
							var matchedLocalExt = (localMediaObj.ext || []).find(function (localExt) {
								return localExt.uri === ext.uri;
							});

							if (!matchedLocalExt) return 'continue';

							remoteMediaObj.ext.push({
								uri: ext.uri,
								value: ext.id
							});
						};

						var _iteratorNormalCompletion4 = true;
						var _didIteratorError4 = false;
						var _iteratorError4 = undefined;

						try {
							for (var _iterator4 = headerExtensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
								var ext = _step4.value;

								var _ret = _loop(ext);

								if (_ret === 'continue') continue;
							}
						} catch (err) {
							_didIteratorError4 = true;
							_iteratorError4 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion4 && _iterator4.return) {
									_iterator4.return();
								}
							} finally {
								if (_didIteratorError4) {
									throw _iteratorError4;
								}
							}
						}
					}

					// Simulcast.
					if (localMediaObj.simulcast_03) {
						// eslint-disable-next-line camelcase
						remoteMediaObj.simulcast_03 = {
							value: localMediaObj.simulcast_03.value.replace(/send/g, 'recv')
						};

						remoteMediaObj.rids = [];

						var _iteratorNormalCompletion5 = true;
						var _didIteratorError5 = false;
						var _iteratorError5 = undefined;

						try {
							for (var _iterator5 = (localMediaObj.rids || [])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
								var rid = _step5.value;

								if (rid.direction !== 'send') continue;

								remoteMediaObj.rids.push({
									id: rid.id,
									direction: 'recv'
								});
							}
						} catch (err) {
							_didIteratorError5 = true;
							_iteratorError5 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion5 && _iterator5.return) {
									_iterator5.return();
								}
							} finally {
								if (_didIteratorError5) {
									throw _iteratorError5;
								}
							}
						}
					}

					remoteMediaObj.rtcpMux = 'rtcp-mux';
					remoteMediaObj.rtcpRsize = 'rtcp-rsize';

					// Push it.
					sdpObj.media.push(remoteMediaObj);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var sdp = _sdpTransform2.default.write(sdpObj);

			return sdp;
		}
	}]);

	return SendRemoteSdp;
}(RemoteSdp);

var RecvRemoteSdp = function (_RemoteSdp2) {
	_inherits(RecvRemoteSdp, _RemoteSdp2);

	function RecvRemoteSdp(rtpParametersByKind) {
		_classCallCheck(this, RecvRemoteSdp);

		// Id of the unique MediaStream for all the remote tracks.
		var _this2 = _possibleConstructorReturn(this, (RecvRemoteSdp.__proto__ || Object.getPrototypeOf(RecvRemoteSdp)).call(this, rtpParametersByKind));

		_this2._streamId = 'recv-stream-' + utils.randomNumber();
		return _this2;
	}

	/**
  * @param {Array<Object>} consumerInfos - Consumer informations.
  * @return {String}
  */


	_createClass(RecvRemoteSdp, [{
		key: 'createOfferSdp',
		value: function createOfferSdp(consumerInfos) {
			logger.debug('createOfferSdp()');

			if (!this._transportRemoteParameters) throw new Error('no transport remote parameters');

			var remoteIceParameters = this._transportRemoteParameters.iceParameters;
			var remoteIceCandidates = this._transportRemoteParameters.iceCandidates;
			var remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;
			var sdpObj = {};
			var mids = consumerInfos.filter(function (info) {
				return !info.closed;
			}).map(function (info) {
				return info.mid;
			});

			// Increase our SDP version.
			this._sdpGlobalFields.version++;

			sdpObj.version = 0;
			sdpObj.origin = {
				address: '0.0.0.0',
				ipVer: 4,
				netType: 'IN',
				sessionId: this._sdpGlobalFields.id,
				sessionVersion: this._sdpGlobalFields.version,
				username: 'mediasoup-client'
			};
			sdpObj.name = '-';
			sdpObj.timing = { start: 0, stop: 0 };
			sdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;
			sdpObj.msidSemantic = {
				semantic: 'WMS',
				token: '*'
			};

			if (mids.length > 0) {
				sdpObj.groups = [{
					type: 'BUNDLE',
					mids: mids.join(' ')
				}];
			}

			sdpObj.media = [];

			// NOTE: We take the latest fingerprint.
			var numFingerprints = remoteDtlsParameters.fingerprints.length;

			sdpObj.fingerprint = {
				type: remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,
				hash: remoteDtlsParameters.fingerprints[numFingerprints - 1].value
			};

			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = consumerInfos[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var info = _step8.value;

					var closed = info.closed;
					var kind = info.kind;
					var codecs = void 0;
					var headerExtensions = void 0;

					if (info.kind !== 'application') {
						codecs = this._rtpParametersByKind[kind].codecs;
						headerExtensions = this._rtpParametersByKind[kind].headerExtensions;
					}

					var remoteMediaObj = {};

					if (info.kind !== 'application') {
						remoteMediaObj.type = kind;
						remoteMediaObj.port = 7;
						remoteMediaObj.protocol = 'RTP/SAVPF';
						remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
						remoteMediaObj.mid = info.mid;
						remoteMediaObj.msid = this._streamId + ' ' + info.trackId;
					} else {
						remoteMediaObj.type = kind;
						remoteMediaObj.port = 9;
						remoteMediaObj.protocol = 'DTLS/SCTP';
						remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
						remoteMediaObj.mid = info.mid;
					}

					remoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;
					remoteMediaObj.icePwd = remoteIceParameters.password;
					remoteMediaObj.candidates = [];

					var _iteratorNormalCompletion9 = true;
					var _didIteratorError9 = false;
					var _iteratorError9 = undefined;

					try {
						for (var _iterator9 = remoteIceCandidates[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
							var candidate = _step9.value;

							var candidateObj = {};

							// mediasoup does not support non rtcp-mux so candidates component is
							// always RTP (1).
							candidateObj.component = 1;
							candidateObj.foundation = candidate.foundation;
							candidateObj.ip = candidate.ip;
							candidateObj.port = candidate.port;
							candidateObj.priority = candidate.priority;
							candidateObj.transport = candidate.protocol;
							candidateObj.type = candidate.type;
							if (candidate.tcpType) candidateObj.tcptype = candidate.tcpType;

							remoteMediaObj.candidates.push(candidateObj);
						}
					} catch (err) {
						_didIteratorError9 = true;
						_iteratorError9 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion9 && _iterator9.return) {
								_iterator9.return();
							}
						} finally {
							if (_didIteratorError9) {
								throw _iteratorError9;
							}
						}
					}

					remoteMediaObj.endOfCandidates = 'end-of-candidates';

					// Announce support for ICE renomination.
					// https://tools.ietf.org/html/draft-thatcher-ice-renomination
					remoteMediaObj.iceOptions = 'renomination';

					remoteMediaObj.setup = 'actpass';

					if (info.kind !== 'application') {
						if (!closed) remoteMediaObj.direction = 'sendonly';else remoteMediaObj.direction = 'inactive';

						remoteMediaObj.rtp = [];
						remoteMediaObj.rtcpFb = [];
						remoteMediaObj.fmtp = [];

						var _iteratorNormalCompletion10 = true;
						var _didIteratorError10 = false;
						var _iteratorError10 = undefined;

						try {
							for (var _iterator10 = codecs[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
								var codec = _step10.value;

								var rtp = {
									payload: codec.payloadType,
									codec: codec.name,
									rate: codec.clockRate
								};

								if (codec.channels > 1) rtp.encoding = codec.channels;

								remoteMediaObj.rtp.push(rtp);

								if (codec.parameters) {
									var paramFmtp = {
										payload: codec.payloadType,
										config: ''
									};

									var _iteratorNormalCompletion12 = true;
									var _didIteratorError12 = false;
									var _iteratorError12 = undefined;

									try {
										for (var _iterator12 = Object.keys(codec.parameters)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
											var key = _step12.value;

											if (paramFmtp.config) paramFmtp.config += ';';

											paramFmtp.config += key + '=' + codec.parameters[key];
										}
									} catch (err) {
										_didIteratorError12 = true;
										_iteratorError12 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion12 && _iterator12.return) {
												_iterator12.return();
											}
										} finally {
											if (_didIteratorError12) {
												throw _iteratorError12;
											}
										}
									}

									if (paramFmtp.config) remoteMediaObj.fmtp.push(paramFmtp);
								}

								if (codec.rtcpFeedback) {
									var _iteratorNormalCompletion13 = true;
									var _didIteratorError13 = false;
									var _iteratorError13 = undefined;

									try {
										for (var _iterator13 = codec.rtcpFeedback[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
											var fb = _step13.value;

											remoteMediaObj.rtcpFb.push({
												payload: codec.payloadType,
												type: fb.type,
												subtype: fb.parameter || ''
											});
										}
									} catch (err) {
										_didIteratorError13 = true;
										_iteratorError13 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion13 && _iterator13.return) {
												_iterator13.return();
											}
										} finally {
											if (_didIteratorError13) {
												throw _iteratorError13;
											}
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError10 = true;
							_iteratorError10 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion10 && _iterator10.return) {
									_iterator10.return();
								}
							} finally {
								if (_didIteratorError10) {
									throw _iteratorError10;
								}
							}
						}

						remoteMediaObj.payloads = codecs.map(function (codec) {
							return codec.payloadType;
						}).join(' ');

						// NOTE: Firefox does not like a=extmap lines if a=inactive.
						if (!closed) {
							remoteMediaObj.ext = [];

							var _iteratorNormalCompletion11 = true;
							var _didIteratorError11 = false;
							var _iteratorError11 = undefined;

							try {
								for (var _iterator11 = headerExtensions[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
									var ext = _step11.value;

									remoteMediaObj.ext.push({
										uri: ext.uri,
										value: ext.id
									});
								}
							} catch (err) {
								_didIteratorError11 = true;
								_iteratorError11 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion11 && _iterator11.return) {
										_iterator11.return();
									}
								} finally {
									if (_didIteratorError11) {
										throw _iteratorError11;
									}
								}
							}
						}

						remoteMediaObj.rtcpMux = 'rtcp-mux';
						remoteMediaObj.rtcpRsize = 'rtcp-rsize';

						if (!closed) {
							remoteMediaObj.ssrcs = [];
							remoteMediaObj.ssrcGroups = [];

							remoteMediaObj.ssrcs.push({
								id: info.ssrc,
								attribute: 'cname',
								value: info.cname
							});

							if (info.rtxSsrc) {
								remoteMediaObj.ssrcs.push({
									id: info.rtxSsrc,
									attribute: 'cname',
									value: info.cname
								});

								// Associate original and retransmission SSRC.
								remoteMediaObj.ssrcGroups.push({
									semantics: 'FID',
									ssrcs: info.ssrc + ' ' + info.rtxSsrc
								});
							}
						}
					} else {
						remoteMediaObj.payloads = 5000;
						remoteMediaObj.sctpmap = {
							app: 'webrtc-datachannel',
							maxMessageSize: 256,
							sctpmapNumber: 5000
						};
					}

					// Push it.
					sdpObj.media.push(remoteMediaObj);
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}

			var sdp = _sdpTransform2.default.write(sdpObj);

			return sdp;
		}
	}]);

	return RecvRemoteSdp;
}(RemoteSdp);

var RemoteUnifiedPlanSdp = function RemoteUnifiedPlanSdp(direction, rtpParametersByKind) {
	_classCallCheck(this, RemoteUnifiedPlanSdp);

	logger.debug('constructor() [direction:%s, rtpParametersByKind:%o]', direction, rtpParametersByKind);

	switch (direction) {
		case 'send':
			return new SendRemoteSdp(rtpParametersByKind);
		case 'recv':
			return new RecvRemoteSdp(rtpParametersByKind);
	}
};

exports.default = RemoteUnifiedPlanSdp;
},{"../../Logger":33,"../../utils":51,"sdp-transform":59}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.extractRtpCapabilities = extractRtpCapabilities;
exports.extractDtlsParameters = extractDtlsParameters;

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Extract RTP capabilities from a SDP.
 *
 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
 * @return {RTCRtpCapabilities}
 */
function extractRtpCapabilities(sdpObj) {
	// Map of RtpCodecParameters indexed by payload type.
	var codecsMap = new Map();

	// Array of RtpHeaderExtensions.
	var headerExtensions = [];

	// Whether a m=audio/video section has been already found.
	var gotAudio = false;
	var gotVideo = false;

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = sdpObj.media[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var m = _step.value;

			var kind = m.type;

			switch (kind) {
				case 'audio':
					{
						if (gotAudio) continue;

						gotAudio = true;
						break;
					}
				case 'video':
					{
						if (gotVideo) continue;

						gotVideo = true;
						break;
					}
				default:
					{
						continue;
					}
			}

			// Get codecs.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = m.rtp[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var rtp = _step2.value;

					var codec = {
						name: rtp.codec,
						mimeType: kind + '/' + rtp.codec,
						kind: kind,
						clockRate: rtp.rate,
						preferredPayloadType: rtp.payload,
						channels: rtp.encoding,
						rtcpFeedback: [],
						parameters: {}
					};

					if (codec.kind !== 'audio') delete codec.channels;else if (!codec.channels) codec.channels = 1;

					codecsMap.set(codec.preferredPayloadType, codec);
				}

				// Get codec parameters.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = (m.fmtp || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var fmtp = _step3.value;

					var parameters = _sdpTransform2.default.parseFmtpConfig(fmtp.config);
					var codec = codecsMap.get(fmtp.payload);

					if (!codec) continue;

					codec.parameters = parameters;
				}

				// Get RTCP feedback for each codec.
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = (m.rtcpFb || [])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var fb = _step4.value;

					var codec = codecsMap.get(fb.payload);

					if (!codec) continue;

					var feedback = {
						type: fb.type,
						parameter: fb.subtype
					};

					if (!feedback.parameter) delete feedback.parameter;

					codec.rtcpFeedback.push(feedback);
				}

				// Get RTP header extensions.
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = (m.ext || [])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var ext = _step5.value;

					var headerExtension = {
						kind: kind,
						uri: ext.uri,
						preferredId: ext.value
					};

					headerExtensions.push(headerExtension);
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var rtpCapabilities = {
		codecs: Array.from(codecsMap.values()),
		headerExtensions: headerExtensions,
		fecMechanisms: [] // TODO
	};

	return rtpCapabilities;
}

/**
 * Extract DTLS parameters from a SDP.
 *
 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
 * @return {RTCDtlsParameters}
 */
function extractDtlsParameters(sdpObj) {
	var media = getFirstActiveMediaSection(sdpObj);
	var fingerprint = media.fingerprint || sdpObj.fingerprint;
	var role = void 0;

	switch (media.setup) {
		case 'active':
			role = 'client';
			break;
		case 'passive':
			role = 'server';
			break;
		case 'actpass':
			role = 'auto';
			break;
	}

	var dtlsParameters = {
		role: role,
		fingerprints: [{
			algorithm: fingerprint.type,
			value: fingerprint.hash
		}]
	};

	return dtlsParameters;
}

/**
 * Get the first acive media section.
 *
 * @private
 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
 * @return {Object} SDP media section as parsed by sdp-transform.
 */
function getFirstActiveMediaSection(sdpObj) {
	return (sdpObj.media || []).find(function (m) {
		return m.iceUfrag && m.port !== 0;
	});
}
},{"sdp-transform":59}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.fillRtpParametersForTrack = fillRtpParametersForTrack;
exports.addSimulcastForTrack = addSimulcastForTrack;
/**
 * Fill the given RTP parameters for the given track.
 *
 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 */
function fillRtpParametersForTrack(rtpParameters, sdpObj, track) {
	var kind = track.kind;
	var rtcp = {
		cname: null,
		reducedSize: true,
		mux: true
	};

	var mSection = (sdpObj.media || []).find(function (m) {
		return m.type === kind;
	});

	if (!mSection) throw new Error('m=' + kind + ' section not found');

	// First media SSRC (or the only one).
	var firstSsrc = void 0;

	// Get all the SSRCs.

	var ssrcs = new Set();

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = (mSection.ssrcs || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var line = _step.value;

			if (line.attribute !== 'msid') continue;

			var trackId = line.value.split(' ')[1];

			if (trackId === track.id) {
				var _ssrc2 = line.id;

				ssrcs.add(_ssrc2);

				if (!firstSsrc) firstSsrc = _ssrc2;
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	if (ssrcs.size === 0) throw new Error('a=ssrc line not found for local track [track.id:' + track.id + ']');

	// Get media and RTX SSRCs.

	var ssrcToRtxSsrc = new Map();

	// First assume RTX is used.
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = (mSection.ssrcGroups || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var _line = _step2.value;

			if (_line.semantics !== 'FID') continue;

			var _line$ssrcs$split = _line.ssrcs.split(/\s+/),
			    _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),
			    ssrc = _line$ssrcs$split2[0],
			    rtxSsrc = _line$ssrcs$split2[1];

			ssrc = Number(ssrc);
			rtxSsrc = Number(rtxSsrc);

			if (ssrcs.has(ssrc)) {
				// Remove both the SSRC and RTX SSRC from the Set so later we know that they
				// are already handled.
				ssrcs.delete(ssrc);
				ssrcs.delete(rtxSsrc);

				// Add to the map.
				ssrcToRtxSsrc.set(ssrc, rtxSsrc);
			}
		}

		// If the Set of SSRCs is not empty it means that RTX is not being used, so take
		// media SSRCs from there.
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = ssrcs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var ssrc = _step3.value;

			// Add to the map.
			ssrcToRtxSsrc.set(ssrc, null);
		}

		// Get RTCP info.
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	var ssrcCnameLine = mSection.ssrcs.find(function (line) {
		return line.attribute === 'cname' && line.id === firstSsrc;
	});

	if (ssrcCnameLine) rtcp.cname = ssrcCnameLine.value;

	// Fill RTP parameters.

	rtpParameters.rtcp = rtcp;
	rtpParameters.encodings = [];

	var simulcast = ssrcToRtxSsrc.size > 1;
	var simulcastProfiles = ['low', 'medium', 'high'];

	var _iteratorNormalCompletion4 = true;
	var _didIteratorError4 = false;
	var _iteratorError4 = undefined;

	try {
		for (var _iterator4 = ssrcToRtxSsrc[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
			var _ref = _step4.value;

			var _ref2 = _slicedToArray(_ref, 2);

			var _ssrc = _ref2[0];
			var rtxSsrc = _ref2[1];

			var encoding = { ssrc: _ssrc };

			if (rtxSsrc) encoding.rtx = { ssrc: rtxSsrc };

			if (simulcast) encoding.profile = simulcastProfiles.shift();

			rtpParameters.encodings.push(encoding);
		}
	} catch (err) {
		_didIteratorError4 = true;
		_iteratorError4 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion4 && _iterator4.return) {
				_iterator4.return();
			}
		} finally {
			if (_didIteratorError4) {
				throw _iteratorError4;
			}
		}
	}
}

/**
 * Adds simulcast into the given SDP for the given track.
 *
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 */
function addSimulcastForTrack(sdpObj, track) {
	var kind = track.kind;

	var mSection = (sdpObj.media || []).find(function (m) {
		return m.type === kind;
	});

	if (!mSection) throw new Error('m=' + kind + ' section not found');

	var ssrc = void 0;
	var rtxSsrc = void 0;
	var msid = void 0;

	// Get the SSRC.

	var ssrcMsidLine = (mSection.ssrcs || []).find(function (line) {
		if (line.attribute !== 'msid') return false;

		var trackId = line.value.split(' ')[1];

		if (trackId === track.id) {
			ssrc = line.id;
			msid = line.value.split(' ')[0];

			return true;
		}
	});

	if (!ssrcMsidLine) throw new Error('a=ssrc line not found for local track [track.id:' + track.id + ']');

	// Get the SSRC for RTX.

	(mSection.ssrcGroups || []).some(function (line) {
		if (line.semantics !== 'FID') return;

		var ssrcs = line.ssrcs.split(/\s+/);

		if (Number(ssrcs[0]) === ssrc) {
			rtxSsrc = Number(ssrcs[1]);

			return true;
		}
	});

	var ssrcCnameLine = mSection.ssrcs.find(function (line) {
		return line.attribute === 'cname' && line.id === ssrc;
	});

	if (!ssrcCnameLine) throw new Error('CNAME line not found for local track [track.id:' + track.id + ']');

	var cname = ssrcCnameLine.value;
	var ssrc2 = ssrc + 1;
	var ssrc3 = ssrc + 2;

	mSection.ssrcGroups = mSection.ssrcGroups || [];

	mSection.ssrcGroups.push({
		semantics: 'SIM',
		ssrcs: ssrc + ' ' + ssrc2 + ' ' + ssrc3
	});

	mSection.ssrcs.push({
		id: ssrc2,
		attribute: 'cname',
		value: cname
	});

	mSection.ssrcs.push({
		id: ssrc2,
		attribute: 'msid',
		value: msid + ' ' + track.id
	});

	mSection.ssrcs.push({
		id: ssrc3,
		attribute: 'cname',
		value: cname
	});

	mSection.ssrcs.push({
		id: ssrc3,
		attribute: 'msid',
		value: msid + ' ' + track.id
	});

	if (rtxSsrc) {
		var rtxSsrc2 = rtxSsrc + 1;
		var rtxSsrc3 = rtxSsrc + 2;

		mSection.ssrcGroups.push({
			semantics: 'FID',
			ssrcs: ssrc2 + ' ' + rtxSsrc2
		});

		mSection.ssrcs.push({
			id: rtxSsrc2,
			attribute: 'cname',
			value: cname
		});

		mSection.ssrcs.push({
			id: rtxSsrc2,
			attribute: 'msid',
			value: msid + ' ' + track.id
		});

		mSection.ssrcGroups.push({
			semantics: 'FID',
			ssrcs: ssrc3 + ' ' + rtxSsrc3
		});

		mSection.ssrcs.push({
			id: rtxSsrc3,
			attribute: 'cname',
			value: cname
		});

		mSection.ssrcs.push({
			id: rtxSsrc3,
			attribute: 'msid',
			value: msid + ' ' + track.id
		});
	}
}
},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.fillRtpParametersForTrack = fillRtpParametersForTrack;
/**
 * Fill the given RTP parameters for the given track.
 *
 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 */
function fillRtpParametersForTrack(rtpParameters, sdpObj, track) {
	var kind = track.kind;
	var rtcp = {
		cname: null,
		reducedSize: true,
		mux: true
	};

	var mSection = (sdpObj.media || []).find(function (m) {
		if (m.type !== kind) return;

		var msidLine = m.msid;

		if (!msidLine) return;

		var trackId = msidLine.split(' ')[1];

		if (trackId === track.id) return true;
	});

	if (!mSection) throw new Error('m=' + kind + ' section not found');

	// Get the SSRC and CNAME.

	var ssrcCnameLine = (mSection.ssrcs || []).find(function (line) {
		return line.attribute === 'cname';
	});

	var ssrc = void 0;

	if (ssrcCnameLine) {
		ssrc = ssrcCnameLine.id;
		rtcp.cname = ssrcCnameLine.value;
	}

	// Get a=rid lines.

	// Array of Objects with rid and profile keys.
	var simulcastStreams = [];

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = (mSection.rids || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var rid = _step.value;

			if (rid.direction !== 'send') continue;

			if (/^low/.test(rid.id)) simulcastStreams.push({ rid: rid.id, profile: 'low' });else if (/^medium/.test(rid.id)) simulcastStreams.push({ rid: rid.id, profile: 'medium' });
			if (/^high/.test(rid.id)) simulcastStreams.push({ rid: rid.id, profile: 'high' });
		}

		// Fill RTP parameters.
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	rtpParameters.rtcp = rtcp;
	rtpParameters.encodings = [];

	if (simulcastStreams.length === 0) {
		var encoding = { ssrc: ssrc };

		rtpParameters.encodings.push(encoding);
	} else {
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = simulcastStreams[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var simulcastStream = _step2.value;

				var _encoding = {
					encodingId: simulcastStream.rid,
					profile: simulcastStream.profile
				};

				rtpParameters.encodings.push(_encoding);
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	}
}
},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Room = undefined;
exports.isDeviceSupported = isDeviceSupported;
exports.getDeviceInfo = getDeviceInfo;
exports.checkCapabilitiesForRoom = checkCapabilitiesForRoom;

var _ortc = require('./ortc');

var ortc = _interopRequireWildcard(_ortc);

var _Device = require('./Device');

var _Device2 = _interopRequireDefault(_Device);

var _Room = require('./Room');

var _Room2 = _interopRequireDefault(_Room);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Whether the current browser or device is supported.
 *
 * @return {Boolean}
 *
 * @example
 * isDeviceSupported()
 * // => true
 */
function isDeviceSupported() {
  return _Device2.default.isSupported();
}

/**
 * Get information regarding the current browser or device.
 *
 * @return {Object} - Object with `name` (String) and version {String}.
 *
 * @example
 * getDeviceInfo()
 * // => { flag: 'chrome', name: 'Chrome', version: '59.0', bowser: {} }
 */
function getDeviceInfo() {
  return {
    flag: _Device2.default.flag,
    name: _Device2.default.name,
    version: _Device2.default.version,
    bowser: _Device2.default.bowser
  };
}

/**
 * Check whether this device/browser can send/receive audio/video in a room
 * whose RTP capabilities are given.
 *
 * @param {Object} Room RTP capabilities.
 *
 * @return {Promise} Resolves to an Object with 'audio' and 'video' Booleans.
 */
function checkCapabilitiesForRoom(roomRtpCapabilities) {
  if (!_Device2.default.isSupported()) return Promise.reject(new Error('current browser/device not supported'));

  return _Device2.default.Handler.getNativeRtpCapabilities().then(function (nativeRtpCapabilities) {
    var extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, roomRtpCapabilities);

    return {
      audio: ortc.canSend('audio', extendedRtpCapabilities),
      video: ortc.canSend('video', extendedRtpCapabilities)
    };
  });
}

/**
 * Expose the Room class.
 *
 * @example
 * const room = new Room();`
 */
exports.Room = _Room2.default;
},{"./Device":31,"./Room":36,"./ortc":50}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
exports.getRtpCapabilities = getRtpCapabilities;
exports.getUnsupportedCodecs = getUnsupportedCodecs;
exports.canSend = canSend;
exports.canReceive = canReceive;
exports.getSendingRtpParameters = getSendingRtpParameters;
exports.getReceivingFullRtpParameters = getReceivingFullRtpParameters;
/**
 * Generate extended RTP capabilities for sending and receiving.
 *
 * @param {RTCRtpCapabilities} localCaps - Local capabilities.
 * @param {RTCRtpCapabilities} remoteCaps - Remote capabilities.
 *
 * @return {RTCExtendedRtpCapabilities}
 */
function getExtendedRtpCapabilities(localCaps, remoteCaps) {
	var extendedCaps = {
		codecs: [],
		headerExtensions: [],
		fecMechanisms: []
	};

	// Match media codecs and keep the order preferred by remoteCaps.

	var _loop = function _loop(remoteCodec) {
		// TODO: Ignore pseudo-codecs and feature codecs.
		if (remoteCodec.name === 'rtx') return 'continue';

		var matchingLocalCodec = (localCaps.codecs || []).find(function (localCodec) {
			return matchCapCodecs(localCodec, remoteCodec);
		});

		if (matchingLocalCodec) {
			var extendedCodec = {
				name: remoteCodec.name,
				mimeType: remoteCodec.mimeType,
				kind: remoteCodec.kind,
				clockRate: remoteCodec.clockRate,
				sendPayloadType: matchingLocalCodec.preferredPayloadType,
				sendRtxPayloadType: null,
				recvPayloadType: remoteCodec.preferredPayloadType,
				recvRtxPayloadType: null,
				channels: remoteCodec.channels,
				rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec),
				parameters: remoteCodec.parameters
			};

			if (!extendedCodec.channels) delete extendedCodec.channels;

			extendedCaps.codecs.push(extendedCodec);
		}
	};

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = (remoteCaps.codecs || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var remoteCodec = _step.value;

			var _ret = _loop(remoteCodec);

			if (_ret === 'continue') continue;
		}

		// Match RTX codecs.
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var _loop2 = function _loop2(extendedCodec) {
		var matchingLocalRtxCodec = (localCaps.codecs || []).find(function (localCodec) {
			return localCodec.name === 'rtx' && localCodec.parameters.apt === extendedCodec.sendPayloadType;
		});

		var matchingRemoteRtxCodec = (remoteCaps.codecs || []).find(function (remoteCodec) {
			return remoteCodec.name === 'rtx' && remoteCodec.parameters.apt === extendedCodec.recvPayloadType;
		});

		if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
			extendedCodec.sendRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
			extendedCodec.recvRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
		}
	};

	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = (extendedCaps.codecs || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var extendedCodec = _step2.value;

			_loop2(extendedCodec);
		}

		// Match header extensions.
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	var _loop3 = function _loop3(remoteExt) {
		var matchingLocalExt = (localCaps.headerExtensions || []).find(function (localExt) {
			return matchCapHeaderExtensions(localExt, remoteExt);
		});

		if (matchingLocalExt) {
			var extendedExt = {
				kind: remoteExt.kind,
				uri: remoteExt.uri,
				sendId: matchingLocalExt.preferredId,
				recvId: remoteExt.preferredId
			};

			extendedCaps.headerExtensions.push(extendedExt);
		}
	};

	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = (remoteCaps.headerExtensions || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var remoteExt = _step3.value;

			_loop3(remoteExt);
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	return extendedCaps;
}

/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 *
 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
 *
 * @return {RTCRtpCapabilities}
 */
function getRtpCapabilities(extendedRtpCapabilities) {
	var caps = {
		codecs: [],
		headerExtensions: [],
		fecMechanisms: []
	};

	var _iteratorNormalCompletion4 = true;
	var _didIteratorError4 = false;
	var _iteratorError4 = undefined;

	try {
		for (var _iterator4 = extendedRtpCapabilities.codecs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
			var capCodec = _step4.value;

			var codec = {
				name: capCodec.name,
				mimeType: capCodec.mimeType,
				kind: capCodec.kind,
				clockRate: capCodec.clockRate,
				preferredPayloadType: capCodec.recvPayloadType,
				channels: capCodec.channels,
				rtcpFeedback: capCodec.rtcpFeedback,
				parameters: capCodec.parameters
			};

			if (!codec.channels) delete codec.channels;

			caps.codecs.push(codec);

			// Add RTX codec.
			if (capCodec.recvRtxPayloadType) {
				var rtxCapCodec = {
					name: 'rtx',
					mimeType: capCodec.kind + '/rtx',
					kind: capCodec.kind,
					clockRate: capCodec.clockRate,
					preferredPayloadType: capCodec.recvRtxPayloadType,
					parameters: {
						apt: capCodec.recvPayloadType
					}
				};

				caps.codecs.push(rtxCapCodec);
			}

			// TODO: In the future, we need to add FEC, CN, etc, codecs.
		}
	} catch (err) {
		_didIteratorError4 = true;
		_iteratorError4 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion4 && _iterator4.return) {
				_iterator4.return();
			}
		} finally {
			if (_didIteratorError4) {
				throw _iteratorError4;
			}
		}
	}

	var _iteratorNormalCompletion5 = true;
	var _didIteratorError5 = false;
	var _iteratorError5 = undefined;

	try {
		for (var _iterator5 = extendedRtpCapabilities.headerExtensions[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
			var capExt = _step5.value;

			var ext = {
				kind: capExt.kind,
				uri: capExt.uri,
				preferredId: capExt.recvId
			};

			caps.headerExtensions.push(ext);
		}
	} catch (err) {
		_didIteratorError5 = true;
		_iteratorError5 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion5 && _iterator5.return) {
				_iterator5.return();
			}
		} finally {
			if (_didIteratorError5) {
				throw _iteratorError5;
			}
		}
	}

	caps.fecMechanisms = extendedRtpCapabilities.fecMechanisms;

	return caps;
}

/**
 * Get unsupported remote codecs.
 *
 * @param {RTCRtpCapabilities} remoteCaps - Remote capabilities.
 * @param {Array<Number>} mandatoryCodecPayloadTypes - List of codec PT values.
 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
 *
 * @return {Boolean}
 */
function getUnsupportedCodecs(remoteCaps, mandatoryCodecPayloadTypes, extendedRtpCapabilities) {
	// If not given just ignore.
	if (!Array.isArray(mandatoryCodecPayloadTypes)) return [];

	var unsupportedCodecs = [];
	var remoteCodecs = remoteCaps.codecs;
	var supportedCodecs = extendedRtpCapabilities.codecs;

	var _loop4 = function _loop4(pt) {
		if (!supportedCodecs.some(function (codec) {
			return codec.recvPayloadType === pt;
		})) {
			var unsupportedCodec = remoteCodecs.find(function (codec) {
				return codec.preferredPayloadType === pt;
			});

			if (!unsupportedCodec) throw new Error('mandatory codec PT ' + pt + ' not found in remote codecs');

			unsupportedCodecs.push(unsupportedCodec);
		}
	};

	var _iteratorNormalCompletion6 = true;
	var _didIteratorError6 = false;
	var _iteratorError6 = undefined;

	try {
		for (var _iterator6 = mandatoryCodecPayloadTypes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
			var pt = _step6.value;

			_loop4(pt);
		}
	} catch (err) {
		_didIteratorError6 = true;
		_iteratorError6 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion6 && _iterator6.return) {
				_iterator6.return();
			}
		} finally {
			if (_didIteratorError6) {
				throw _iteratorError6;
			}
		}
	}

	return unsupportedCodecs;
}

/**
 * Whether media can be sent based on the given RTP capabilities.
 *
 * @param {String} kind
 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
 *
 * @return {Boolean}
 */
function canSend(kind, extendedRtpCapabilities) {
	return extendedRtpCapabilities.codecs.some(function (codec) {
		return codec.kind === kind;
	});
}

/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 *
 * @param {RTCRtpParameters} rtpParameters
 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
 *
 * @return {Boolean}
 */
function canReceive(rtpParameters, extendedRtpCapabilities) {
	if (rtpParameters.codecs.length === 0) return false;

	var firstMediaCodec = rtpParameters.codecs[0];

	return extendedRtpCapabilities.codecs.some(function (codec) {
		return codec.recvPayloadType === firstMediaCodec.payloadType;
	});
}

/**
 * Generate RTP parameters of the given kind for sending media.
 * Just the first media codec per kind is considered.
 * NOTE: muxId, encodings and rtcp fields are left empty.
 *
 * @param {kind} kind
 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
 *
 * @return {RTCRtpParameters}
 */
function getSendingRtpParameters(kind, extendedRtpCapabilities) {
	var params = {
		muxId: null,
		codecs: [],
		headerExtensions: [],
		encodings: [],
		rtcp: {}
	};

	var _iteratorNormalCompletion7 = true;
	var _didIteratorError7 = false;
	var _iteratorError7 = undefined;

	try {
		for (var _iterator7 = extendedRtpCapabilities.codecs[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
			var capCodec = _step7.value;

			if (capCodec.kind !== kind) continue;

			var codec = {
				name: capCodec.name,
				mimeType: capCodec.mimeType,
				clockRate: capCodec.clockRate,
				payloadType: capCodec.sendPayloadType,
				channels: capCodec.channels,
				rtcpFeedback: capCodec.rtcpFeedback,
				parameters: capCodec.parameters
			};

			if (!codec.channels) delete codec.channels;

			params.codecs.push(codec);

			// Add RTX codec.
			if (capCodec.sendRtxPayloadType) {
				var rtxCodec = {
					name: 'rtx',
					mimeType: capCodec.kind + '/rtx',
					clockRate: capCodec.clockRate,
					payloadType: capCodec.sendRtxPayloadType,
					parameters: {
						apt: capCodec.sendPayloadType
					}
				};

				params.codecs.push(rtxCodec);
			}

			// NOTE: We assume a single media codec plus an optional RTX codec for now.
			// TODO: In the future, we need to add FEC, CN, etc, codecs.
			break;
		}
	} catch (err) {
		_didIteratorError7 = true;
		_iteratorError7 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion7 && _iterator7.return) {
				_iterator7.return();
			}
		} finally {
			if (_didIteratorError7) {
				throw _iteratorError7;
			}
		}
	}

	var _iteratorNormalCompletion8 = true;
	var _didIteratorError8 = false;
	var _iteratorError8 = undefined;

	try {
		for (var _iterator8 = extendedRtpCapabilities.headerExtensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
			var capExt = _step8.value;

			if (capExt.kind && capExt.kind !== kind) continue;

			var ext = {
				uri: capExt.uri,
				id: capExt.sendId
			};

			params.headerExtensions.push(ext);
		}
	} catch (err) {
		_didIteratorError8 = true;
		_iteratorError8 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion8 && _iterator8.return) {
				_iterator8.return();
			}
		} finally {
			if (_didIteratorError8) {
				throw _iteratorError8;
			}
		}
	}

	return params;
}

/**
 * Generate RTP parameters of the given kind for receiving media.
 * All the media codecs per kind are considered. This is useful for generating
 * a SDP remote offer.
 * NOTE: muxId, encodings and rtcp fields are left empty.
 *
 * @param {String} kind
 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
 *
 * @return {RTCRtpParameters}
 */
function getReceivingFullRtpParameters(kind, extendedRtpCapabilities) {
	var params = {
		muxId: null,
		codecs: [],
		headerExtensions: [],
		encodings: [],
		rtcp: {}
	};

	var _iteratorNormalCompletion9 = true;
	var _didIteratorError9 = false;
	var _iteratorError9 = undefined;

	try {
		for (var _iterator9 = extendedRtpCapabilities.codecs[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
			var capCodec = _step9.value;

			if (capCodec.kind !== kind) continue;

			var codec = {
				name: capCodec.name,
				mimeType: capCodec.mimeType,
				clockRate: capCodec.clockRate,
				payloadType: capCodec.recvPayloadType,
				channels: capCodec.channels,
				rtcpFeedback: capCodec.rtcpFeedback,
				parameters: capCodec.parameters
			};

			if (!codec.channels) delete codec.channels;

			params.codecs.push(codec);

			// Add RTX codec.
			if (capCodec.recvRtxPayloadType) {
				var rtxCodec = {
					name: 'rtx',
					mimeType: capCodec.kind + '/rtx',
					clockRate: capCodec.clockRate,
					payloadType: capCodec.recvRtxPayloadType,
					parameters: {
						apt: capCodec.recvPayloadType
					}
				};

				params.codecs.push(rtxCodec);
			}

			// TODO: In the future, we need to add FEC, CN, etc, codecs.
		}
	} catch (err) {
		_didIteratorError9 = true;
		_iteratorError9 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion9 && _iterator9.return) {
				_iterator9.return();
			}
		} finally {
			if (_didIteratorError9) {
				throw _iteratorError9;
			}
		}
	}

	var _iteratorNormalCompletion10 = true;
	var _didIteratorError10 = false;
	var _iteratorError10 = undefined;

	try {
		for (var _iterator10 = extendedRtpCapabilities.headerExtensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
			var capExt = _step10.value;

			if (capExt.kind && capExt.kind !== kind) continue;

			var ext = {
				uri: capExt.uri,
				id: capExt.recvId
			};

			params.headerExtensions.push(ext);
		}
	} catch (err) {
		_didIteratorError10 = true;
		_iteratorError10 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion10 && _iterator10.return) {
				_iterator10.return();
			}
		} finally {
			if (_didIteratorError10) {
				throw _iteratorError10;
			}
		}
	}

	return params;
}

function matchCapCodecs(aCodec, bCodec) {
	var aMimeType = aCodec.mimeType.toLowerCase();
	var bMimeType = bCodec.mimeType.toLowerCase();

	if (aMimeType !== bMimeType) return false;

	if (aCodec.clockRate !== bCodec.clockRate) return false;

	if (aCodec.channels !== bCodec.channels) return false;

	// Match H264 parameters.
	if (aMimeType === 'video/h264') {
		var aPacketizationMode = (aCodec.parameters || {})['packetization-mode'] || 0;
		var bPacketizationMode = (bCodec.parameters || {})['packetization-mode'] || 0;

		if (aPacketizationMode !== bPacketizationMode) return false;
	}

	return true;
}

function matchCapHeaderExtensions(aExt, bExt) {
	if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) return false;

	if (aExt.uri !== bExt.uri) return false;

	return true;
}

function reduceRtcpFeedback(codecA, codecB) {
	var reducedRtcpFeedback = [];

	var _loop5 = function _loop5(aFb) {
		var matchingBFb = (codecB.rtcpFeedback || []).find(function (bFb) {
			return bFb.type === aFb.type && bFb.parameter === aFb.parameter;
		});

		if (matchingBFb) reducedRtcpFeedback.push(matchingBFb);
	};

	var _iteratorNormalCompletion11 = true;
	var _didIteratorError11 = false;
	var _iteratorError11 = undefined;

	try {
		for (var _iterator11 = (codecA.rtcpFeedback || [])[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
			var aFb = _step11.value;

			_loop5(aFb);
		}
	} catch (err) {
		_didIteratorError11 = true;
		_iteratorError11 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion11 && _iterator11.return) {
				_iterator11.return();
			}
		} finally {
			if (_didIteratorError11) {
				throw _iteratorError11;
			}
		}
	}

	return reducedRtcpFeedback;
}
},{}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomNumber = randomNumber;
exports.clone = clone;

var _randomNumber = require('random-number');

var _randomNumber2 = _interopRequireDefault(_randomNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var randomNumberGenerator = _randomNumber2.default.generator({
  min: 10000000,
  max: 99999999,
  integer: true
});

/**
 * Generates a random positive number between 10000000 and 99999999.
 *
 * @return {Number}
 */
function randomNumber() {
  return randomNumberGenerator();
}

/**
 * Clones the given Object/Array.
 *
 * @param {Object|Array} obj
 *
 * @return {Object|Array}
 */
function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
},{"random-number":57}],52:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":53,"_process":74}],53:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":54}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],55:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],56:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],57:[function(require,module,exports){
void function(root){

  function defaults(options){
    var options = options || {}
    var min = options.min
    var max = options.max
    var integer = options.integer || false
    if ( min == null && max == null ) {
      min = 0
      max = 1
    } else if ( min == null ) {
      min = max - 1
    } else if ( max == null ) {
      max = min + 1
    }
    if ( max < min ) throw new Error('invalid options, max must be >= min')
    return {
      min:     min
    , max:     max
    , integer: integer
    }
  }

  function random(options){
    options = defaults(options)
    if ( options.max === options.min ) return options.min
    var r = Math.random() * (options.max - options.min + Number(!!options.integer)) + options.min
    return options.integer ? Math.floor(r) : r
  }

  function generator(options){
    options = defaults(options)
    return function(min, max, integer){
      options.min     = min != null ? min : options.min
      options.max     = max != null ? max : options.max
      options.integer = integer != null ? integer : options.integer
      return random(options)
    }
  }

  module.exports =  random
  module.exports.generator = generator
  module.exports.defaults = defaults
}(this)

},{}],58:[function(require,module,exports){
var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{ //o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  //k: [{}], // outdated thing ignored
  t: [{ //t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{ //c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{ //b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    { //a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding) ?
          'rtpmap:%d %s/%s/%s':
          o.rate ?
          'rtpmap:%d %s/%s':
          'rtpmap:%d %s';
      }
    },
    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      //a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    { //a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    { //a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null) ?
          'rtcp:%d %s IP%d %s':
          'rtcp:%d';
      }
    },
    { //a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%d trr-int %d'
    },
    { //a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null) ?
          'rtcp-fb:%s %s %s':
          'rtcp-fb:%s %s';
      }
    },
    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      //a=extmap:1/recvonly URI-gps-string
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'uri', 'config'],
      format: function (o) {
        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');
      }
    },
    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null) ?
          'crypto:%d %s %s %s':
          'crypto:%d %s %s';
      }
    },
    { //a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    { //a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    { //a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*)/,
      format: 'ptime:%d'
    },
    { //a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*)/,
      format: 'maxptime:%d'
    },
    { //a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    { //a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    { //a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    { //a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    { //a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    { //a=ssrc-group:FEC 1 2
      //a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    { //a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    { //a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    { //a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    { //a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null) ?
          'sctpmap:%s %s %s' :
          'sctpmap:%s %s';
      }
    },
    { //a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      //a=imageattr:* send [x=800,y=640] recv *
      //a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        //a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        //recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      //a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        //a=simulcast:
        '^simulcast:' +
        //send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        //space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        //end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    { //Old simulcast draft 03 (implemented by Firefox)
      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      //a=simulcast: recv pt=97;98 send pt=97
      //a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      //a=framerate:25
      //a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    { // any a= that we don't understand is kepts verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});

},{}],59:[function(require,module,exports){
var parser = require('./parser');
var writer = require('./writer');

exports.write = writer;
exports.parse = parser.parse;
exports.parseFmtpConfig = parser.parseFmtpConfig;
exports.parseParams = parser.parseParams;
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;

},{"./parser":60,"./writer":61}],60:[function(require,module,exports){
var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/\;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};

},{"./grammar":58}],61:[function(require,module,exports){
var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":58}],62:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":63,"./socket":65,"./url":66,"debug":11,"socket.io-parser":68}],63:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":64,"./socket":65,"backo2":4,"component-bind":8,"component-emitter":9,"debug":11,"engine.io-client":13,"indexof":27,"socket.io-parser":68}],64:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

},{}],65:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = { type: parser.EVENT, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  if (packet.nsp !== this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":64,"component-bind":8,"component-emitter":9,"debug":11,"parseqs":55,"socket.io-parser":68,"to-array":70}],66:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"debug":11,"parseuri":56}],67:[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');
var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./is-buffer":69,"isarray":28}],68:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var Emitter = require('component-emitter');
var hasBin = require('has-binary2');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  if ((obj.type === exports.EVENT || obj.type === exports.ACK) && hasBin(obj.data)) {
    obj.type = obj.type === exports.EVENT ? exports.BINARY_EVENT : exports.BINARY_ACK;
  }

  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    str += JSON.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    p = tryParse(p, str.substr(i));
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(p, str) {
  try {
    p.data = JSON.parse(str);
  } catch(e){
    return error();
  }
  return p; 
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error() {
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":67,"./is-buffer":69,"component-emitter":9,"debug":11,"has-binary2":25}],69:[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],70:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],71:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],72:[function(require,module,exports){

},{}],73:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],74:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ib3dzZXIvc3JjL2Jvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWItZXM1L0NvbW1hbmRRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvQ29uc3VtZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWItZXM1L0RldmljZS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvRW5oYW5jZWRFdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWItZXM1L0xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvUGVlci5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvUHJvZHVjZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWItZXM1L1Jvb20uanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWItZXM1L1RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliLWVzNS9oYW5kbGVycy9DaHJvbWU1NS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvaGFuZGxlcnMvRWRnZTExLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliLWVzNS9oYW5kbGVycy9GaXJlZm94NTAuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWItZXM1L2hhbmRsZXJzL1NhZmFyaTExLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliLWVzNS9oYW5kbGVycy9vcnRjL2VkZ2VVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvaGFuZGxlcnMvc2RwL1JlbW90ZVBsYW5CU2RwLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliLWVzNS9oYW5kbGVycy9zZHAvUmVtb3RlVW5pZmllZFBsYW5TZHAuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWItZXM1L2hhbmRsZXJzL3NkcC9jb21tb25VdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvaGFuZGxlcnMvc2RwL3BsYW5CVXRpbHMuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWItZXM1L2hhbmRsZXJzL3NkcC91bmlmaWVkUGxhblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliLWVzNS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvb3J0Yy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi1lczUvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlcXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLW51bWJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi9ncmFtbWFyLmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi93cml0ZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMveWVhc3QvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwiLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIuLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdnVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNubkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzduQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2prQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3AwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlvID0gcmVxdWlyZSgnc29ja2V0LmlvLWNsaWVudCcpXG5jb25zdCBtZWRpYXNvdXBDbGllbnQgPSByZXF1aXJlKCdtZWRpYXNvdXAtY2xpZW50JylcblxuY29uc3Qgc29ja2V0ID0gaW8oJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcpXG5jb25zdCBtZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpXG5sZXQgcmVjZWl2ZVRyYW5zcG9ydFxubGV0IHNlbmRUcmFuc3BvcnRcblxuc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIScpXG59KVxuXG5zb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICBjb25zb2xlLmxvZyhlcnJvcilcbn0pXG5cbmNvbnN0IGNyZWF0ZVJvb20gPSAoKSA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgcmVxdWVzdFRpbWVvdXQ6IDEwMDAwLFxuICAgIHRyYW5zcG9ydE9wdGlvbnM6IHtcbiAgICAgIHRjcDogZmFsc2VcbiAgICB9XG4gIH1cblxuICBjb25zdCByb29tID0gbmV3IG1lZGlhc291cENsaWVudC5Sb29tKG9wdGlvbnMpXG5cbiAgcm9vbS5vbignbmV3cGVlcicsIGhhbmRsZU5ld1BlZXIpXG4gIHJvb20ub24oJ25vdGlmeScsIGhhbmRsZU5vdGlmeSlcbiAgcm9vbS5vbigncmVxdWVzdCcsIGRpc3BhdGNoUmVxdWVzdClcbiAgcm9vbS5vbignZXJyb3InLCBoYW5kbGVSb29tRXJyb3IpXG4gIHJldHVybiByb29tXG59XG5cbmNvbnN0IGpvaW5Sb29tID0gKCkgPT4ge1xuICBjb25zdCByb29tID0gY3JlYXRlUm9vbSgpXG4gIGNvbnN0IHVzZXJuYW1lID0gZG9jdW1uZXQucXVlcnlFbGVtZW50QnlJZCgndXNlcm5hbWUnKS52YWx1ZVxuICBjb25zb2xlLmxvZyhgSm9pbmluZyByb29tIGFzICR7dXNlcm5hbWV9IWApXG4gIHJvb20uam9pbih1c2VybmFtZSkudGhlbihwZWVycyA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIHNlbmQgYW5kIHJlY2VpdmUgdHJhbnNwb3J0cyEnKVxuICAgIHJlY2VpdmVUcmFuc3BvcnQgPSByb29tLmNyZWF0ZVRyYW5zcG9ydCgncmVjdicpXG4gICAgc2VuZFRyYW5zcG9ydCA9IHJvb20uY3JlYXRlVHJhbnNwb3J0KCdzZW5kJylcbiAgICBzdGFydE1pY3JvcGhvbmUocm9vbSlcbiAgICBwZWVycy5mb3JFYWNoKGhhbmRsZU5ld1BlZXIpXG4gIH0pXG59XG5cbmNvbnN0IGpvaW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnam9pbicpXG5qb2luQnV0dG9uLm9uQ2xpY2sgPSBqb2luUm9vbVxuXG5jb25zdCBoYW5kbGVOZXdQZWVyID0gcGVlciA9PiB7XG4gIGNvbnNvbGUubG9nKGBQZWVyICR7cGVlci5uYW1lfSBqb2luZWQgdGhlIHJvb20hYClcbiAgcGVlci5jb25zdW1lcnMuZm9yRWFjaChoYW5kbGVDb25zdW1lcilcbiAgcGVlci5vbignbmV3Y29uc3VtZXInLCBoYW5kbGVDb25zdW1lcilcbn1cblxuY29uc3QgaGFuZGxlQ29uc3VtZXIgPSBjb25zdW1lciA9PiB7XG4gIGNvbnNvbGUubG9nKGBBZGRpbmcgbmV3IGNvbnN1bWVyIGZvciBwZWVyICR7Y29uc3VtZXIucGVlci5uYW1lfSFgKVxuICBjb25zdW1lci5yZWNlaXZlKHJlY2VpdmVUcmFuc3BvcnQpLnRoZW4odHJhY2sgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdUcmFjayBlbmFibGVkIScpXG4gICAgbWVkaWFTdHJlYW0uYWRkVHJhY2sodHJhY2spXG5cbiAgICBjb25zdCBjb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpXG4gICAgY29uc3Qgc291cmNlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShtZWRpYVN0cmVhbSlcbiAgICBjb25zdCBwcm9jZXNzb3IgPSBjb250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcigxMDI0LCAxLCAxKVxuXG4gICAgbGV0IGNvdW50ID0gMFxuICAgIHNvdXJjZS5jb25uZWN0KHByb2Nlc3NvcilcbiAgICBwcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSBldmVudCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnZXZlbnQhJylcbiAgICAgIC8vICAgaWYgKGNvdW50ICUgMTAwID09PSAwKSB7XG4gICAgICAvLyAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDApXG4gICAgICAvLyAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgIC8vICAgfVxuICAgICAgLy8gICBjb3VudCArPSAxXG4gICAgfVxuICB9KVxufVxuXG5jb25zdCBoYW5kbGVOb3RpZnkgPSBub3RpZmljYXRpb24gPT4ge1xuICBjb25zb2xlLmxvZygnaGFuZGxlTm90aWZ5JylcbiAgZmF0YWwoJ05vdCBpbXBsZW1lbnRlZCcpXG59XG5cbmNvbnN0IGhhbmRsZVJvb21FcnJvciA9IGVycm9yID0+IHtcbiAgY29uc29sZS5sb2coJ1Jvb20gRXJyb3IhJywgZXJyb3IpXG59XG5cbmNvbnN0IHN0YXJ0TWljcm9waG9uZSA9IHJvb20gPT4ge1xuICBjb25zb2xlLmxvZygnU3RhcnRpbmcgbWljcm9waG9uZS4uLicpXG4gIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUsIHZpZGVvOiBmYWxzZSB9KVxuICAgIC50aGVuKHN0cmVhbSA9PiB7XG4gICAgICBjb25zdCBhdWRpbyA9IHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdXG4gICAgICBjb25zdCBwcm9kdWNlciA9IHJvb20uY3JlYXRlUHJvZHVjZXIoYXVkaW8pXG4gICAgICBwcm9kdWNlci5zZW5kKHNlbmRUcmFuc3BvcnQpXG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyBhdWRpbyEnKVxuICAgIH0pXG4gICAgLmNhdGNoKGhhbmRsZVJvb21FcnJvcilcbn1cblxuY29uc3QgZGlzcGF0Y2hSZXF1ZXN0ID0gKHJlcXVlc3QsIGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gIHNvY2tldC5vbignbWVzc2FnZScsIG1lc3NhZ2UgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBSZWNlaXZlZCByZXNwb25zZSB0byAke3JlcXVlc3QubWV0aG9kfSByZXF1ZXN0YClcbiAgICBpZiAobWVzc2FnZS50eXBlID09PSAnbWVkaWFzb3VwLXJlc3BvbnNlJykge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBtZXNzYWdlLmJvZHlcbiAgICAgIGFjY2VwdChyZXNwb25zZSlcbiAgICAgIGNvbnNvbGUubG9nKCdBY2NlcHRlZCByZXNwb25zZSBmcm9tIHNlcnZlciEnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vua25vd24gbWVzc2FnZSB0eXBlIScpXG4gICAgfVxuICB9KVxuXG4gIGNvbnNvbGUubG9nKGBEaXNwYXRjaGluZyAke3JlcXVlc3QubWV0aG9kfSByZXF1ZXN0YClcbiAgc29ja2V0LnNlbmQoeyB0eXBlOiAnbWVkaWFzb3VwLXJlcXVlc3QnLCBib2R5OiByZXF1ZXN0IH0pXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG4iLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cbiIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbigpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcblxuICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gIHZhciBsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzEpXTtcbiAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMildO1xuICAgICAgZW5jb2RlZDQgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSszKV07XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoKTtcbiIsIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuIiwiLyohXG4gKiBCb3dzZXIgLSBhIGJyb3dzZXIgZGV0ZWN0b3JcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm93c2VyXG4gKiBNSVQgTGljZW5zZSB8IChjKSBEdXN0aW4gRGlheiAyMDE1XG4gKi9cblxuIWZ1bmN0aW9uIChyb290LCBuYW1lLCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKG5hbWUsIGRlZmluaXRpb24pXG4gIGVsc2Ugcm9vdFtuYW1lXSA9IGRlZmluaXRpb24oKVxufSh0aGlzLCAnYm93c2VyJywgZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICAqIFNlZSB1c2VyYWdlbnRzLmpzIGZvciBleGFtcGxlcyBvZiBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgKi9cblxuICB2YXIgdCA9IHRydWVcblxuICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcblxuICAgIGZ1bmN0aW9uIGdldEZpcnN0TWF0Y2gocmVnZXgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKHJlZ2V4KTtcbiAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsxXSkgfHwgJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2Vjb25kTWF0Y2gocmVnZXgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKHJlZ2V4KTtcbiAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsyXSkgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGlvc2RldmljZSA9IGdldEZpcnN0TWF0Y2goLyhpcG9kfGlwaG9uZXxpcGFkKS9pKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGxpa2VBbmRyb2lkID0gL2xpa2UgYW5kcm9pZC9pLnRlc3QodWEpXG4gICAgICAsIGFuZHJvaWQgPSAhbGlrZUFuZHJvaWQgJiYgL2FuZHJvaWQvaS50ZXN0KHVhKVxuICAgICAgLCBuZXh1c01vYmlsZSA9IC9uZXh1c1xccypbMC02XVxccyovaS50ZXN0KHVhKVxuICAgICAgLCBuZXh1c1RhYmxldCA9ICFuZXh1c01vYmlsZSAmJiAvbmV4dXNcXHMqWzAtOV0rL2kudGVzdCh1YSlcbiAgICAgICwgY2hyb21lb3MgPSAvQ3JPUy8udGVzdCh1YSlcbiAgICAgICwgc2lsayA9IC9zaWxrL2kudGVzdCh1YSlcbiAgICAgICwgc2FpbGZpc2ggPSAvc2FpbGZpc2gvaS50ZXN0KHVhKVxuICAgICAgLCB0aXplbiA9IC90aXplbi9pLnRlc3QodWEpXG4gICAgICAsIHdlYm9zID0gLyh3ZWJ8aHB3KW9zL2kudGVzdCh1YSlcbiAgICAgICwgd2luZG93c3Bob25lID0gL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKVxuICAgICAgLCBzYW1zdW5nQnJvd3NlciA9IC9TYW1zdW5nQnJvd3Nlci9pLnRlc3QodWEpXG4gICAgICAsIHdpbmRvd3MgPSAhd2luZG93c3Bob25lICYmIC93aW5kb3dzL2kudGVzdCh1YSlcbiAgICAgICwgbWFjID0gIWlvc2RldmljZSAmJiAhc2lsayAmJiAvbWFjaW50b3NoL2kudGVzdCh1YSlcbiAgICAgICwgbGludXggPSAhYW5kcm9pZCAmJiAhc2FpbGZpc2ggJiYgIXRpemVuICYmICF3ZWJvcyAmJiAvbGludXgvaS50ZXN0KHVhKVxuICAgICAgLCBlZGdlVmVyc2lvbiA9IGdldFNlY29uZE1hdGNoKC9lZGcoW2VhXXxpb3MpXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgLCB2ZXJzaW9uSWRlbnRpZmllciA9IGdldEZpcnN0TWF0Y2goL3ZlcnNpb25cXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICAsIHRhYmxldCA9IC90YWJsZXQvaS50ZXN0KHVhKSAmJiAhL3RhYmxldCBwYy9pLnRlc3QodWEpXG4gICAgICAsIG1vYmlsZSA9ICF0YWJsZXQgJiYgL1teLV1tb2JpL2kudGVzdCh1YSlcbiAgICAgICwgeGJveCA9IC94Ym94L2kudGVzdCh1YSlcbiAgICAgICwgcmVzdWx0XG5cbiAgICBpZiAoL29wZXJhL2kudGVzdCh1YSkpIHtcbiAgICAgIC8vICBhbiBvbGQgT3BlcmFcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ09wZXJhJ1xuICAgICAgLCBvcGVyYTogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzpvcGVyYXxvcHJ8b3Bpb3MpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvb3ByXFwvfG9waW9zL2kudGVzdCh1YSkpIHtcbiAgICAgIC8vIGEgbmV3IE9wZXJhXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdPcGVyYSdcbiAgICAgICAgLCBvcGVyYTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om9wcnxvcGlvcylbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL1NhbXN1bmdCcm93c2VyL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWQnXG4gICAgICAgICwgc2Ftc3VuZ0Jyb3dzZXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzpTYW1zdW5nQnJvd3NlcilbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2NvYXN0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ09wZXJhIENvYXN0J1xuICAgICAgICAsIGNvYXN0OiB0XG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86Y29hc3QpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC95YWJyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnWWFuZGV4IEJyb3dzZXInXG4gICAgICAsIHlhbmRleGJyb3dzZXI6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86eWFicm93c2VyKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvdWNicm93c2VyL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBuYW1lOiAnVUMgQnJvd3NlcidcbiAgICAgICAgLCB1Y2Jyb3dzZXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzp1Y2Jyb3dzZXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL214aW9zL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ01heHRob24nXG4gICAgICAgICwgbWF4dGhvbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om14aW9zKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9lcGlwaGFueS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdFcGlwaGFueSdcbiAgICAgICAgLCBlcGlwaGFueTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmVwaXBoYW55KVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9wdWZmaW4vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUHVmZmluJ1xuICAgICAgICAsIHB1ZmZpbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnB1ZmZpbilbXFxzXFwvXShcXGQrKD86XFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2xlaXBuaXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2xlaXBuaXInXG4gICAgICAgICwgc2xlaXBuaXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpzbGVpcG5pcilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvay1tZWxlb24vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnSy1NZWxlb24nXG4gICAgICAgICwga01lbGVvbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmstbWVsZW9uKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvd3NwaG9uZSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnV2luZG93cyBQaG9uZSdcbiAgICAgICwgb3NuYW1lOiAnV2luZG93cyBQaG9uZSdcbiAgICAgICwgd2luZG93c3Bob25lOiB0XG4gICAgICB9XG4gICAgICBpZiAoZWRnZVZlcnNpb24pIHtcbiAgICAgICAgcmVzdWx0Lm1zZWRnZSA9IHRcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBlZGdlVmVyc2lvblxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5tc2llID0gdFxuICAgICAgICByZXN1bHQudmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2llbW9iaWxlXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvbXNpZXx0cmlkZW50L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0ludGVybmV0IEV4cGxvcmVyJ1xuICAgICAgLCBtc2llOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om1zaWUgfHJ2OikoXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaHJvbWVvcykge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21lJ1xuICAgICAgLCBvc25hbWU6ICdDaHJvbWUgT1MnXG4gICAgICAsIGNocm9tZW9zOiB0XG4gICAgICAsIGNocm9tZUJvb2s6IHRcbiAgICAgICwgY2hyb21lOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9lZGcoW2VhXXxpb3MpL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ01pY3Jvc29mdCBFZGdlJ1xuICAgICAgLCBtc2VkZ2U6IHRcbiAgICAgICwgdmVyc2lvbjogZWRnZVZlcnNpb25cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3ZpdmFsZGkvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnVml2YWxkaSdcbiAgICAgICAgLCB2aXZhbGRpOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvdml2YWxkaVxcLyhcXGQrKFxcLlxcZCspPykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2FpbGZpc2gpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NhaWxmaXNoJ1xuICAgICAgLCBvc25hbWU6ICdTYWlsZmlzaCBPUydcbiAgICAgICwgc2FpbGZpc2g6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXHM/YnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NlYW1vbmtleVxcLy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTZWFNb25rZXknXG4gICAgICAsIHNlYW1vbmtleTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zZWFtb25rZXlcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9maXJlZm94fGljZXdlYXNlbHxmeGlvcy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdGaXJlZm94J1xuICAgICAgLCBmaXJlZm94OiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVsgXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICAgIGlmICgvXFwoKG1vYmlsZXx0YWJsZXQpO1teXFwpXSpydjpbXFxkXFwuXStcXCkvaS50ZXN0KHVhKSkge1xuICAgICAgICByZXN1bHQuZmlyZWZveG9zID0gdFxuICAgICAgICByZXN1bHQub3NuYW1lID0gJ0ZpcmVmb3ggT1MnXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpbGspIHtcbiAgICAgIHJlc3VsdCA9ICB7XG4gICAgICAgIG5hbWU6ICdBbWF6b24gU2lsaydcbiAgICAgICwgc2lsazogdFxuICAgICAgLCB2ZXJzaW9uIDogZ2V0Rmlyc3RNYXRjaCgvc2lsa1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3BoYW50b20vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUGhhbnRvbUpTJ1xuICAgICAgLCBwaGFudG9tOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3BoYW50b21qc1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NsaW1lcmpzL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NsaW1lckpTJ1xuICAgICAgICAsIHNsaW1lcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3NsaW1lcmpzXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaS50ZXN0KHVhKSB8fCAvcmltXFxzdGFibGV0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0JsYWNrQmVycnknXG4gICAgICAsIG9zbmFtZTogJ0JsYWNrQmVycnkgT1MnXG4gICAgICAsIGJsYWNrYmVycnk6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVtcXGRdK1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2Vib3MpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1dlYk9TJ1xuICAgICAgLCBvc25hbWU6ICdXZWJPUydcbiAgICAgICwgd2Vib3M6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9vc2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9O1xuICAgICAgL3RvdWNocGFkXFwvL2kudGVzdCh1YSkgJiYgKHJlc3VsdC50b3VjaHBhZCA9IHQpXG4gICAgfVxuICAgIGVsc2UgaWYgKC9iYWRhL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0JhZGEnXG4gICAgICAsIG9zbmFtZTogJ0JhZGEnXG4gICAgICAsIGJhZGE6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGl6ZW4pIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1RpemVuJ1xuICAgICAgLCBvc25hbWU6ICdUaXplbidcbiAgICAgICwgdGl6ZW46IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86dGl6ZW5cXHM/KT9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL3F1cHppbGxhL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1F1cFppbGxhJ1xuICAgICAgICAsIHF1cHppbGxhOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86cXVwemlsbGEpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2Nocm9taXVtL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0Nocm9taXVtJ1xuICAgICAgICAsIGNocm9taXVtOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21pdW0pW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspPykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2Nocm9tZXxjcmlvc3xjcm1vL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0Nocm9tZSdcbiAgICAgICAgLCBjaHJvbWU6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFuZHJvaWQpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0FuZHJvaWQnXG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NhZmFyaXxhcHBsZXdlYmtpdC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTYWZhcmknXG4gICAgICAsIHNhZmFyaTogdFxuICAgICAgfVxuICAgICAgaWYgKHZlcnNpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW9zZGV2aWNlKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWUgOiBpb3NkZXZpY2UgPT0gJ2lwaG9uZScgPyAnaVBob25lJyA6IGlvc2RldmljZSA9PSAnaXBhZCcgPyAnaVBhZCcgOiAnaVBvZCdcbiAgICAgIH1cbiAgICAgIC8vIFdURjogdmVyc2lvbiBpcyBub3QgcGFydCBvZiB1c2VyIGFnZW50IGluIHdlYiBhcHBzXG4gICAgICBpZiAodmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmKC9nb29nbGVib3QvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnR29vZ2xlYm90J1xuICAgICAgLCBnb29nbGVib3Q6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZ29vZ2xlYm90XFwvKFxcZCsoXFwuXFxkKykpL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiBnZXRGaXJzdE1hdGNoKC9eKC4qKVxcLyguKikgLyksXG4gICAgICAgIHZlcnNpb246IGdldFNlY29uZE1hdGNoKC9eKC4qKVxcLyguKikgLylcbiAgICAgfTtcbiAgIH1cblxuICAgIC8vIHNldCB3ZWJraXQgb3IgZ2Vja28gZmxhZyBmb3IgYnJvd3NlcnMgYmFzZWQgb24gdGhlc2UgZW5naW5lc1xuICAgIGlmICghcmVzdWx0Lm1zZWRnZSAmJiAvKGFwcGxlKT93ZWJraXQvaS50ZXN0KHVhKSkge1xuICAgICAgaWYgKC8oYXBwbGUpP3dlYmtpdFxcLzUzN1xcLjM2L2kudGVzdCh1YSkpIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIkJsaW5rXCJcbiAgICAgICAgcmVzdWx0LmJsaW5rID0gdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIldlYmtpdFwiXG4gICAgICAgIHJlc3VsdC53ZWJraXQgPSB0XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3VsdC52ZXJzaW9uICYmIHZlcnNpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFyZXN1bHQub3BlcmEgJiYgL2dlY2tvXFwvL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUgfHwgXCJHZWNrb1wiXG4gICAgICByZXN1bHQuZ2Vja28gPSB0XG4gICAgICByZXN1bHQudmVyc2lvbiA9IHJlc3VsdC52ZXJzaW9uIHx8IGdldEZpcnN0TWF0Y2goL2dlY2tvXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgIH1cblxuICAgIC8vIHNldCBPUyBmbGFncyBmb3IgcGxhdGZvcm1zIHRoYXQgaGF2ZSBtdWx0aXBsZSBicm93c2Vyc1xuICAgIGlmICghcmVzdWx0LndpbmRvd3NwaG9uZSAmJiAoYW5kcm9pZCB8fCByZXN1bHQuc2lsaykpIHtcbiAgICAgIHJlc3VsdC5hbmRyb2lkID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdBbmRyb2lkJ1xuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC53aW5kb3dzcGhvbmUgJiYgaW9zZGV2aWNlKSB7XG4gICAgICByZXN1bHRbaW9zZGV2aWNlXSA9IHRcbiAgICAgIHJlc3VsdC5pb3MgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ2lPUydcbiAgICB9IGVsc2UgaWYgKG1hYykge1xuICAgICAgcmVzdWx0Lm1hYyA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnbWFjT1MnXG4gICAgfSBlbHNlIGlmICh4Ym94KSB7XG4gICAgICByZXN1bHQueGJveCA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnWGJveCdcbiAgICB9IGVsc2UgaWYgKHdpbmRvd3MpIHtcbiAgICAgIHJlc3VsdC53aW5kb3dzID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdXaW5kb3dzJ1xuICAgIH0gZWxzZSBpZiAobGludXgpIHtcbiAgICAgIHJlc3VsdC5saW51eCA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnTGludXgnXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93c1ZlcnNpb24gKHMpIHtcbiAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlICdOVCc6IHJldHVybiAnTlQnXG4gICAgICAgIGNhc2UgJ1hQJzogcmV0dXJuICdYUCdcbiAgICAgICAgY2FzZSAnTlQgNS4wJzogcmV0dXJuICcyMDAwJ1xuICAgICAgICBjYXNlICdOVCA1LjEnOiByZXR1cm4gJ1hQJ1xuICAgICAgICBjYXNlICdOVCA1LjInOiByZXR1cm4gJzIwMDMnXG4gICAgICAgIGNhc2UgJ05UIDYuMCc6IHJldHVybiAnVmlzdGEnXG4gICAgICAgIGNhc2UgJ05UIDYuMSc6IHJldHVybiAnNydcbiAgICAgICAgY2FzZSAnTlQgNi4yJzogcmV0dXJuICc4J1xuICAgICAgICBjYXNlICdOVCA2LjMnOiByZXR1cm4gJzguMSdcbiAgICAgICAgY2FzZSAnTlQgMTAuMCc6IHJldHVybiAnMTAnXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPUyB2ZXJzaW9uIGV4dHJhY3Rpb25cbiAgICB2YXIgb3NWZXJzaW9uID0gJyc7XG4gICAgaWYgKHJlc3VsdC53aW5kb3dzKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRXaW5kb3dzVmVyc2lvbihnZXRGaXJzdE1hdGNoKC9XaW5kb3dzICgoTlR8WFApKCBcXGRcXGQ/LlxcZCk/KS9pKSlcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC53aW5kb3dzcGhvbmUpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3dpbmRvd3MgcGhvbmUgKD86b3MpP1xccz8oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0Lm1hYykge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvTWFjIE9TIFggKFxcZCsoW19cXC5cXHNdXFxkKykqKS9pKTtcbiAgICAgIG9zVmVyc2lvbiA9IG9zVmVyc2lvbi5yZXBsYWNlKC9bX1xcc10vZywgJy4nKTtcbiAgICB9IGVsc2UgaWYgKGlvc2RldmljZSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvb3MgKFxcZCsoW19cXHNdXFxkKykqKSBsaWtlIG1hYyBvcyB4L2kpO1xuICAgICAgb3NWZXJzaW9uID0gb3NWZXJzaW9uLnJlcGxhY2UoL1tfXFxzXS9nLCAnLicpO1xuICAgIH0gZWxzZSBpZiAoYW5kcm9pZCkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFsgXFwvLV0oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LndlYm9zKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC8oPzp3ZWJ8aHB3KW9zXFwvKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5ibGFja2JlcnJ5KSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9yaW1cXHN0YWJsZXRcXHNvc1xccyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuYmFkYSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYmFkYVxcLyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQudGl6ZW4pIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3RpemVuW1xcL1xcc10oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH1cbiAgICBpZiAob3NWZXJzaW9uKSB7XG4gICAgICByZXN1bHQub3N2ZXJzaW9uID0gb3NWZXJzaW9uO1xuICAgIH1cblxuICAgIC8vIGRldmljZSB0eXBlIGV4dHJhY3Rpb25cbiAgICB2YXIgb3NNYWpvclZlcnNpb24gPSAhcmVzdWx0LndpbmRvd3MgJiYgb3NWZXJzaW9uLnNwbGl0KCcuJylbMF07XG4gICAgaWYgKFxuICAgICAgICAgdGFibGV0XG4gICAgICB8fCBuZXh1c1RhYmxldFxuICAgICAgfHwgaW9zZGV2aWNlID09ICdpcGFkJ1xuICAgICAgfHwgKGFuZHJvaWQgJiYgKG9zTWFqb3JWZXJzaW9uID09IDMgfHwgKG9zTWFqb3JWZXJzaW9uID49IDQgJiYgIW1vYmlsZSkpKVxuICAgICAgfHwgcmVzdWx0LnNpbGtcbiAgICApIHtcbiAgICAgIHJlc3VsdC50YWJsZXQgPSB0XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgIG1vYmlsZVxuICAgICAgfHwgaW9zZGV2aWNlID09ICdpcGhvbmUnXG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwb2QnXG4gICAgICB8fCBhbmRyb2lkXG4gICAgICB8fCBuZXh1c01vYmlsZVxuICAgICAgfHwgcmVzdWx0LmJsYWNrYmVycnlcbiAgICAgIHx8IHJlc3VsdC53ZWJvc1xuICAgICAgfHwgcmVzdWx0LmJhZGFcbiAgICApIHtcbiAgICAgIHJlc3VsdC5tb2JpbGUgPSB0XG4gICAgfVxuXG4gICAgLy8gR3JhZGVkIEJyb3dzZXIgU3VwcG9ydFxuICAgIC8vIGh0dHA6Ly9kZXZlbG9wZXIueWFob28uY29tL3l1aS9hcnRpY2xlcy9nYnNcbiAgICBpZiAocmVzdWx0Lm1zZWRnZSB8fFxuICAgICAgICAocmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTApIHx8XG4gICAgICAgIChyZXN1bHQueWFuZGV4YnJvd3NlciAmJiByZXN1bHQudmVyc2lvbiA+PSAxNSkgfHxcblx0XHQgICAgKHJlc3VsdC52aXZhbGRpICYmIHJlc3VsdC52ZXJzaW9uID49IDEuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPj0gMjApIHx8XG4gICAgICAgIChyZXN1bHQuc2Ftc3VuZ0Jyb3dzZXIgJiYgcmVzdWx0LnZlcnNpb24gPj0gNCkgfHxcbiAgICAgICAgKHJlc3VsdC5maXJlZm94ICYmIHJlc3VsdC52ZXJzaW9uID49IDIwLjApIHx8XG4gICAgICAgIChyZXN1bHQuc2FmYXJpICYmIHJlc3VsdC52ZXJzaW9uID49IDYpIHx8XG4gICAgICAgIChyZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5pb3MgJiYgcmVzdWx0Lm9zdmVyc2lvbiAmJiByZXN1bHQub3N2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA+PSA2KSB8fFxuICAgICAgICAocmVzdWx0LmJsYWNrYmVycnkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMSlcbiAgICAgICAgfHwgKHJlc3VsdC5jaHJvbWl1bSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMClcbiAgICAgICAgKSB7XG4gICAgICByZXN1bHQuYSA9IHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA8IDEwKSB8fFxuICAgICAgICAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA8IDIwKSB8fFxuICAgICAgICAocmVzdWx0LmZpcmVmb3ggJiYgcmVzdWx0LnZlcnNpb24gPCAyMC4wKSB8fFxuICAgICAgICAocmVzdWx0LnNhZmFyaSAmJiByZXN1bHQudmVyc2lvbiA8IDYpIHx8XG4gICAgICAgIChyZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPCAxMC4wKSB8fFxuICAgICAgICAocmVzdWx0LmlvcyAmJiByZXN1bHQub3N2ZXJzaW9uICYmIHJlc3VsdC5vc3ZlcnNpb24uc3BsaXQoXCIuXCIpWzBdIDwgNilcbiAgICAgICAgfHwgKHJlc3VsdC5jaHJvbWl1bSAmJiByZXN1bHQudmVyc2lvbiA8IDIwKVxuICAgICAgICApIHtcbiAgICAgIHJlc3VsdC5jID0gdFxuICAgIH0gZWxzZSByZXN1bHQueCA9IHRcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHZhciBib3dzZXIgPSBkZXRlY3QodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnIDogJycpXG5cbiAgYm93c2VyLnRlc3QgPSBmdW5jdGlvbiAoYnJvd3Nlckxpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyb3dzZXJMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYnJvd3Nlckl0ZW0gPSBicm93c2VyTGlzdFtpXTtcbiAgICAgIGlmICh0eXBlb2YgYnJvd3Nlckl0ZW09PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGJyb3dzZXJJdGVtIGluIGJvd3Nlcikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdmVyc2lvbiBwcmVjaXNpb25zIGNvdW50XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgZ2V0VmVyc2lvblByZWNpc2lvbihcIjEuMTAuM1wiKSAvLyAzXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmVyc2lvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gdmVyc2lvbi5zcGxpdChcIi5cIikubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEFycmF5OjptYXAgcG9seWZpbGxcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBtYXAoYXJyLCBpdGVyYXRvcikge1xuICAgIHZhciByZXN1bHQgPSBbXSwgaTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLm1hcCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcnIsIGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goaXRlcmF0b3IoYXJyW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJyb3dzZXIgdmVyc2lvbiB3ZWlnaHRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS44LjIuMS45MCddKSAgICAvLyAxXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4wMTAuMi4xJywgJzEuMDkuMi4xLjkwJ10pOyAgLy8gMVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMTAuMi4xJywgICcxLjEwLjIuMSddKTsgICAgIC8vIDBcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS4wODAwLjInXSk7ICAgICAvLyAtMVxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheTxTdHJpbmc+fSB2ZXJzaW9ucyB2ZXJzaW9ucyB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge051bWJlcn0gY29tcGFyaXNvbiByZXN1bHRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2ZXJzaW9ucykge1xuICAgIC8vIDEpIGdldCBjb21tb24gcHJlY2lzaW9uIGZvciBib3RoIHZlcnNpb25zLCBmb3IgZXhhbXBsZSBmb3IgXCIxMC4wXCIgYW5kIFwiOVwiIGl0IHNob3VsZCBiZSAyXG4gICAgdmFyIHByZWNpc2lvbiA9IE1hdGgubWF4KGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbnNbMF0pLCBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb25zWzFdKSk7XG4gICAgdmFyIGNodW5rcyA9IG1hcCh2ZXJzaW9ucywgZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgIHZhciBkZWx0YSA9IHByZWNpc2lvbiAtIGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbik7XG5cbiAgICAgIC8vIDIpIFwiOVwiIC0+IFwiOS4wXCIgKGZvciBwcmVjaXNpb24gPSAyKVxuICAgICAgdmVyc2lvbiA9IHZlcnNpb24gKyBuZXcgQXJyYXkoZGVsdGEgKyAxKS5qb2luKFwiLjBcIik7XG5cbiAgICAgIC8vIDMpIFwiOS4wXCIgLT4gW1wiMDAwMDAwMDAwXCJcIiwgXCIwMDAwMDAwMDlcIl1cbiAgICAgIHJldHVybiBtYXAodmVyc2lvbi5zcGxpdChcIi5cIiksIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KDIwIC0gY2h1bmsubGVuZ3RoKS5qb2luKFwiMFwiKSArIGNodW5rO1xuICAgICAgfSkucmV2ZXJzZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gaXRlcmF0ZSBpbiByZXZlcnNlIG9yZGVyIGJ5IHJldmVyc2VkIGNodW5rcyBhcnJheVxuICAgIHdoaWxlICgtLXByZWNpc2lvbiA+PSAwKSB7XG4gICAgICAvLyA0KSBjb21wYXJlOiBcIjAwMDAwMDAwOVwiID4gXCIwMDAwMDAwMTBcIiA9IGZhbHNlIChidXQgXCI5XCIgPiBcIjEwXCIgPSB0cnVlKVxuICAgICAgaWYgKGNodW5rc1swXVtwcmVjaXNpb25dID4gY2h1bmtzWzFdW3ByZWNpc2lvbl0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjaHVua3NbMF1bcHJlY2lzaW9uXSA9PT0gY2h1bmtzWzFdW3ByZWNpc2lvbl0pIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICAgIC8vIGFsbCB2ZXJzaW9uIGNodW5rcyBhcmUgc2FtZVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBicm93c2VyIGlzIHVuc3VwcG9ydGVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgYm93c2VyLmlzVW5zdXBwb3J0ZWRCcm93c2VyKHtcbiAgICogICAgIG1zaWU6IFwiMTBcIixcbiAgICogICAgIGZpcmVmb3g6IFwiMjNcIixcbiAgICogICAgIGNocm9tZTogXCIyOVwiLFxuICAgKiAgICAgc2FmYXJpOiBcIjUuMVwiLFxuICAgKiAgICAgb3BlcmE6IFwiMTZcIixcbiAgICogICAgIHBoYW50b206IFwiNTM0XCJcbiAgICogICB9KTtcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgbWluVmVyc2lvbnMgbWFwIG9mIG1pbmltYWwgdmVyc2lvbiB0byBicm93c2VyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtzdHJpY3RNb2RlID0gZmFsc2VdIGZsYWcgdG8gcmV0dXJuIGZhbHNlIGlmIGJyb3dzZXIgd2Fzbid0IGZvdW5kIGluIG1hcFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbdWFdIHVzZXIgYWdlbnQgc3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc1Vuc3VwcG9ydGVkQnJvd3NlcihtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpIHtcbiAgICB2YXIgX2Jvd3NlciA9IGJvd3NlcjtcblxuICAgIC8vIG1ha2Ugc3RyaWN0TW9kZSBwYXJhbSBvcHRpb25hbCB3aXRoIHVhIHBhcmFtIHVzYWdlXG4gICAgaWYgKHR5cGVvZiBzdHJpY3RNb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgdWEgPSBzdHJpY3RNb2RlO1xuICAgICAgc3RyaWN0TW9kZSA9IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdE1vZGUgPT09IHZvaWQoMCkpIHtcbiAgICAgIHN0cmljdE1vZGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHVhKSB7XG4gICAgICBfYm93c2VyID0gZGV0ZWN0KHVhKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IFwiXCIgKyBfYm93c2VyLnZlcnNpb247XG4gICAgZm9yICh2YXIgYnJvd3NlciBpbiBtaW5WZXJzaW9ucykge1xuICAgICAgaWYgKG1pblZlcnNpb25zLmhhc093blByb3BlcnR5KGJyb3dzZXIpKSB7XG4gICAgICAgIGlmIChfYm93c2VyW2Jyb3dzZXJdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtaW5WZXJzaW9uc1ticm93c2VyXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciB2ZXJzaW9uIGluIHRoZSBtaW5WZXJzaW9uIG1hcCBzaG91bGQgYmUgYSBzdHJpbmc6ICcgKyBicm93c2VyICsgJzogJyArIFN0cmluZyhtaW5WZXJzaW9ucykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGJyb3dzZXIgdmVyc2lvbiBhbmQgbWluIHN1cHBvcnRlZCB2ZXJzaW9uLlxuICAgICAgICAgIHJldHVybiBjb21wYXJlVmVyc2lvbnMoW3ZlcnNpb24sIG1pblZlcnNpb25zW2Jyb3dzZXJdXSkgPCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmljdE1vZGU7IC8vIG5vdCBmb3VuZFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGJyb3dzZXIgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gbWluVmVyc2lvbnMgbWFwIG9mIG1pbmltYWwgdmVyc2lvbiB0byBicm93c2VyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtzdHJpY3RNb2RlID0gZmFsc2VdIGZsYWcgdG8gcmV0dXJuIGZhbHNlIGlmIGJyb3dzZXIgd2Fzbid0IGZvdW5kIGluIG1hcFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbdWFdIHVzZXIgYWdlbnQgc3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBjaGVjayhtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpIHtcbiAgICByZXR1cm4gIWlzVW5zdXBwb3J0ZWRCcm93c2VyKG1pblZlcnNpb25zLCBzdHJpY3RNb2RlLCB1YSk7XG4gIH1cblxuICBib3dzZXIuaXNVbnN1cHBvcnRlZEJyb3dzZXIgPSBpc1Vuc3VwcG9ydGVkQnJvd3NlcjtcbiAgYm93c2VyLmNvbXBhcmVWZXJzaW9ucyA9IGNvbXBhcmVWZXJzaW9ucztcbiAgYm93c2VyLmNoZWNrID0gY2hlY2s7XG5cbiAgLypcbiAgICogU2V0IG91ciBkZXRlY3QgbWV0aG9kIHRvIHRoZSBtYWluIGJvd3NlciBvYmplY3Qgc28gd2UgY2FuXG4gICAqIHJldXNlIGl0IHRvIHRlc3Qgb3RoZXIgdXNlciBhZ2VudHMuXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGltcGxlbWVudCBmdXR1cmUgdGVzdHMuXG4gICAqL1xuICBib3dzZXIuX2RldGVjdCA9IGRldGVjdDtcblxuICAvKlxuICAgKiBTZXQgb3VyIGRldGVjdCBwdWJsaWMgbWV0aG9kIHRvIHRoZSBtYWluIGJvd3NlciBvYmplY3RcbiAgICogVGhpcyBpcyBuZWVkZWQgdG8gaW1wbGVtZW50IGJvd3NlciBpbiBzZXJ2ZXIgc2lkZVxuICAgKi9cbiAgYm93c2VyLmRldGVjdCA9IGRldGVjdDtcbiAgcmV0dXJuIGJvd3NlclxufSk7XG4iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07IiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuICAgIDogKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgID8gbG9jYXRpb24ucG9ydFxuICAgICAgOiAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IG9wdHMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBwZXItdHJhbnNwb3J0IG9wdGlvbnNcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLnRyYW5zcG9ydE9wdGlvbnNbbmFtZV0gfHwge307XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiBvcHRpb25zLmhvc3RuYW1lIHx8IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogb3B0aW9ucy5wb3J0IHx8IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGgsXG4gICAgZm9yY2VKU09OUDogb3B0aW9ucy5mb3JjZUpTT05QIHx8IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiBvcHRpb25zLmZvcmNlQmFzZTY0IHx8IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogb3B0aW9ucy5lbmFibGVzWERSIHx8IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiBvcHRpb25zLnRpbWVzdGFtcFBhcmFtIHx8IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogb3B0aW9ucy5wb2xpY3lQb3J0IHx8IHRoaXMucG9saWN5UG9ydCxcbiAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuICAgIGtleTogb3B0aW9ucy5rZXkgfHwgdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlIHx8IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuICAgIGNhOiBvcHRpb25zLmNhIHx8IHRoaXMuY2EsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzIHx8IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuICAgIGxvY2FsQWRkcmVzczogb3B0aW9ucy5sb2NhbEFkZHJlc3MgfHwgdGhpcy5sb2NhbEFkZHJlc3MsXG4gICAgcmVxdWVzdFRpbWVvdXQ6IG9wdGlvbnMucmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5yZXF1ZXN0VGltZW91dCxcbiAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KTtcbiAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3BlbiAoKSB7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09PSBtc2cudHlwZSAmJiAncHJvYmUnID09PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQgKCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yIChlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSAoKSB7XG4gICAgb25lcnJvcigndHJhbnNwb3J0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3NvY2tldCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSAodG8pIHtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSBvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nIChvcHRzKSB7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJywgZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfSBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiIsIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdCAob3B0cykge1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKCdQT1NUJyA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJyovKicpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDIpIHtcbiAgICAgICAgICB2YXIgY29udGVudFR5cGU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY2xlYW51cCh0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoZnJvbUVycm9yKSB7XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICB9XG5cbiAgaWYgKGZyb21FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlIHx8IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIgKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlICgpIHtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbnZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xudmFyIE5vZGVXZWJTb2NrZXQ7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHJ5IHtcbiAgICBOb2RlV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIFdlYlNvY2tldCA9IE5vZGVXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHRoaXMucHJvdG9jb2xzO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cbiAgaWYgKHRoaXMubG9jYWxBZGRyZXNzKSB7XG4gICAgb3B0cy5sb2NhbEFkZHJlc3MgPSB0aGlzLmxvY2FsQWRkcmVzcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy53cyA9IHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID8gKHByb3RvY29scyA/IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpIDogbmV3IFdlYlNvY2tldCh1cmkpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG4iLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG5cbnZhciBiYXNlNjRlbmNvZGVyO1xuaWYgKGdsb2JhbCAmJiBnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIiwiXG4vKipcbiAqIEdldHMgdGhlIGtleXMgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuICB2YXIgYXJyID0gW107XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRpZiAoIWNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpKSB7XG5cdFx0XHRcdGNvZGVQb2ludCA9IDB4RkZGRDtcblx0XHRcdH1cblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRyZXR1cm4gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkgPyBjb2RlUG9pbnQgOiAweEZGRkQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZywgb3B0cykge1xuXHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjEuMicsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLyogZ2xvYmFsIEJsb2IgRmlsZSAqL1xuXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBnbG9iYWwuQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5CbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXSc7XG52YXIgd2l0aE5hdGl2ZUZpbGUgPSB0eXBlb2YgZ2xvYmFsLkZpbGUgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuRmlsZSkgPT09ICdbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl0nO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogU3VwcG9ydHMgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQmxvYiBhbmQgRmlsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5IChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgodHlwZW9mIGdsb2JhbC5CdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG4gIGlmIChvYmoudG9KU09OICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gaGFzQmluYXJ5KG9iai50b0pTT04oKSwgdHJ1ZSk7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbnZhciBfTG9nZ2VyID0gcmVxdWlyZSgnLi9Mb2dnZXInKTtcblxudmFyIF9Mb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTG9nZ2VyKTtcblxudmFyIF9lcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBsb2dnZXIgPSBuZXcgX0xvZ2dlcjIuZGVmYXVsdCgnQ29tbWFuZFF1ZXVlJyk7XG5cbnZhciBDb21tYW5kUXVldWUgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuXHRfaW5oZXJpdHMoQ29tbWFuZFF1ZXVlLCBfRXZlbnRFbWl0dGVyKTtcblxuXHRmdW5jdGlvbiBDb21tYW5kUXVldWUoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbW1hbmRRdWV1ZSk7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29tbWFuZFF1ZXVlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29tbWFuZFF1ZXVlKSkuY2FsbCh0aGlzKSk7XG5cblx0XHRfdGhpcy5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuXG5cdFx0Ly8gQ2xvc2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0X3RoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQnVzeSBydW5uaW5nIGEgY29tbWFuZC5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHRfdGhpcy5fYnVzeSA9IGZhbHNlO1xuXG5cdFx0Ly8gUXVldWUgZm9yIHBlbmRpbmcgY29tbWFuZHMuIEVhY2ggY29tbWFuZCBpcyBhbiBPYmplY3Qgd2l0aCBtZXRob2QsXG5cdFx0Ly8gcmVzb2x2ZSwgcmVqZWN0LCBhbmQgb3RoZXIgbWVtYmVycyAoZGVwZW5kaW5nIHRoZSBjYXNlKS5cblx0XHQvLyBAdHlwZSB7QXJyYXk8T2JqZWN0Pn1cblx0XHRfdGhpcy5fcXVldWUgPSBbXTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoQ29tbWFuZFF1ZXVlLCBbe1xuXHRcdGtleTogJ2Nsb3NlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG5cdFx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3B1c2gnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwdXNoKG1ldGhvZCwgZGF0YSkge1xuXHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRcdHZhciBjb21tYW5kID0gT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogbWV0aG9kIH0sIGRhdGEpO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3B1c2goKSBbbWV0aG9kOiVzXScsIG1ldGhvZCk7XG5cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IF90aGlzMi5fcXVldWU7XG5cblx0XHRcdFx0Y29tbWFuZC5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRcdFx0Y29tbWFuZC5yZWplY3QgPSByZWplY3Q7XG5cblx0XHRcdFx0Ly8gQXBwZW5kIGNvbW1hbmQgdG8gdGhlIHF1ZXVlLlxuXHRcdFx0XHRxdWV1ZS5wdXNoKGNvbW1hbmQpO1xuXHRcdFx0XHRfdGhpczIuX2hhbmRsZVBlbmRpbmdDb21tYW5kcygpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2hhbmRsZVBlbmRpbmdDb21tYW5kcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVQZW5kaW5nQ29tbWFuZHMoKSB7XG5cdFx0XHR2YXIgX3RoaXMzID0gdGhpcztcblxuXHRcdFx0aWYgKHRoaXMuX2J1c3kpIHJldHVybjtcblxuXHRcdFx0dmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG5cblx0XHRcdC8vIFRha2UgdGhlIGZpcnN0IGNvbW1hbmQuXG5cdFx0XHR2YXIgY29tbWFuZCA9IHF1ZXVlWzBdO1xuXG5cdFx0XHRpZiAoIWNvbW1hbmQpIHJldHVybjtcblxuXHRcdFx0dGhpcy5fYnVzeSA9IHRydWU7XG5cblx0XHRcdC8vIEV4ZWN1dGUgaXQuXG5cdFx0XHR0aGlzLl9oYW5kbGVDb21tYW5kKGNvbW1hbmQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfdGhpczMuX2J1c3kgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIGZpcnN0IGNvbW1hbmQgKHRoZSBjb21wbGV0ZWQgb25lKSBmcm9tIHRoZSBxdWV1ZS5cblx0XHRcdFx0cXVldWUuc2hpZnQoKTtcblxuXHRcdFx0XHQvLyBBbmQgY29udGludWUuXG5cdFx0XHRcdF90aGlzMy5faGFuZGxlUGVuZGluZ0NvbW1hbmRzKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfaGFuZGxlQ29tbWFuZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDb21tYW5kKGNvbW1hbmQpIHtcblx0XHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ19oYW5kbGVDb21tYW5kKCkgW21ldGhvZDolc10nLCBjb21tYW5kLm1ldGhvZCk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHtcblx0XHRcdFx0Y29tbWFuZC5yZWplY3QobmV3IF9lcnJvcnMuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpKTtcblxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwcm9taXNlSG9sZGVyID0geyBwcm9taXNlOiBudWxsIH07XG5cblx0XHRcdHRoaXMuZW1pdCgnZXhlYycsIGNvbW1hbmQsIHByb21pc2VIb2xkZXIpO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBwcm9taXNlSG9sZGVyLnByb21pc2U7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdfaGFuZGxlQ29tbWFuZCgpIHwgY29tbWFuZCBzdWNjZWVkZWQgW21ldGhvZDolc10nLCBjb21tYW5kLm1ldGhvZCk7XG5cblx0XHRcdFx0aWYgKF90aGlzNC5fY2xvc2VkKSB7XG5cdFx0XHRcdFx0Y29tbWFuZC5yZWplY3QobmV3IF9lcnJvcnMuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpKTtcblxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgdGhlIGNvbW1hbmQgd2l0aCB0aGUgZ2l2ZW4gcmVzdWx0IChpZiBhbnkpLlxuXHRcdFx0XHRjb21tYW5kLnJlc29sdmUocmVzdWx0KTtcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ19oYW5kbGVDb21tYW5kKCkgfCBjb21tYW5kIGZhaWxlZCBbbWV0aG9kOiVzXTogJW8nLCBjb21tYW5kLm1ldGhvZCwgZXJyb3IpO1xuXG5cdFx0XHRcdC8vIFJlamVjdCB0aGUgY29tbWFuZCB3aXRoIHRoZSBlcnJvci5cblx0XHRcdFx0Y29tbWFuZC5yZWplY3QoZXJyb3IpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIENvbW1hbmRRdWV1ZTtcbn0oX2V2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb21tYW5kUXVldWU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfTG9nZ2VyID0gcmVxdWlyZSgnLi9Mb2dnZXInKTtcblxudmFyIF9Mb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTG9nZ2VyKTtcblxudmFyIF9FbmhhbmNlZEV2ZW50RW1pdHRlcjIgPSByZXF1aXJlKCcuL0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5cbnZhciBfRW5oYW5jZWRFdmVudEVtaXR0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRW5oYW5jZWRFdmVudEVtaXR0ZXIyKTtcblxudmFyIF9lcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQUk9GSUxFUyA9IG5ldyBTZXQoWydkZWZhdWx0JywgJ2xvdycsICdtZWRpdW0nLCAnaGlnaCddKTtcbnZhciBERUZBVUxUX1NUQVRTX0lOVEVSVkFMID0gMTAwMDtcblxudmFyIGxvZ2dlciA9IG5ldyBfTG9nZ2VyMi5kZWZhdWx0KCdDb25zdW1lcicpO1xuXG52YXIgQ29uc3VtZXIgPSBmdW5jdGlvbiAoX0VuaGFuY2VkRXZlbnRFbWl0dGVyKSB7XG5cdF9pbmhlcml0cyhDb25zdW1lciwgX0VuaGFuY2VkRXZlbnRFbWl0dGVyKTtcblxuXHQvKipcbiAgKiBAcHJpdmF0ZVxuICAqXG4gICogQGVtaXRzIHtvcmlnaW5hdG9yOiBTdHJpbmcsIFthcHBEYXRhXTogQW55fSBwYXVzZVxuICAqIEBlbWl0cyB7b3JpZ2luYXRvcjogU3RyaW5nLCBbYXBwRGF0YV06IEFueX0gcmVzdW1lXG4gICogQGVtaXRzIHtwcm9maWxlOiBTdHJpbmd9IGVmZmVjdGl2ZXByb2ZpbGVjaGFuZ2VcbiAgKiBAZW1pdHMge3N0YXRzOiBPYmplY3R9IHN0YXRzXG4gICogQGVtaXRzIHVuaGFuZGxlZFxuICAqIEBlbWl0cyB7b3JpZ2luYXRvcjogU3RyaW5nfSBjbG9zZVxuICAqXG4gICogQGVtaXRzIEBjbG9zZVxuICAqL1xuXHRmdW5jdGlvbiBDb25zdW1lcihpZCwga2luZCwgcnRwUGFyYW1ldGVycywgcGVlciwgYXBwRGF0YSkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25zdW1lcik7XG5cblx0XHQvLyBJZC5cblx0XHQvLyBAdHlwZSB7TnVtYmVyfVxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb25zdW1lci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbnN1bWVyKSkuY2FsbCh0aGlzLCBsb2dnZXIpKTtcblxuXHRcdF90aGlzLl9pZCA9IGlkO1xuXG5cdFx0Ly8gQ2xvc2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0X3RoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gTWVkaWEga2luZC5cblx0XHQvLyBAdHlwZSB7U3RyaW5nfVxuXHRcdF90aGlzLl9raW5kID0ga2luZDtcblxuXHRcdC8vIFJUUCBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtSVENSdHBQYXJhbWV0ZXJzfVxuXHRcdF90aGlzLl9ydHBQYXJhbWV0ZXJzID0gcnRwUGFyYW1ldGVycztcblxuXHRcdC8vIEFzc29jaWF0ZWQgUGVlci5cblx0XHQvLyBAdHlwZSB7UGVlcn1cblx0XHRfdGhpcy5fcGVlciA9IHBlZXI7XG5cblx0XHQvLyBBcHAgY3VzdG9tIGRhdGEuXG5cdFx0Ly8gQHR5cGUge0FueX1cblx0XHRfdGhpcy5fYXBwRGF0YSA9IGFwcERhdGE7XG5cblx0XHQvLyBXaGV0aGVyIHdlIGNhbiByZWNlaXZlIHRoaXMgQ29uc3VtZXIgKGJhc2VkIG9uIG91ciBSVFAgY2FwYWJpbGl0aWVzKS5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHRfdGhpcy5fc3VwcG9ydGVkID0gZmFsc2U7XG5cblx0XHQvLyBBc3NvY2lhdGVkIFRyYW5zcG9ydC5cblx0XHQvLyBAdHlwZSB7VHJhbnNwb3J0fVxuXHRcdF90aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0Ly8gUmVtb3RlIHRyYWNrLlxuXHRcdC8vIEB0eXBlIHtNZWRpYVN0cmVhbVRyYWNrfVxuXHRcdF90aGlzLl90cmFjayA9IG51bGw7XG5cblx0XHQvLyBMb2NhbGx5IHBhdXNlZCBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdF90aGlzLl9sb2NhbGx5UGF1c2VkID0gZmFsc2U7XG5cblx0XHQvLyBSZW1vdGVseSBwYXVzZWQgZmxhZy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHRfdGhpcy5fcmVtb3RlbHlQYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8vIFBlcmlvZGljIHN0YXRzIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0X3RoaXMuX3N0YXRzRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gUGVyaW9kaWMgc3RhdHMgZ2F0aGVyaW5nIGludGVydmFsIChtaWxsaXNlY29uZHMpLlxuXHRcdC8vIEB0eXBlIHtOdW1iZXJ9XG5cdFx0X3RoaXMuX3N0YXRzSW50ZXJ2YWwgPSBERUZBVUxUX1NUQVRTX0lOVEVSVkFMO1xuXG5cdFx0Ly8gUHJlZmVycmVkIHByb2ZpbGUuXG5cdFx0Ly8gQHR5cGUge1N0cmluZ31cblx0XHRfdGhpcy5fcHJlZmVycmVkUHJvZmlsZSA9ICdkZWZhdWx0JztcblxuXHRcdC8vIEVmZmVjdGl2ZSBwcm9maWxlLlxuXHRcdC8vIEB0eXBlIHtTdHJpbmd9XG5cdFx0X3RoaXMuX2VmZmVjdGl2ZVByb2ZpbGUgPSBudWxsO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8qKlxuICAqIENvbnN1bWVyIGlkLlxuICAqXG4gICogQHJldHVybiB7TnVtYmVyfVxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKENvbnN1bWVyLCBbe1xuXHRcdGtleTogJ2Nsb3NlJyxcblxuXG5cdFx0LyoqXG4gICAqIENsb3NlcyB0aGUgQ29uc3VtZXIuXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGxvY2FsIFJvb20gaXMgY2xvc2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkgcmV0dXJuO1xuXG5cdFx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG5cdFx0XHRpZiAodGhpcy5fc3RhdHNFbmFibGVkKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXRzRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICh0aGlzLnRyYW5zcG9ydCkgdGhpcy50cmFuc3BvcnQuZGlzYWJsZUNvbnN1bWVyU3RhdHModGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZW1pdCgnQGNsb3NlJyk7XG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdjbG9zZScsICdsb2NhbCcpO1xuXG5cdFx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE15IHJlbW90ZSBDb25zdW1lciB3YXMgY2xvc2VkLlxuICAgKiBJbnZva2VkIHZpYSByZW1vdGUgbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3RlQ2xvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdGVDbG9zZSgpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlQ2xvc2UoKScpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHRcdGlmICh0aGlzLl90cmFuc3BvcnQpIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVDb25zdW1lcih0aGlzKTtcblxuXHRcdFx0dGhpcy5fZGVzdHJveSgpO1xuXG5cdFx0XHR0aGlzLmVtaXQoJ0BjbG9zZScpO1xuXHRcdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAncmVtb3RlJyk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2Rlc3Ryb3knLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcblx0XHRcdHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3RyYWNrLnN0b3AoKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7fVxuXG5cdFx0XHR0aGlzLl90cmFjayA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlY2VpdmVzIFJUUC5cbiAgICpcbiAgICogQHBhcmFtIHt0cmFuc3BvcnR9IFRyYW5zcG9ydCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgd2l0aCBhIHJlbW90ZSBNZWRpYVN0cmVhbVRyYWNrLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVjZWl2ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmUodHJhbnNwb3J0KSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYW5zcG9ydDolb10nLCB0cmFuc3BvcnQpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IF9lcnJvcnMuSW52YWxpZFN0YXRlRXJyb3IoJ0NvbnN1bWVyIGNsb3NlZCcpKTtlbHNlIGlmICghdGhpcy5fc3VwcG9ydGVkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd1bnN1cHBvcnRlZCBjb2RlY3MnKSk7ZWxzZSBpZiAodGhpcy5fdHJhbnNwb3J0KSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdhbHJlYWR5IGhhbmRsZWQgYnkgYSBUcmFuc3BvcnQnKSk7ZWxzZSBpZiAoKHR5cGVvZiB0cmFuc3BvcnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRyYW5zcG9ydCkpICE9PSAnb2JqZWN0JykgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgVHJhbnNwb3J0JykpO1xuXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cblx0XHRcdHJldHVybiB0cmFuc3BvcnQuYWRkQ29uc3VtZXIodGhpcykudGhlbihmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdFx0X3RoaXMyLl90cmFjayA9IHRyYWNrO1xuXG5cdFx0XHRcdC8vIElmIHdlIHdlcmUgcGF1c2VkLCBkaXNhYmxlIHRoZSB0cmFjay5cblx0XHRcdFx0aWYgKF90aGlzMi5wYXVzZWQpIHRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHR0cmFuc3BvcnQub25jZSgnQGNsb3NlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChfdGhpczIuX2Nsb3NlZCB8fCBfdGhpczIuX3RyYW5zcG9ydCAhPT0gdHJhbnNwb3J0KSByZXR1cm47XG5cblx0XHRcdFx0XHRfdGhpczIuX3RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0X3RoaXMyLl90cmFjay5zdG9wKCk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHt9XG5cblx0XHRcdFx0XHRfdGhpczIuX3RyYWNrID0gbnVsbDtcblxuXHRcdFx0XHRcdF90aGlzMi5zYWZlRW1pdCgndW5oYW5kbGVkJyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF90aGlzMi5zYWZlRW1pdCgnaGFuZGxlZCcpO1xuXG5cdFx0XHRcdGlmIChfdGhpczIuX3N0YXRzRW5hYmxlZCkgdHJhbnNwb3J0LmVuYWJsZUNvbnN1bWVyU3RhdHMoX3RoaXMyLCBfdGhpczIuX3N0YXRzSW50ZXJ2YWwpO1xuXG5cdFx0XHRcdHJldHVybiB0cmFjaztcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRfdGhpczIuX3RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUGF1c2VzIHJlY2VpdmluZyBtZWRpYS5cbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwYXVzZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdwYXVzZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHBhdXNlKGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncGF1c2UoKScpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcigncGF1c2UoKSB8IENvbnN1bWVyIGNsb3NlZCcpO1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fbG9jYWxseVBhdXNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbG9jYWxseVBhdXNlZCA9IHRydWU7XG5cblx0XHRcdGlmICh0aGlzLl90cmFjaykgdGhpcy5fdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KSB0aGlzLl90cmFuc3BvcnQucGF1c2VDb25zdW1lcih0aGlzLCBhcHBEYXRhKTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgncGF1c2UnLCAnbG9jYWwnLCBhcHBEYXRhKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWUgaWYgcmVhbGx5IHBhdXNlZC5cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogTXkgcmVtb3RlIENvbnN1bWVyIHdhcyBwYXVzZWQuXG4gICAqIEludm9rZWQgdmlhIHJlbW90ZSBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVQYXVzZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZVBhdXNlKGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlUGF1c2UoKScpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkIHx8IHRoaXMuX3JlbW90ZWx5UGF1c2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX3JlbW90ZWx5UGF1c2VkID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHRoaXMuX3RyYWNrKSB0aGlzLl90cmFjay5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ3BhdXNlJywgJ3JlbW90ZScsIGFwcERhdGEpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXN1bWVzIHJlY2VpdmluZyBtZWRpYS5cbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBub3QgcGF1c2VkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVzdW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVzdW1lKGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdW1lKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3Jlc3VtZSgpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5fbG9jYWxseVBhdXNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbG9jYWxseVBhdXNlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodGhpcy5fdHJhY2sgJiYgIXRoaXMuX3JlbW90ZWx5UGF1c2VkKSB0aGlzLl90cmFjay5lbmFibGVkID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHRoaXMuX3RyYW5zcG9ydCkgdGhpcy5fdHJhbnNwb3J0LnJlc3VtZUNvbnN1bWVyKHRoaXMsIGFwcERhdGEpO1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdyZXN1bWUnLCAnbG9jYWwnLCBhcHBEYXRhKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWUgaWYgbm90IHBhdXNlZC5cblx0XHRcdHJldHVybiAhdGhpcy5wYXVzZWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE15IHJlbW90ZSBDb25zdW1lciB3YXMgcmVzdW1lZC5cbiAgICogSW52b2tlZCB2aWEgcmVtb3RlIG5vdGlmaWNhdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW90ZVJlc3VtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZVJlc3VtZShhcHBEYXRhKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZVJlc3VtZSgpJyk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQgfHwgIXRoaXMuX3JlbW90ZWx5UGF1c2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX3JlbW90ZWx5UGF1c2VkID0gZmFsc2U7XG5cblx0XHRcdGlmICh0aGlzLl90cmFjayAmJiAhdGhpcy5fbG9jYWxseVBhdXNlZCkgdGhpcy5fdHJhY2suZW5hYmxlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ3Jlc3VtZScsICdyZW1vdGUnLCBhcHBEYXRhKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0IHByZWZlcnJlZCByZWNlaXZpbmcgcHJvZmlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFByZWZlcnJlZFByb2ZpbGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRQcmVmZXJyZWRQcm9maWxlKHByb2ZpbGUpIHtcblx0XHRcdGxvZ2dlci5kZWJ1Zygnc2V0UHJlZmVycmVkUHJvZmlsZSgpIFtwcm9maWxlOiVzXScsIHByb2ZpbGUpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcignc2V0UHJlZmVycmVkUHJvZmlsZSgpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmIChwcm9maWxlID09PSB0aGlzLl9wcmVmZXJyZWRQcm9maWxlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIVBST0ZJTEVTLmhhcyhwcm9maWxlKSkge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3NldFByZWZlcnJlZFByb2ZpbGUoKSB8IGludmFsaWQgcHJvZmlsZSBcIiVzXCInLCBwcm9maWxlKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ByZWZlcnJlZFByb2ZpbGUgPSBwcm9maWxlO1xuXG5cdFx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KSB0aGlzLl90cmFuc3BvcnQuc2V0Q29uc3VtZXJQcmVmZXJyZWRQcm9maWxlKHRoaXMsIHRoaXMuX3ByZWZlcnJlZFByb2ZpbGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBQcmVmZXJyZWQgcmVjZWl2aW5nIHByb2ZpbGUgd2FzIHNldCBvbiBteSByZW1vdGUgQ29uc3VtZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9maWxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVTZXRQcmVmZXJyZWRQcm9maWxlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3RlU2V0UHJlZmVycmVkUHJvZmlsZShwcm9maWxlKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZVNldFByZWZlcnJlZFByb2ZpbGUoKSBbcHJvZmlsZTolc10nLCBwcm9maWxlKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCB8fCBwcm9maWxlID09PSB0aGlzLl9wcmVmZXJyZWRQcm9maWxlKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX3ByZWZlcnJlZFByb2ZpbGUgPSBwcm9maWxlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFZmZlY3RpdmUgcmVjZWl2aW5nIHByb2ZpbGUgY2hhbmdlZCBvbiBteSByZW1vdGUgQ29uc3VtZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9maWxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVFZmZlY3RpdmVQcm9maWxlQ2hhbmdlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZUVmZmVjdGl2ZVByb2ZpbGVDaGFuZ2VkKHByb2ZpbGUpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlRWZmZWN0aXZlUHJvZmlsZUNoYW5nZWQoKSBbcHJvZmlsZTolc10nLCBwcm9maWxlKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCB8fCBwcm9maWxlID09PSB0aGlzLl9lZmZlY3RpdmVQcm9maWxlKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX2VmZmVjdGl2ZVByb2ZpbGUgPSBwcm9maWxlO1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdlZmZlY3RpdmVwcm9maWxlY2hhbmdlJywgdGhpcy5fZWZmZWN0aXZlUHJvZmlsZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEVuYWJsZXMgcGVyaW9kaWMgc3RhdHMgcmV0cmlldmFsLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZW5hYmxlU3RhdHMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTdGF0cygpIHtcblx0XHRcdHZhciBpbnRlcnZhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogREVGQVVMVF9TVEFUU19JTlRFUlZBTDtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdlbmFibGVTdGF0cygpIFtpbnRlcnZhbDolc10nLCBpbnRlcnZhbCk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdlbmFibGVTdGF0cygpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fc3RhdHNFbmFibGVkKSByZXR1cm47XG5cblx0XHRcdGlmICh0eXBlb2YgaW50ZXJ2YWwgIT09ICdudW1iZXInIHx8IGludGVydmFsIDwgMTAwMCkgdGhpcy5fc3RhdHNJbnRlcnZhbCA9IERFRkFVTFRfU1RBVFNfSU5URVJWQUw7ZWxzZSB0aGlzLl9zdGF0c0ludGVydmFsID0gaW50ZXJ2YWw7XG5cblx0XHRcdHRoaXMuX3N0YXRzRW5hYmxlZCA9IHRydWU7XG5cblx0XHRcdGlmICh0aGlzLl90cmFuc3BvcnQpIHRoaXMuX3RyYW5zcG9ydC5lbmFibGVDb25zdW1lclN0YXRzKHRoaXMsIHRoaXMuX3N0YXRzSW50ZXJ2YWwpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBEaXNhYmxlcyBwZXJpb2RpYyBzdGF0cyByZXRyaWV2YWwuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNhYmxlU3RhdHMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlU3RhdHMoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2Rpc2FibGVTdGF0cygpJyk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdkaXNhYmxlU3RhdHMoKSB8IENvbnN1bWVyIGNsb3NlZCcpO1xuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9zdGF0c0VuYWJsZWQpIHJldHVybjtcblxuXHRcdFx0dGhpcy5fc3RhdHNFbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdGlmICh0aGlzLl90cmFuc3BvcnQpIHRoaXMuX3RyYW5zcG9ydC5kaXNhYmxlQ29uc3VtZXJTdGF0cyh0aGlzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogTWFyayB0aGlzIENvbnN1bWVyIGFzIHN1aXRhYmxlIGZvciByZWNlcHRpb24gb3Igbm90LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZsYWdcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFN1cHBvcnRlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFN1cHBvcnRlZChmbGFnKSB7XG5cdFx0XHR0aGlzLl9zdXBwb3J0ZWQgPSBmbGFnO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZWNlaXZlIHJlbW90ZSBzdGF0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRzXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVTdGF0cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZVN0YXRzKHN0YXRzKSB7XG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdzdGF0cycsIHN0YXRzKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdpZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFdoZXRoZXIgdGhlIENvbnN1bWVyIGlzIGNsb3NlZC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Nsb3NlZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBNZWRpYSBraW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdraW5kJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9raW5kO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSVFAgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHJldHVybiB7UlRDUnRwUGFyYW1ldGVyc31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J0cFBhcmFtZXRlcnMnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3J0cFBhcmFtZXRlcnM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFzc29jaWF0ZWQgUGVlci5cbiAgICpcbiAgICogQHJldHVybiB7UGVlcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3BlZXInLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BlZXI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7QW55fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXBwRGF0YScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYXBwRGF0YTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogV2hldGhlciB3ZSBjYW4gcmVjZWl2ZSB0aGlzIENvbnN1bWVyIChiYXNlZCBvbiBvdXIgUlRQIGNhcGFiaWxpdGllcykuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzdXBwb3J0ZWQnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cHBvcnRlZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQXNzb2NpYXRlZCBUcmFuc3BvcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RyYW5zcG9ydCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNwb3J0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBUaGUgYXNzb2NpYXRlZCB0cmFjayAoaWYgYW55IHlldCkuXG4gICAqXG4gICAqIEByZXR1cm4ge01lZGlhU3RyZWFtVHJhY2t8TnVsbH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RyYWNrJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl90cmFjaztcblx0XHR9XG5cblx0XHQvKipcbiAgICogV2hldGhlciB0aGUgQ29uc3VtZXIgaXMgbG9jYWxseSBwYXVzZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdsb2NhbGx5UGF1c2VkJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9sb2NhbGx5UGF1c2VkO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBXaGV0aGVyIHRoZSBDb25zdW1lciBpcyByZW1vdGVseSBwYXVzZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVseVBhdXNlZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVtb3RlbHlQYXVzZWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFdoZXRoZXIgdGhlIENvbnN1bWVyIGlzIHBhdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3BhdXNlZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbG9jYWxseVBhdXNlZCB8fCB0aGlzLl9yZW1vdGVseVBhdXNlZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVGhlIHByZWZlcnJlZCBwcm9maWxlLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncHJlZmVycmVkUHJvZmlsZScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcHJlZmVycmVkUHJvZmlsZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVGhlIGVmZmVjdGl2ZSBwcm9maWxlLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZWZmZWN0aXZlUHJvZmlsZScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlUHJvZmlsZTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gQ29uc3VtZXI7XG59KF9FbmhhbmNlZEV2ZW50RW1pdHRlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbnN1bWVyOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ib3dzZXIgPSByZXF1aXJlKCdib3dzZXInKTtcblxudmFyIF9ib3dzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYm93c2VyKTtcblxudmFyIF9Mb2dnZXIgPSByZXF1aXJlKCcuL0xvZ2dlcicpO1xuXG52YXIgX0xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Mb2dnZXIpO1xuXG52YXIgX0Nocm9tZSA9IHJlcXVpcmUoJy4vaGFuZGxlcnMvQ2hyb21lNTUnKTtcblxudmFyIF9DaHJvbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2hyb21lKTtcblxudmFyIF9TYWZhcmkgPSByZXF1aXJlKCcuL2hhbmRsZXJzL1NhZmFyaTExJyk7XG5cbnZhciBfU2FmYXJpMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NhZmFyaSk7XG5cbnZhciBfRmlyZWZveCA9IHJlcXVpcmUoJy4vaGFuZGxlcnMvRmlyZWZveDUwJyk7XG5cbnZhciBfRmlyZWZveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GaXJlZm94KTtcblxudmFyIF9FZGdlID0gcmVxdWlyZSgnLi9oYW5kbGVycy9FZGdlMTEnKTtcblxudmFyIF9FZGdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VkZ2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgbG9nZ2VyID0gbmV3IF9Mb2dnZXIyLmRlZmF1bHQoJ0RldmljZScpO1xuXG4vKipcbiAqIENsYXNzIHdpdGggc3RhdGljIG1lbWJlcnMgcmVwcmVzZW50aW5nIHRoZSB1bmRlcmx5aW5nIGRldmljZSBvciBicm93c2VyLlxuICovXG5cbnZhciBEZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIERldmljZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGV2aWNlKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhEZXZpY2UsIG51bGwsIFt7XG5cdFx0a2V5OiAnaXNTdXBwb3J0ZWQnLFxuXG5cblx0XHQvKipcbiAgICogV2hldGhlciB0aGlzIGRldmljZSBpcyBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcblx0XHRcdGlmICghRGV2aWNlLl9kZXRlY3RlZCkgRGV2aWNlLl9kZXRlY3QoKTtcblxuXHRcdFx0cmV0dXJuIEJvb2xlYW4oRGV2aWNlLl9oYW5kbGVyQ2xhc3MpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGEgc3VpdGFibGUgV2ViUlRDIGhhbmRsZXIgY2xhc3MuXG4gICAqXG4gICAqIEB0eXBlIHtDbGFzc31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19kZXRlY3QnLFxuXG5cblx0XHQvKipcbiAgICogRGV0ZWN0cyB0aGUgY3VycmVudCBkZXZpY2UvYnJvd3Nlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9kZXRlY3QoKSB7XG5cdFx0XHR2YXIgdWEgPSBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0XHRcdHZhciBicm93c2VyID0gX2Jvd3NlcjIuZGVmYXVsdC5fZGV0ZWN0KHVhKTtcblxuXHRcdFx0RGV2aWNlLl9kZXRlY3RlZCA9IHRydWU7XG5cdFx0XHREZXZpY2UuX2ZsYWcgPSB1bmRlZmluZWQ7XG5cdFx0XHREZXZpY2UuX25hbWUgPSBicm93c2VyLm5hbWUgfHwgJ3Vua25vd24gZGV2aWNlJztcblx0XHRcdERldmljZS5fdmVyc2lvbiA9IGJyb3dzZXIudmVyc2lvbiB8fCAndW5rbm93biB2ZXNpb24nO1xuXHRcdFx0RGV2aWNlLl9ib3dzZXIgPSBicm93c2VyO1xuXHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBudWxsO1xuXG5cdFx0XHQvLyBDaHJvbWUsIENocm9taXVtIChkZXNrdG9wIGFuZCBtb2JpbGUpLlxuXHRcdFx0aWYgKF9ib3dzZXIyLmRlZmF1bHQuY2hlY2soeyBjaHJvbWU6ICc1NScsIGNocm9taXVtOiAnNTUnIH0sIHRydWUsIHVhKSkge1xuXHRcdFx0XHREZXZpY2UuX2ZsYWcgPSAnY2hyb21lJztcblx0XHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBfQ2hyb21lMi5kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmlyZWZveCAoZGVza3RvcCBhbmQgbW9iaWxlKS5cblx0XHRcdGVsc2UgaWYgKF9ib3dzZXIyLmRlZmF1bHQuY2hlY2soeyBmaXJlZm94OiAnNTAnIH0sIHRydWUsIHVhKSkge1xuXHRcdFx0XHRcdERldmljZS5fZmxhZyA9ICdmaXJlZm94Jztcblx0XHRcdFx0XHREZXZpY2UuX2hhbmRsZXJDbGFzcyA9IF9GaXJlZm94Mi5kZWZhdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFNhZmFyaSAoZGVza3RvcCBhbmQgbW9iaWxlKS5cblx0XHRcdFx0ZWxzZSBpZiAoX2Jvd3NlcjIuZGVmYXVsdC5jaGVjayh7IHNhZmFyaTogJzExJyB9LCB0cnVlLCB1YSkpIHtcblx0XHRcdFx0XHRcdERldmljZS5fZmxhZyA9ICdzYWZhcmknO1xuXHRcdFx0XHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBfU2FmYXJpMi5kZWZhdWx0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBFZGdlIChkZXNrdG9wKS5cblx0XHRcdFx0XHRlbHNlIGlmIChfYm93c2VyMi5kZWZhdWx0LmNoZWNrKHsgbXNlZGdlOiAnMTEnIH0sIHRydWUsIHVhKSkge1xuXHRcdFx0XHRcdFx0XHREZXZpY2UuX2ZsYWcgPSAnbXNlZGdlJztcblx0XHRcdFx0XHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBfRWRnZTIuZGVmYXVsdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdC8vIE9wZXJhIChkZXNrdG9wIGFuZCBtb2JpbGUpLlxuXHRcdFx0aWYgKF9ib3dzZXIyLmRlZmF1bHQuY2hlY2soeyBvcGVyYTogJzQ0JyB9LCB0cnVlLCB1YSkpIHtcblx0XHRcdFx0RGV2aWNlLl9mbGFnID0gJ29wZXJhJztcblx0XHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBfQ2hyb21lMi5kZWZhdWx0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoRGV2aWNlLmlzU3VwcG9ydGVkKCkpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdkZXZpY2Ugc3VwcG9ydGVkIFtmbGFnOiVzLCBuYW1lOlwiJXNcIiwgdmVyc2lvbjolcywgaGFuZGxlcjolc10nLCBEZXZpY2UuX2ZsYWcsIERldmljZS5fbmFtZSwgRGV2aWNlLl92ZXJzaW9uLCBEZXZpY2UuX2hhbmRsZXJDbGFzcy5uYW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZ2dlci53YXJuKCdkZXZpY2Ugbm90IHN1cHBvcnRlZCBbbmFtZTolcywgdmVyc2lvbjolc10nLCBEZXZpY2UuX25hbWUsIERldmljZS5fdmVyc2lvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZmxhZycsXG5cblx0XHQvKipcbiAgICogR2V0IHRoZSBkZXZpY2UgZmxhZy5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdGlmICghRGV2aWNlLl9kZXRlY3RlZCkgRGV2aWNlLl9kZXRlY3QoKTtcblxuXHRcdFx0cmV0dXJuIERldmljZS5fZmxhZztcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0IHRoZSBkZXZpY2UgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbmFtZScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRpZiAoIURldmljZS5fZGV0ZWN0ZWQpIERldmljZS5fZGV0ZWN0KCk7XG5cblx0XHRcdHJldHVybiBEZXZpY2UuX25hbWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldCB0aGUgZGV2aWNlIHZlcnNpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3ZlcnNpb24nLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0aWYgKCFEZXZpY2UuX2RldGVjdGVkKSBEZXZpY2UuX2RldGVjdCgpO1xuXG5cdFx0XHRyZXR1cm4gRGV2aWNlLl92ZXJzaW9uO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXQgdGhlIGJvd3NlciBtb2R1bGUgT2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdib3dzZXInLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0aWYgKCFEZXZpY2UuX2RldGVjdGVkKSBEZXZpY2UuX2RldGVjdCgpO1xuXG5cdFx0XHRyZXR1cm4gRGV2aWNlLl9ib3dzZXI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnSGFuZGxlcicsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRpZiAoIURldmljZS5fZGV0ZWN0ZWQpIERldmljZS5fZGV0ZWN0KCk7XG5cblx0XHRcdHJldHVybiBEZXZpY2UuX2hhbmRsZXJDbGFzcztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRGV2aWNlO1xufSgpO1xuXG4vLyBJbml0aWFsaXplZCBmbGFnLlxuLy8gQHR5cGUge0Jvb2xlYW59XG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gRGV2aWNlO1xuRGV2aWNlLl9kZXRlY3RlZCA9IGZhbHNlO1xuXG4vLyBEZXZpY2UgZmxhZy5cbi8vIEB0eXBlIHtTdHJpbmd9XG5EZXZpY2UuX2ZsYWcgPSB1bmRlZmluZWQ7XG5cbi8vIERldmljZSBuYW1lLlxuLy8gQHR5cGUge1N0cmluZ31cbkRldmljZS5fbmFtZSA9IHVuZGVmaW5lZDtcblxuLy8gRGV2aWNlIHZlcnNpb24uXG4vLyBAdHlwZSB7U3RyaW5nfVxuRGV2aWNlLl92ZXJzaW9uID0gdW5kZWZpbmVkO1xuXG4vLyBib3dzZXIgbW9kdWxlIE9iamVjdC5cbi8vIEB0eXBlIHtPYmplY3R9XG5EZXZpY2UuX2Jvd3NlciA9IHVuZGVmaW5lZDtcblxuLy8gV2ViUlRDIGhhbmRlciBmb3IgdGhpcyBkZXZpY2UuXG4vLyBAdHlwZSB7Q2xhc3N9XG5EZXZpY2UuX2hhbmRsZXJDbGFzcyA9IG51bGw7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgX0xvZ2dlciA9IHJlcXVpcmUoJy4vTG9nZ2VyJyk7XG5cbnZhciBfTG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xvZ2dlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEVuaGFuY2VkRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcblx0X2luaGVyaXRzKEVuaGFuY2VkRXZlbnRFbWl0dGVyLCBfRXZlbnRFbWl0dGVyKTtcblxuXHRmdW5jdGlvbiBFbmhhbmNlZEV2ZW50RW1pdHRlcihsb2dnZXIpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5oYW5jZWRFdmVudEVtaXR0ZXIpO1xuXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEVuaGFuY2VkRXZlbnRFbWl0dGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW5oYW5jZWRFdmVudEVtaXR0ZXIpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLnNldE1heExpc3RlbmVycyhJbmZpbml0eSk7XG5cblx0XHRfdGhpcy5fbG9nZ2VyID0gbG9nZ2VyIHx8IG5ldyBfTG9nZ2VyMi5kZWZhdWx0KCdFbmhhbmNlZEV2ZW50RW1pdHRlcicpO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhFbmhhbmNlZEV2ZW50RW1pdHRlciwgW3tcblx0XHRrZXk6ICdzYWZlRW1pdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNhZmVFbWl0KGV2ZW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0XHRcdFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZW1pdC5hcHBseSh0aGlzLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHR0aGlzLl9sb2dnZXIuZXJyb3IoJ3NhZmVFbWl0KCkgfCBldmVudCBsaXN0ZW5lciB0aHJldyBhbiBlcnJvciBbZXZlbnQ6JXNdOiVvJywgZXZlbnQsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdzYWZlRW1pdEFzUHJvbWlzZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNhZmVFbWl0QXNQcm9taXNlKGV2ZW50KSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0Zm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHRcdFx0XHRhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhyZXN1bHQpIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIGVycmJhY2sgPSBmdW5jdGlvbiBlcnJiYWNrKGVycm9yKSB7XG5cdFx0XHRcdFx0X3RoaXMyLl9sb2dnZXIuZXJyb3IoJ3NhZmVFbWl0QXNQcm9taXNlKCkgfCBlcnJiYWNrIGNhbGxlZCBbZXZlbnQ6JXNdOiVvJywgZXZlbnQsIGVycm9yKTtcblxuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0X3RoaXMyLnNhZmVFbWl0LmFwcGx5KF90aGlzMiwgW2V2ZW50XS5jb25jYXQoYXJncywgW2NhbGxiYWNrLCBlcnJiYWNrXSkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEVuaGFuY2VkRXZlbnRFbWl0dGVyO1xufShfZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEVuaGFuY2VkRXZlbnRFbWl0dGVyOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9kZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJyk7XG5cbnZhciBfZGVidWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVidWcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQVBQX05BTUUgPSAnbWVkaWFzb3VwLWNsaWVudCc7XG5cbnZhciBMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIExvZ2dlcihwcmVmaXgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9nZ2VyKTtcblxuXHRcdGlmIChwcmVmaXgpIHtcblx0XHRcdHRoaXMuX2RlYnVnID0gKDAsIF9kZWJ1ZzIuZGVmYXVsdCkoQVBQX05BTUUgKyAnOicgKyBwcmVmaXgpO1xuXHRcdFx0dGhpcy5fd2FybiA9ICgwLCBfZGVidWcyLmRlZmF1bHQpKEFQUF9OQU1FICsgJzpXQVJOOicgKyBwcmVmaXgpO1xuXHRcdFx0dGhpcy5fZXJyb3IgPSAoMCwgX2RlYnVnMi5kZWZhdWx0KShBUFBfTkFNRSArICc6RVJST1I6JyArIHByZWZpeCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RlYnVnID0gKDAsIF9kZWJ1ZzIuZGVmYXVsdCkoQVBQX05BTUUpO1xuXHRcdFx0dGhpcy5fd2FybiA9ICgwLCBfZGVidWcyLmRlZmF1bHQpKEFQUF9OQU1FICsgJzpXQVJOJyk7XG5cdFx0XHR0aGlzLl9lcnJvciA9ICgwLCBfZGVidWcyLmRlZmF1bHQpKEFQUF9OQU1FICsgJzpFUlJPUicpO1xuXHRcdH1cblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblx0XHR0aGlzLl9kZWJ1Zy5sb2cgPSBjb25zb2xlLmluZm8uYmluZChjb25zb2xlKTtcblx0XHR0aGlzLl93YXJuLmxvZyA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuXHRcdHRoaXMuX2Vycm9yLmxvZyA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcblx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhMb2dnZXIsIFt7XG5cdFx0a2V5OiAnZGVidWcnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RlYnVnO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3dhcm4nLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3dhcm47XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZXJyb3InLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2Vycm9yO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBMb2dnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExvZ2dlcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfTG9nZ2VyID0gcmVxdWlyZSgnLi9Mb2dnZXInKTtcblxudmFyIF9Mb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTG9nZ2VyKTtcblxudmFyIF9FbmhhbmNlZEV2ZW50RW1pdHRlcjIgPSByZXF1aXJlKCcuL0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5cbnZhciBfRW5oYW5jZWRFdmVudEVtaXR0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRW5oYW5jZWRFdmVudEVtaXR0ZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgbG9nZ2VyID0gbmV3IF9Mb2dnZXIyLmRlZmF1bHQoJ1BlZXInKTtcblxudmFyIFBlZXIgPSBmdW5jdGlvbiAoX0VuaGFuY2VkRXZlbnRFbWl0dGVyKSB7XG5cdF9pbmhlcml0cyhQZWVyLCBfRW5oYW5jZWRFdmVudEVtaXR0ZXIpO1xuXG5cdC8qKlxuICAqIEBwcml2YXRlXG4gICpcbiAgKiBAZW1pdHMge2NvbnN1bWVyOiBDb25zdW1lcn0gbmV3Y29uc3VtZXJcbiAgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IGNsb3NlXG4gICpcbiAgKiBAZW1pdHMgQGNsb3NlXG4gICovXG5cdGZ1bmN0aW9uIFBlZXIobmFtZSwgYXBwRGF0YSkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZWVyKTtcblxuXHRcdC8vIE5hbWUuXG5cdFx0Ly8gQHR5cGUge1N0cmluZ31cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUGVlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBlZXIpKS5jYWxsKHRoaXMsIGxvZ2dlcikpO1xuXG5cdFx0X3RoaXMuX25hbWUgPSBuYW1lO1xuXG5cdFx0Ly8gQ2xvc2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0X3RoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQXBwIGN1c3RvbSBkYXRhLlxuXHRcdC8vIEB0eXBlIHtBbnl9XG5cdFx0X3RoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuXG5cdFx0Ly8gTWFwIG9mIENvbnN1bWVycyBpbmRleGVkIGJ5IGlkLlxuXHRcdC8vIEB0eXBlIHttYXA8TnVtYmVyLCBDb25zdW1lcj59XG5cdFx0X3RoaXMuX2NvbnN1bWVycyA9IG5ldyBNYXAoKTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBQZWVyIG5hbWUuXG4gICpcbiAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoUGVlciwgW3tcblx0XHRrZXk6ICdjbG9zZScsXG5cblxuXHRcdC8qKlxuICAgKiBDbG9zZXMgdGhlIFBlZXIuXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGxvY2FsIFJvb20gaXMgY2xvc2VkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkgcmV0dXJuO1xuXG5cdFx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLmVtaXQoJ0BjbG9zZScpO1xuXHRcdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAnbG9jYWwnKTtcblxuXHRcdFx0Ly8gQ2xvc2UgYWxsIHRoZSBDb25zdW1lcnMuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0XHRcdHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5fY29uc3VtZXJzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciBjb25zdW1lciA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRcdFx0Y29uc3VtZXIuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFRoZSByZW1vdGUgUGVlciBvciBSb29tIHdhcyBjbG9zZWQuXG4gICAqIEludm9rZWQgdmlhIHJlbW90ZSBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVDbG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZUNsb3NlKGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlQ2xvc2UoKScpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuZW1pdCgnQGNsb3NlJyk7XG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdjbG9zZScsICdyZW1vdGUnLCBhcHBEYXRhKTtcblxuXHRcdFx0Ly8gQ2xvc2UgYWxsIHRoZSBDb25zdW1lcnMuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuX2NvbnN1bWVycy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciBjb25zdW1lciA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0XHRcdGNvbnN1bWVyLnJlbW90ZUNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdF9pdGVyYXRvcjIucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcblx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0IHRoZSBDb25zdW1lciB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbnN1bWVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Q29uc3VtZXJCeUlkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0Q29uc3VtZXJCeUlkKGlkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29uc3VtZXJzLmdldChpZCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFkZCBhbiBhc3NvY2lhdGVkIENvbnN1bWVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0NvbnN1bWVyfSBjb25zdW1lclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYWRkQ29uc3VtZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRDb25zdW1lcihjb25zdW1lcikge1xuXHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRcdGlmICh0aGlzLl9jb25zdW1lcnMuaGFzKGNvbnN1bWVyLmlkKSkgdGhyb3cgbmV3IEVycm9yKCdDb25zdW1lciBhbHJlYWR5IGV4aXN0cyBbaWQ6JyArIGNvbnN1bWVyLmlkICsgJ10nKTtcblxuXHRcdFx0Ly8gU3RvcmUgaXQuXG5cdFx0XHR0aGlzLl9jb25zdW1lcnMuc2V0KGNvbnN1bWVyLmlkLCBjb25zdW1lcik7XG5cblx0XHRcdC8vIEhhbmRsZSBpdC5cblx0XHRcdGNvbnN1bWVyLm9uKCdAY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzMi5fY29uc3VtZXJzLmRlbGV0ZShjb25zdW1lci5pZCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRW1pdCBldmVudC5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ25ld2NvbnN1bWVyJywgY29uc3VtZXIpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ25hbWUnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX25hbWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFdoZXRoZXIgdGhlIFBlZXIgaXMgY2xvc2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY2xvc2VkJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jbG9zZWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7QW55fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXBwRGF0YScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYXBwRGF0YTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVGhlIGxpc3Qgb2YgQ29uc3VtZXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxDb25zdW1lcj59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjb25zdW1lcnMnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIEFycmF5LmZyb20odGhpcy5fY29uc3VtZXJzLnZhbHVlcygpKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gUGVlcjtcbn0oX0VuaGFuY2VkRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGVlcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Mb2dnZXIgPSByZXF1aXJlKCcuL0xvZ2dlcicpO1xuXG52YXIgX0xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Mb2dnZXIpO1xuXG52YXIgX0VuaGFuY2VkRXZlbnRFbWl0dGVyMiA9IHJlcXVpcmUoJy4vRW5oYW5jZWRFdmVudEVtaXR0ZXInKTtcblxudmFyIF9FbmhhbmNlZEV2ZW50RW1pdHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbmhhbmNlZEV2ZW50RW1pdHRlcjIpO1xuXG52YXIgX2Vycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIERFRkFVTFRfU1RBVFNfSU5URVJWQUwgPSAxMDAwO1xudmFyIFNJTVVMQ0FTVF9ERUZBVUxUID0ge1xuXHRsb3c6IDEwMDAwMCxcblx0bWVkaXVtOiAzMDAwMDAsXG5cdGhpZ2g6IDE1MDAwMDBcbn07XG5cbnZhciBsb2dnZXIgPSBuZXcgX0xvZ2dlcjIuZGVmYXVsdCgnUHJvZHVjZXInKTtcblxudmFyIFByb2R1Y2VyID0gZnVuY3Rpb24gKF9FbmhhbmNlZEV2ZW50RW1pdHRlcikge1xuXHRfaW5oZXJpdHMoUHJvZHVjZXIsIF9FbmhhbmNlZEV2ZW50RW1pdHRlcik7XG5cblx0LyoqXG4gICogQHByaXZhdGVcbiAgKlxuICAqIEBlbWl0cyB7b3JpZ2luYXRvcjogU3RyaW5nLCBbYXBwRGF0YV06IEFueX0gcGF1c2VcbiAgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IHJlc3VtZVxuICAqIEBlbWl0cyB7c3RhdHM6IE9iamVjdH0gc3RhdHNcbiAgKiBAZW1pdHMgdW5oYW5kbGVkXG4gICogQGVtaXRzIHRyYWNrZW5kZWRcbiAgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IGNsb3NlXG4gICpcbiAgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IEBjbG9zZVxuICAqL1xuXHRmdW5jdGlvbiBQcm9kdWNlcih0cmFjaywgb3B0aW9ucywgYXBwRGF0YSkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9kdWNlcik7XG5cblx0XHQvLyBJZC5cblx0XHQvLyBAdHlwZSB7TnVtYmVyfVxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQcm9kdWNlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFByb2R1Y2VyKSkuY2FsbCh0aGlzLCBsb2dnZXIpKTtcblxuXHRcdF90aGlzLl9pZCA9IHV0aWxzLnJhbmRvbU51bWJlcigpO1xuXG5cdFx0Ly8gQ2xvc2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0X3RoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gT3JpZ2luYWwgdHJhY2suXG5cdFx0Ly8gQHR5cGUge01lZGlhU3RyZWFtVHJhY2t9XG5cdFx0X3RoaXMuX29yaWdpbmFsVHJhY2sgPSB0cmFjaztcblxuXHRcdC8vIFRyYWNrIGNsb25lZCBmcm9tIHRoZSBvcmlnaW5hbCBvbmUuXG5cdFx0Ly8gQHR5cGUge01lZGlhU3RyZWFtVHJhY2t9XG5cdFx0X3RoaXMuX3RyYWNrID0gdHJhY2suY2xvbmUoKTtcblxuXHRcdC8vIEFwcCBjdXN0b20gZGF0YS5cblx0XHQvLyBAdHlwZSB7QW55fVxuXHRcdF90aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcblxuXHRcdC8vIFNpbXVsY2FzdC5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fGZhbHNlfVxuXHRcdF90aGlzLl9zaW11bGNhc3QgPSBmYWxzZTtcblxuXHRcdGlmIChvcHRpb25zLnNpbXVsY2FzdCkgX3RoaXMuX3NpbXVsY2FzdCA9IE9iamVjdC5hc3NpZ24oe30sIFNJTVVMQ0FTVF9ERUZBVUxULCBvcHRpb25zLnNpbXVsY2FzdCk7XG5cblx0XHQvLyBBc3NvY2lhdGVkIFRyYW5zcG9ydC5cblx0XHQvLyBAdHlwZSB7VHJhbnNwb3J0fVxuXHRcdF90aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0Ly8gUlRQIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge1JUQ1J0cFBhcmFtZXRlcnN9XG5cdFx0X3RoaXMuX3J0cFBhcmFtZXRlcnMgPSBudWxsO1xuXG5cdFx0Ly8gTG9jYWxseSBwYXVzZWQgZmxhZy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHRfdGhpcy5fbG9jYWxseVBhdXNlZCA9ICFfdGhpcy5fdHJhY2suZW5hYmxlZDtcblxuXHRcdC8vIFJlbW90ZWx5IHBhdXNlZCBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdF90aGlzLl9yZW1vdGVseVBhdXNlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gUGVyaW9kaWMgc3RhdHMgZmxhZy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHRfdGhpcy5fc3RhdHNFbmFibGVkID0gZmFsc2U7XG5cblx0XHQvLyBQZXJpb2RpYyBzdGF0cyBnYXRoZXJpbmcgaW50ZXJ2YWwgKG1pbGxpc2Vjb25kcykuXG5cdFx0Ly8gQHR5cGUge051bWJlcn1cblx0XHRfdGhpcy5fc3RhdHNJbnRlcnZhbCA9IERFRkFVTFRfU1RBVFNfSU5URVJWQUw7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGVmZmVjdGl2ZSB0cmFjay5cblx0XHRfdGhpcy5faGFuZGxlVHJhY2soKTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBQcm9kdWNlciBpZC5cbiAgKlxuICAqIEByZXR1cm4ge051bWJlcn1cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhQcm9kdWNlciwgW3tcblx0XHRrZXk6ICdjbG9zZScsXG5cblxuXHRcdC8qKlxuICAgKiBDbG9zZXMgdGhlIFByb2R1Y2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoYXBwRGF0YSkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHJldHVybjtcblxuXHRcdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHRoaXMuX3N0YXRzRW5hYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9zdGF0c0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAodGhpcy50cmFuc3BvcnQpIHtcblx0XHRcdFx0XHR0aGlzLnRyYW5zcG9ydC5kaXNhYmxlUHJvZHVjZXJTdGF0cyh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KSB0aGlzLl90cmFuc3BvcnQucmVtb3ZlUHJvZHVjZXIodGhpcywgJ2xvY2FsJywgYXBwRGF0YSk7XG5cblx0XHRcdHRoaXMuX2Rlc3Ryb3koKTtcblxuXHRcdFx0dGhpcy5lbWl0KCdAY2xvc2UnLCAnbG9jYWwnLCBhcHBEYXRhKTtcblx0XHRcdHRoaXMuc2FmZUVtaXQoJ2Nsb3NlJywgJ2xvY2FsJywgYXBwRGF0YSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE15IHJlbW90ZSBQcm9kdWNlciB3YXMgY2xvc2VkLlxuICAgKiBJbnZva2VkIHZpYSByZW1vdGUgbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3RlQ2xvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdGVDbG9zZShhcHBEYXRhKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZUNsb3NlKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkgcmV0dXJuO1xuXG5cdFx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG5cdFx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KSB0aGlzLl90cmFuc3BvcnQucmVtb3ZlUHJvZHVjZXIodGhpcywgJ3JlbW90ZScsIGFwcERhdGEpO1xuXG5cdFx0XHR0aGlzLl9kZXN0cm95KCk7XG5cblx0XHRcdHRoaXMuZW1pdCgnQGNsb3NlJywgJ3JlbW90ZScsIGFwcERhdGEpO1xuXHRcdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAncmVtb3RlJywgYXBwRGF0YSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2Rlc3Ryb3knLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcblx0XHRcdHRoaXMuX3RyYW5zcG9ydCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcnRwUGFyYW1ldGVycyA9IG51bGw7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3RyYWNrLnN0b3AoKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZW5kcyBSVFAuXG4gICAqXG4gICAqIEBwYXJhbSB7dHJhbnNwb3J0fSBUcmFuc3BvcnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZW5kJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2VuZCh0cmFuc3BvcnQpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3NlbmQoKSBbdHJhbnNwb3J0OiVvXScsIHRyYW5zcG9ydCk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgX2Vycm9ycy5JbnZhbGlkU3RhdGVFcnJvcignUHJvZHVjZXIgY2xvc2VkJykpO2Vsc2UgaWYgKHRoaXMuX3RyYW5zcG9ydCkgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignYWxyZWFkeSBoYW5kbGVkIGJ5IGEgVHJhbnNwb3J0JykpO2Vsc2UgaWYgKCh0eXBlb2YgdHJhbnNwb3J0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0cmFuc3BvcnQpKSAhPT0gJ29iamVjdCcpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdpbnZhbGlkIFRyYW5zcG9ydCcpKTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG5cdFx0XHRyZXR1cm4gdHJhbnNwb3J0LmFkZFByb2R1Y2VyKHRoaXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0cmFuc3BvcnQub25jZSgnQGNsb3NlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChfdGhpczIuX2Nsb3NlZCB8fCBfdGhpczIuX3RyYW5zcG9ydCAhPT0gdHJhbnNwb3J0KSByZXR1cm47XG5cblx0XHRcdFx0XHRfdGhpczIuX3RyYW5zcG9ydC5yZW1vdmVQcm9kdWNlcihfdGhpczIsICdsb2NhbCcpO1xuXG5cdFx0XHRcdFx0X3RoaXMyLl90cmFuc3BvcnQgPSBudWxsO1xuXHRcdFx0XHRcdF90aGlzMi5fcnRwUGFyYW1ldGVycyA9IG51bGw7XG5cblx0XHRcdFx0XHRfdGhpczIuc2FmZUVtaXQoJ3VuaGFuZGxlZCcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfdGhpczIuc2FmZUVtaXQoJ2hhbmRsZWQnKTtcblxuXHRcdFx0XHRpZiAoX3RoaXMyLl9zdGF0c0VuYWJsZWQpIHRyYW5zcG9ydC5lbmFibGVQcm9kdWNlclN0YXRzKF90aGlzMiwgX3RoaXMyLl9zdGF0c0ludGVydmFsKTtcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRfdGhpczIuX3RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUGF1c2VzIHNlbmRpbmcgbWVkaWEuXG4gICAqXG4gICAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcGF1c2VkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncGF1c2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwYXVzZShhcHBEYXRhKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3BhdXNlKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3BhdXNlKCkgfCBQcm9kdWNlciBjbG9zZWQnKTtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2xvY2FsbHlQYXVzZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xvY2FsbHlQYXVzZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5fdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KSB0aGlzLl90cmFuc3BvcnQucGF1c2VQcm9kdWNlcih0aGlzLCBhcHBEYXRhKTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgncGF1c2UnLCAnbG9jYWwnLCBhcHBEYXRhKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWUgaWYgcmVhbGx5IHBhdXNlZC5cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogTXkgcmVtb3RlIFByb2R1Y2VyIHdhcyBwYXVzZWQuXG4gICAqIEludm9rZWQgdmlhIHJlbW90ZSBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVQYXVzZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZVBhdXNlKGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlUGF1c2UoKScpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkIHx8IHRoaXMuX3JlbW90ZWx5UGF1c2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX3JlbW90ZWx5UGF1c2VkID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgncGF1c2UnLCAncmVtb3RlJywgYXBwRGF0YSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlc3VtZXMgc2VuZGluZyBtZWRpYS5cbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBub3QgcGF1c2VkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVzdW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVzdW1lKGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdW1lKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3Jlc3VtZSgpIHwgUHJvZHVjZXIgY2xvc2VkJyk7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5fbG9jYWxseVBhdXNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbG9jYWxseVBhdXNlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIXRoaXMuX3JlbW90ZWx5UGF1c2VkKSB0aGlzLl90cmFjay5lbmFibGVkID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHRoaXMuX3RyYW5zcG9ydCkgdGhpcy5fdHJhbnNwb3J0LnJlc3VtZVByb2R1Y2VyKHRoaXMsIGFwcERhdGEpO1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdyZXN1bWUnLCAnbG9jYWwnLCBhcHBEYXRhKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWUgaWYgbm90IHBhdXNlZC5cblx0XHRcdHJldHVybiAhdGhpcy5wYXVzZWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE15IHJlbW90ZSBQcm9kdWNlciB3YXMgcmVzdW1lZC5cbiAgICogSW52b2tlZCB2aWEgcmVtb3RlIG5vdGlmaWNhdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW90ZVJlc3VtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZVJlc3VtZShhcHBEYXRhKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZVJlc3VtZSgpJyk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQgfHwgIXRoaXMuX3JlbW90ZWx5UGF1c2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX3JlbW90ZWx5UGF1c2VkID0gZmFsc2U7XG5cblx0XHRcdGlmICghdGhpcy5fbG9jYWxseVBhdXNlZCkgdGhpcy5fdHJhY2suZW5hYmxlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ3Jlc3VtZScsICdyZW1vdGUnLCBhcHBEYXRhKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgdHJhY2sgd2l0aCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2sgLSBOZXcgdHJhY2suXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHdpdGggdGhlIG5ldyB0cmFjayBpdHNlbGYuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlVHJhY2snLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlVHJhY2sodHJhY2spIHtcblx0XHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFt0cmFjazolb10nLCB0cmFjayk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgX2Vycm9ycy5JbnZhbGlkU3RhdGVFcnJvcignUHJvZHVjZXIgY2xvc2VkJykpO2Vsc2UgaWYgKCEodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSkgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ3RyYWNrIGlzIG5vdCBhIE1lZGlhU3RyZWFtVHJhY2snKSk7ZWxzZSBpZiAodHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndHJhY2sucmVhZHlTdGF0ZSBpcyBcImVuZGVkXCInKSk7XG5cblx0XHRcdHZhciBjbG9uZWRUcmFjayA9IHRyYWNrLmNsb25lKCk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gSWYgdGhpcyBQcm9kdWNlciBpcyBoYW5kbGVkIGJ5IGEgVHJhbnNwb3J0LCB3ZSBuZWVkIHRvIHRlbGwgaXQgYWJvdXRcblx0XHRcdFx0Ly8gdGhlIG5ldyB0cmFjay5cblx0XHRcdFx0aWYgKF90aGlzMy5fdHJhbnNwb3J0KSByZXR1cm4gX3RoaXMzLl90cmFuc3BvcnQucmVwbGFjZVByb2R1Y2VyVHJhY2soX3RoaXMzLCBjbG9uZWRUcmFjayk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gU3RvcCB0aGUgcHJldmlvdXMgdHJhY2suXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0X3RoaXMzLl90cmFjay5vbmVuZGVkID0gbnVsbDtfdGhpczMuX3RyYWNrLnN0b3AoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHt9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBQcm9kdWNlciB3YXMgbG9jYWxseSBwYXVzZWQvcmVzdW1lZCBhbmQgdGhlIHN0YXRlIG9mIHRoZSBuZXdcblx0XHRcdFx0Ly8gdHJhY2sgZG9lcyBub3QgbWF0Y2gsIGZpeCBpdC5cblx0XHRcdFx0aWYgKCFfdGhpczMucGF1c2VkKSBjbG9uZWRUcmFjay5lbmFibGVkID0gdHJ1ZTtlbHNlIGNsb25lZFRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIG5ldyB0cmFja3MuXG5cdFx0XHRcdF90aGlzMy5fb3JpZ2luYWxUcmFjayA9IHRyYWNrO1xuXHRcdFx0XHRfdGhpczMuX3RyYWNrID0gY2xvbmVkVHJhY2s7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBlZmZlY3RpdmUgdHJhY2suXG5cdFx0XHRcdF90aGlzMy5faGFuZGxlVHJhY2soKTtcblxuXHRcdFx0XHQvLyBSZXR1cm4gdGhlIG5ldyB0cmFjay5cblx0XHRcdFx0cmV0dXJuIF90aGlzMy5fdHJhY2s7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0L3VwZGF0ZSBSVFAgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtSVENSdHBQYXJhbWV0ZXJzfSBydHBQYXJhbWV0ZXJzXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRSdHBQYXJhbWV0ZXJzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0UnRwUGFyYW1ldGVycyhydHBQYXJhbWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzID0gcnRwUGFyYW1ldGVycztcblx0XHR9XG5cblx0XHQvKipcbiAgICogRW5hYmxlcyBwZXJpb2RpYyBzdGF0cyByZXRyaWV2YWwuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlbmFibGVTdGF0cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVN0YXRzKCkge1xuXHRcdFx0dmFyIGludGVydmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBERUZBVUxUX1NUQVRTX0lOVEVSVkFMO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ2VuYWJsZVN0YXRzKCkgW2ludGVydmFsOiVzXScsIGludGVydmFsKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ2VuYWJsZVN0YXRzKCkgfCBQcm9kdWNlciBjbG9zZWQnKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9zdGF0c0VuYWJsZWQpIHJldHVybjtcblxuXHRcdFx0aWYgKHR5cGVvZiBpbnRlcnZhbCAhPT0gJ251bWJlcicgfHwgaW50ZXJ2YWwgPCAxMDAwKSB0aGlzLl9zdGF0c0ludGVydmFsID0gREVGQVVMVF9TVEFUU19JTlRFUlZBTDtlbHNlIHRoaXMuX3N0YXRzSW50ZXJ2YWwgPSBpbnRlcnZhbDtcblxuXHRcdFx0dGhpcy5fc3RhdHNFbmFibGVkID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHRoaXMuX3RyYW5zcG9ydCkgdGhpcy5fdHJhbnNwb3J0LmVuYWJsZVByb2R1Y2VyU3RhdHModGhpcywgdGhpcy5fc3RhdHNJbnRlcnZhbCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIERpc2FibGVzIHBlcmlvZGljIHN0YXRzIHJldHJpZXZhbC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc2FibGVTdGF0cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTdGF0cygpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnZGlzYWJsZVN0YXRzKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ2Rpc2FibGVTdGF0cygpIHwgUHJvZHVjZXIgY2xvc2VkJyk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX3N0YXRzRW5hYmxlZCkgcmV0dXJuO1xuXG5cdFx0XHR0aGlzLl9zdGF0c0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHRoaXMuX3RyYW5zcG9ydCkgdGhpcy5fdHJhbnNwb3J0LmRpc2FibGVQcm9kdWNlclN0YXRzKHRoaXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZWNlaXZlIHJlbW90ZSBzdGF0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRzXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVTdGF0cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZVN0YXRzKHN0YXRzKSB7XG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdzdGF0cycsIHN0YXRzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19oYW5kbGVUcmFjaycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVUcmFjaygpIHtcblx0XHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXG5cdFx0XHQvLyBJZiB0aGUgY2xvbmVkIHRyYWNrIGlzIGNsb3NlZCAoZm9yIGV4YW1wbGUgaWYgdGhlIGRlc2t0b3Agc2hhcmluZyBpcyBjbG9zZWRcblx0XHRcdC8vIHZpYSBjaHJvbWUgVUkpIGNsb3NlIHRoZSBQcm9kdWNlci5cblx0XHRcdHRoaXMuX3RyYWNrLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChfdGhpczQuX2Nsb3NlZCkgcmV0dXJuO1xuXG5cdFx0XHRcdGxvZ2dlci53YXJuKCd0cmFjayBcImVuZGVkXCIgZXZlbnQsIGNsb3NpbmcgUHJvZHVjZXInKTtcblxuXHRcdFx0XHRfdGhpczQuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcblx0XHRcdFx0X3RoaXM0LmNsb3NlKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2lkJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9pZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogV2hldGhlciB0aGUgUHJvZHVjZXIgaXMgY2xvc2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY2xvc2VkJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jbG9zZWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE1lZGlhIGtpbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2tpbmQnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RyYWNrLmtpbmQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFRoZSBhc3NvY2lhdGVkIHRyYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNZWRpYVN0cmVhbVRyYWNrfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndHJhY2snLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RyYWNrO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBUaGUgYXNzb2NpYXRlZCBvcmlnaW5hbCB0cmFjay5cbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFTdHJlYW1UcmFja31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ29yaWdpbmFsVHJhY2snLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29yaWdpbmFsVHJhY2s7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNpbXVsY2FzdCBzZXR0aW5ncy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fGZhbHNlfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2ltdWxjYXN0Jyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zaW11bGNhc3Q7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7QW55fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXBwRGF0YScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYXBwRGF0YTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQXNzb2NpYXRlZCBUcmFuc3BvcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RyYW5zcG9ydCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNwb3J0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSVFAgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHJldHVybiB7UlRDUnRwUGFyYW1ldGVyc31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J0cFBhcmFtZXRlcnMnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3J0cFBhcmFtZXRlcnM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFdoZXRoZXIgdGhlIFByb2R1Y2VyIGlzIGxvY2FsbHkgcGF1c2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbG9jYWxseVBhdXNlZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbG9jYWxseVBhdXNlZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogV2hldGhlciB0aGUgUHJvZHVjZXIgaXMgcmVtb3RlbHkgcGF1c2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3RlbHlQYXVzZWQnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlbW90ZWx5UGF1c2VkO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBXaGV0aGVyIHRoZSBQcm9kdWNlciBpcyBwYXVzZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdwYXVzZWQnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2xvY2FsbHlQYXVzZWQgfHwgdGhpcy5fcmVtb3RlbHlQYXVzZWQ7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFByb2R1Y2VyO1xufShfRW5oYW5jZWRFdmVudEVtaXR0ZXIzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQcm9kdWNlcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Mb2dnZXIgPSByZXF1aXJlKCcuL0xvZ2dlcicpO1xuXG52YXIgX0xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Mb2dnZXIpO1xuXG52YXIgX0VuaGFuY2VkRXZlbnRFbWl0dGVyMiA9IHJlcXVpcmUoJy4vRW5oYW5jZWRFdmVudEVtaXR0ZXInKTtcblxudmFyIF9FbmhhbmNlZEV2ZW50RW1pdHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbmhhbmNlZEV2ZW50RW1pdHRlcjIpO1xuXG52YXIgX2Vycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbnZhciBfb3J0YyA9IHJlcXVpcmUoJy4vb3J0YycpO1xuXG52YXIgb3J0YyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9vcnRjKTtcblxudmFyIF9EZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpO1xuXG52YXIgX0RldmljZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EZXZpY2UpO1xuXG52YXIgX1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4vVHJhbnNwb3J0Jyk7XG5cbnZhciBfVHJhbnNwb3J0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RyYW5zcG9ydCk7XG5cbnZhciBfUHJvZHVjZXIgPSByZXF1aXJlKCcuL1Byb2R1Y2VyJyk7XG5cbnZhciBfUHJvZHVjZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHJvZHVjZXIpO1xuXG52YXIgX1BlZXIgPSByZXF1aXJlKCcuL1BlZXInKTtcblxudmFyIF9QZWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BlZXIpO1xuXG52YXIgX0NvbnN1bWVyID0gcmVxdWlyZSgnLi9Db25zdW1lcicpO1xuXG52YXIgX0NvbnN1bWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbnN1bWVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgbG9nZ2VyID0gbmV3IF9Mb2dnZXIyLmRlZmF1bHQoJ1Jvb20nKTtcblxudmFyIFJvb21TdGF0ZSA9IHtcblx0bmV3OiAnbmV3Jyxcblx0am9pbmluZzogJ2pvaW5pbmcnLFxuXHRqb2luZWQ6ICdqb2luZWQnLFxuXHRjbG9zZWQ6ICdjbG9zZWQnXG59O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIFJvb20gcmVwcmVzZW50cyBhIHJlbW90ZSBtdWx0aSBjb25mZXJlbmNlIGFuZCBhIGxvY2FsXG4gKiBwZWVyIHRoYXQgam9pbnMgaXQuXG4gKi9cblxudmFyIFJvb20gPSBmdW5jdGlvbiAoX0VuaGFuY2VkRXZlbnRFbWl0dGVyKSB7XG5cdF9pbmhlcml0cyhSb29tLCBfRW5oYW5jZWRFdmVudEVtaXR0ZXIpO1xuXG5cdC8qKlxuICAqIFJvb20gY2xhc3MuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICogQHBhcmFtIHtPYmplY3R9IFtyb29tU2V0dGluZ3NdIFJlbW90ZSByb29tIHNldHRpbmdzLCBpbmNsdWRpbmcgaXRzIFJUUFxuICAqIGNhcGFiaWxpdGllcywgbWFuZGF0b3J5IGNvZGVjcywgZXRjLiBJZiBnaXZlbiwgbm8gJ3F1ZXJ5Um9vbScgcmVxdWVzdCBpcyBzZW50XG4gICogdG8gdGhlIHNlcnZlciB0byBkaXNjb3ZlciB0aGVtLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXF1ZXN0VGltZW91dD0xMDAwMF0gLSBUaW1lb3V0IGZvciBzZW50IHJlcXVlc3RzXG4gICogKGluIG1pbGxpc2Vjb25kcykuIERlZmF1bHRzIHRvIDEwMDAwICgxMCBzZWNvbmRzKS5cbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhbnNwb3J0T3B0aW9uc10gLSBPcHRpb25zIGZvciBUcmFuc3BvcnQgY3JlYXRlZCBpbiBtZWRpYXNvdXAuXG4gICogQHBhcmFtIHtBcnJheTxSVENJY2VTZXJ2ZXI+fSBbb3B0aW9ucy50dXJuU2VydmVyc10gLSBBcnJheSBvZiBUVVJOIHNlcnZlcnMuXG4gICpcbiAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgZGV2aWNlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICpcbiAgKiBAZW1pdHMge3JlcXVlc3Q6IE9iamVjdCwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBlcnJiYWNrOiBGdW5jdGlvbn0gcmVxdWVzdFxuICAqIEBlbWl0cyB7bm90aWZpY2F0aW9uOiBPYmplY3R9IG5vdGlmeVxuICAqIEBlbWl0cyB7cGVlcjogUGVlcn0gbmV3cGVlclxuICAqIEBlbWl0cyB7b3JpZ2luYXRvcjogU3RyaW5nLCBbYXBwRGF0YV06IEFueX0gY2xvc2VcbiAgKi9cblx0ZnVuY3Rpb24gUm9vbShvcHRpb25zKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvb20pO1xuXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJvb20uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSb29tKSkuY2FsbCh0aGlzLCBsb2dnZXIpKTtcblxuXHRcdGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcblxuXHRcdGlmICghX0RldmljZTIuZGVmYXVsdC5pc1N1cHBvcnRlZCgpKSB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnQgYnJvd3Nlci9kZXZpY2Ugbm90IHN1cHBvcnRlZCcpO1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBDb21wdXRlZCBzZXR0aW5ncy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdF90aGlzLl9zZXR0aW5ncyA9IHtcblx0XHRcdHJvb21TZXR0aW5nczogb3B0aW9ucy5yb29tU2V0dGluZ3MsXG5cdFx0XHRyZXF1ZXN0VGltZW91dDogb3B0aW9ucy5yZXF1ZXN0VGltZW91dCB8fCAxMDAwMCxcblx0XHRcdHRyYW5zcG9ydE9wdGlvbnM6IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fSxcblx0XHRcdHR1cm5TZXJ2ZXJzOiBvcHRpb25zLnR1cm5TZXJ2ZXJzIHx8IFtdXG5cdFx0fTtcblxuXHRcdC8vIFJvb20gc3RhdGUuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0X3RoaXMuX3N0YXRlID0gUm9vbVN0YXRlLm5ldztcblxuXHRcdC8vIE15IG1lZGlhc291cCBQZWVyIG5hbWUuXG5cdFx0Ly8gQHR5cGUge1N0cmluZ31cblx0XHRfdGhpcy5fcGVlck5hbWUgPSBudWxsO1xuXG5cdFx0Ly8gTWFwIG9mIFRyYW5zcG9ydHMgaW5kZXhlZCBieSBpZC5cblx0XHQvLyBAdHlwZSB7bWFwPE51bWJlciwgVHJhbnNwb3J0Pn1cblx0XHRfdGhpcy5fdHJhbnNwb3J0cyA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIE1hcCBvZiBQcm9kdWNlcnMgaW5kZXhlZCBieSBpZC5cblx0XHQvLyBAdHlwZSB7bWFwPE51bWJlciwgUHJvZHVjZXI+fVxuXHRcdF90aGlzLl9wcm9kdWNlcnMgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBNYXAgb2YgUGVlcnMgaW5kZXhlZCBieSBuYW1lLlxuXHRcdC8vIEB0eXBlIHttYXA8U3RyaW5nLCBQZWVyPn1cblx0XHRfdGhpcy5fcGVlcnMgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBFeHRlbmRlZCBSVFAgY2FwYWJpbGl0aWVzLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0X3RoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gbnVsbDtcblxuXHRcdC8vIFdoZXRoZXIgd2UgY2FuIHNlbmQgYXVkaW8vdmlkZW8gYmFzZWQgb24gY29tcHV0ZWQgZXh0ZW5kZWQgUlRQXG5cdFx0Ly8gY2FwYWJpbGl0aWVzLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0X3RoaXMuX2NhblNlbmRCeUtpbmQgPSB7XG5cdFx0XHRhdWRpbzogZmFsc2UsXG5cdFx0XHR2aWRlbzogZmFsc2Vcblx0XHR9O1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8qKlxuICAqIFdoZXRoZXIgdGhlIFJvb20gaXMgam9pbmVkLlxuICAqXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhSb29tLCBbe1xuXHRcdGtleTogJ2dldFRyYW5zcG9ydEJ5SWQnLFxuXG5cblx0XHQvKipcbiAgICogR2V0IHRoZSBUcmFuc3BvcnQgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuICAgKlxuICAgKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFuc3BvcnRCeUlkKGlkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNwb3J0cy5nZXQoaWQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXQgdGhlIFByb2R1Y2VyIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvZHVjZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQcm9kdWNlckJ5SWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9kdWNlckJ5SWQoaWQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wcm9kdWNlcnMuZ2V0KGlkKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0IHRoZSBQZWVyIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqXG4gICAqIEByZXR1cm4ge1BlZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQZWVyQnlOYW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UGVlckJ5TmFtZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGVlcnMuZ2V0KG5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTdGFydCB0aGUgcHJvY2VkdXJlcyB0byBqb2luIGEgcmVtb3RlIHJvb20uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwZWVyTmFtZSAtIE15IG1lZGlhc291cCBQZWVyIG5hbWUuXG4gICAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdqb2luJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gam9pbihwZWVyTmFtZSwgYXBwRGF0YSkge1xuXHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1Zygnam9pbigpIFtwZWVyTmFtZTpcIiVzXCJdJywgcGVlck5hbWUpO1xuXG5cdFx0XHRpZiAodHlwZW9mIHBlZXJOYW1lICE9PSAnc3RyaW5nJykgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGVlck5hbWUnKSk7XG5cblx0XHRcdGlmICh0aGlzLl9zdGF0ZSAhPT0gUm9vbVN0YXRlLm5ldyAmJiB0aGlzLl9zdGF0ZSAhPT0gUm9vbVN0YXRlLmNsb3NlZCkge1xuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IF9lcnJvcnMuSW52YWxpZFN0YXRlRXJyb3IoJ2ludmFsaWQgc3RhdGUgXCInICsgdGhpcy5fc3RhdGUgKyAnXCInKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BlZXJOYW1lID0gcGVlck5hbWU7XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IFJvb21TdGF0ZS5qb2luaW5nO1xuXG5cdFx0XHR2YXIgcm9vbVNldHRpbmdzID0gdm9pZCAwO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIElmIFJvb20gc2V0dGluZ3MgYXJlIHByb3ZpZGVkIGRvbid0IHF1ZXJ5IHRoZW0uXG5cdFx0XHRcdGlmIChfdGhpczIuX3NldHRpbmdzLnJvb21TZXR0aW5ncykge1xuXHRcdFx0XHRcdHJvb21TZXR0aW5ncyA9IF90aGlzMi5fc2V0dGluZ3Mucm9vbVNldHRpbmdzO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBfdGhpczIuX3NlbmRSZXF1ZXN0KCdxdWVyeVJvb20nLCB7IHRhcmdldDogJ3Jvb20nIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0XHRyb29tU2V0dGluZ3MgPSByZXNwb25zZTtcblxuXHRcdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdqb2luKCkgfCBnb3QgUm9vbSBzZXR0aW5nczolbycsIHJvb21TZXR0aW5ncyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gX0RldmljZTIuZGVmYXVsdC5IYW5kbGVyLmdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAobmF0aXZlUnRwQ2FwYWJpbGl0aWVzKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zygnam9pbigpIHwgbmF0aXZlIFJUUCBjYXBhYmlsaXRpZXM6JW8nLCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0XHRcdC8vIEdldCBleHRlbmRlZCBSVFAgY2FwYWJpbGl0aWVzLlxuXHRcdFx0XHRfdGhpczIuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gb3J0Yy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyhuYXRpdmVSdHBDYXBhYmlsaXRpZXMsIHJvb21TZXR0aW5ncy5ydHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zygnam9pbigpIHwgZXh0ZW5kZWQgUlRQIGNhcGFiaWxpdGllczolbycsIF90aGlzMi5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0XHRcdC8vIENoZWNrIHVuc3VwcG9ydGVkIGNvZGVjcy5cblx0XHRcdFx0dmFyIHVuc3VwcG9ydGVkUm9vbUNvZGVjcyA9IG9ydGMuZ2V0VW5zdXBwb3J0ZWRDb2RlY3Mocm9vbVNldHRpbmdzLnJ0cENhcGFiaWxpdGllcywgcm9vbVNldHRpbmdzLm1hbmRhdG9yeUNvZGVjUGF5bG9hZFR5cGVzLCBfdGhpczIuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdFx0XHRpZiAodW5zdXBwb3J0ZWRSb29tQ29kZWNzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoJyVzIG1hbmRhdG9yeSByb29tIGNvZGVjcyBub3Qgc3VwcG9ydGVkOiVvJywgdW5zdXBwb3J0ZWRSb29tQ29kZWNzLmxlbmd0aCwgdW5zdXBwb3J0ZWRSb29tQ29kZWNzKTtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBfZXJyb3JzLlVuc3VwcG9ydGVkRXJyb3IoJ21hbmRhdG9yeSByb29tIGNvZGVjcyBub3Qgc3VwcG9ydGVkJywgdW5zdXBwb3J0ZWRSb29tQ29kZWNzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENoZWNrIHdoZXRoZXIgd2UgY2FuIHNlbmQgYXVkaW8vdmlkZW8uXG5cdFx0XHRcdF90aGlzMi5fY2FuU2VuZEJ5S2luZC5hdWRpbyA9IG9ydGMuY2FuU2VuZCgnYXVkaW8nLCBfdGhpczIuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblx0XHRcdFx0X3RoaXMyLl9jYW5TZW5kQnlLaW5kLnZpZGVvID0gb3J0Yy5jYW5TZW5kKCd2aWRlbycsIF90aGlzMi5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0XHRcdC8vIEdlbmVyYXRlIG91ciBlZmZlY3RpdmUgUlRQIGNhcGFiaWxpdGllcyBmb3IgcmVjZWl2aW5nIG1lZGlhLlxuXHRcdFx0XHR2YXIgZWZmZWN0aXZlTG9jYWxSdHBDYXBhYmlsaXRpZXMgPSBvcnRjLmdldFJ0cENhcGFiaWxpdGllcyhfdGhpczIuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2pvaW4oKSB8IGVmZmVjdGl2ZSBsb2NhbCBSVFAgY2FwYWJpbGl0aWVzIGZvciByZWNlaXZpbmc6JW8nLCBlZmZlY3RpdmVMb2NhbFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0dGFyZ2V0OiAncm9vbScsXG5cdFx0XHRcdFx0cGVlck5hbWU6IF90aGlzMi5fcGVlck5hbWUsXG5cdFx0XHRcdFx0cnRwQ2FwYWJpbGl0aWVzOiBlZmZlY3RpdmVMb2NhbFJ0cENhcGFiaWxpdGllcyxcblx0XHRcdFx0XHRhcHBEYXRhOiBhcHBEYXRhXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzMi5fc2VuZFJlcXVlc3QoJ2pvaW4nLCBkYXRhKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5wZWVycztcblx0XHRcdFx0fSk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChwZWVycykge1xuXHRcdFx0XHQvLyBIYW5kbGUgUGVlcnMgYWxyZWFkeSBleGlzdGluZyBpbiB0aGUgcm9vbS5cblx0XHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuXHRcdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0XHRcdFx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gKHBlZXJzIHx8IFtdKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdFx0XHRcdHZhciBwZWVyRGF0YSA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRfdGhpczIuX2hhbmRsZVBlZXJEYXRhKHBlZXJEYXRhKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdGxvZ2dlci5lcnJvcignam9pbigpIHwgZXJyb3IgaGFuZGxpbmcgUGVlcjolbycsIGVycm9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvciA9IGVycjtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3RoaXMyLl9zdGF0ZSA9IFJvb21TdGF0ZS5qb2luZWQ7XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdqb2luKCkgfCBqb2luZWQgdGhlIFJvb20nKTtcblxuXHRcdFx0XHQvLyBSZXR1cm4gdGhlIGxpc3Qgb2YgYWxyZWFkeSBleGlzdGluZyBQZWVycy5cblx0XHRcdFx0cmV0dXJuIF90aGlzMi5wZWVycztcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRfdGhpczIuX3N0YXRlID0gUm9vbVN0YXRlLm5ldztcblxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBMZWF2ZSB0aGUgUm9vbS5cbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2xlYXZlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbGVhdmUoYXBwRGF0YSkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdsZWF2ZSgpJyk7XG5cblx0XHRcdGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuO1xuXG5cdFx0XHQvLyBTZW5kIGEgbm90aWZpY2F0aW9uLlxuXHRcdFx0dGhpcy5fc2VuZE5vdGlmaWNhdGlvbignbGVhdmUnLCB7IGFwcERhdGE6IGFwcERhdGEgfSk7XG5cblx0XHRcdC8vIFNldCBjbG9zZWQgc3RhdGUgYWZ0ZXIgc2VuZGluZyB0aGUgbm90aWZpY2F0aW9uIChvdGhlcndpc2UgdGhlXG5cdFx0XHQvLyBub3RpZmljYXRpb24gd29uJ3QgYmUgc2VudCkuXG5cdFx0XHR0aGlzLl9zdGF0ZSA9IFJvb21TdGF0ZS5jbG9zZWQ7XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ2Nsb3NlJywgJ2xvY2FsJywgYXBwRGF0YSk7XG5cblx0XHRcdC8vIENsb3NlIGFsbCB0aGUgVHJhbnNwb3J0cy5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gdGhpcy5fdHJhbnNwb3J0cy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciB0cmFuc3BvcnQgPSBfc3RlcDIudmFsdWU7XG5cblx0XHRcdFx0XHR0cmFuc3BvcnQuY2xvc2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENsb3NlIGFsbCB0aGUgUHJvZHVjZXJzLlxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yMiA9IGVycjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IHRoaXMuX3Byb2R1Y2Vycy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciBwcm9kdWNlciA9IF9zdGVwMy52YWx1ZTtcblxuXHRcdFx0XHRcdHByb2R1Y2VyLmNsb3NlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDbG9zZSBhbGwgdGhlIFBlZXJzLlxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yMyA9IGVycjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yNCA9IHRoaXMuX3BlZXJzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlKSB7XG5cdFx0XHRcdFx0dmFyIHBlZXIgPSBfc3RlcDQudmFsdWU7XG5cblx0XHRcdFx0XHRwZWVyLmNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuXHRcdFx0XHRfaXRlcmF0b3JFcnJvcjQgPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdF9pdGVyYXRvcjQucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcblx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yNDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVGhlIHJlbW90ZSBSb29tIHdhcyBjbG9zZWQgb3Igb3VyIHJlbW90ZSBQZWVyIGhhcyBiZWVuIGNsb3NlZC5cbiAgICogSW52b2tlZCB2aWEgcmVtb3RlIG5vdGlmaWNhdGlvbiBvciB2aWEgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3RlQ2xvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdGVDbG9zZShhcHBEYXRhKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZUNsb3NlKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuY2xvc2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX3N0YXRlID0gUm9vbVN0YXRlLmNsb3NlZDtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAncmVtb3RlJywgYXBwRGF0YSk7XG5cblx0XHRcdC8vIENsb3NlIGFsbCB0aGUgVHJhbnNwb3J0cy5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG5cdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3I1ID0gdGhpcy5fdHJhbnNwb3J0cy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IChfc3RlcDUgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciB0cmFuc3BvcnQgPSBfc3RlcDUudmFsdWU7XG5cblx0XHRcdFx0XHR0cmFuc3BvcnQucmVtb3RlQ2xvc2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENsb3NlIGFsbCB0aGUgUHJvZHVjZXJzLlxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yNSA9IGVycjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yNS5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yNiA9IHRoaXMuX3Byb2R1Y2Vycy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciBwcm9kdWNlciA9IF9zdGVwNi52YWx1ZTtcblxuXHRcdFx0XHRcdHByb2R1Y2VyLnJlbW90ZUNsb3NlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDbG9zZSBhbGwgdGhlIFBlZXJzLlxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yNiA9IGVycjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yNi5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yNyA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yNyA9IHRoaXMuX3BlZXJzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7XG5cdFx0XHRcdFx0dmFyIHBlZXIgPSBfc3RlcDcudmFsdWU7XG5cblx0XHRcdFx0XHRwZWVyLnJlbW90ZUNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuXHRcdFx0XHRfaXRlcmF0b3JFcnJvcjcgPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdF9pdGVyYXRvcjcucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjcpIHtcblx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yNztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogV2hldGhlciB3ZSBjYW4gc2VuZCBhdWRpby92aWRlby5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtpbmQgLSAnYXVkaW8nIG9yICd2aWRlbycuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjYW5TZW5kJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FuU2VuZChraW5kKSB7XG5cdFx0XHRpZiAoIXRoaXMuam9pbmVkKSB0aHJvdyBuZXcgX2Vycm9ycy5JbnZhbGlkU3RhdGVFcnJvcignaW52YWxpZCBzdGF0ZSBcIicgKyB0aGlzLl9zdGF0ZSArICdcIicpO2Vsc2UgaWYgKGtpbmQgIT09ICdhdWRpbycgJiYga2luZCAhPT0gJ3ZpZGVvJykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBraW5kIFwiJyArIGtpbmQgKyAnXCInKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhblNlbmRCeUtpbmRba2luZF07XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENyZWF0ZXMgYSBUcmFuc3BvcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gLSBNdXN0IGJlICdzZW5kJyBvciAncmVjdicuXG4gICAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAgICpcbiAgICogQHRocm93cyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBqb2luZWQuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY3JlYXRlVHJhbnNwb3J0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVHJhbnNwb3J0KGRpcmVjdGlvbiwgYXBwRGF0YSkge1xuXHRcdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnY3JlYXRlVHJhbnNwb3J0KCkgW2RpcmVjdGlvbjolc10nLCBkaXJlY3Rpb24pO1xuXG5cdFx0XHRpZiAoIXRoaXMuam9pbmVkKSB0aHJvdyBuZXcgX2Vycm9ycy5JbnZhbGlkU3RhdGVFcnJvcignaW52YWxpZCBzdGF0ZSBcIicgKyB0aGlzLl9zdGF0ZSArICdcIicpO2Vsc2UgaWYgKGRpcmVjdGlvbiAhPT0gJ3NlbmQnICYmIGRpcmVjdGlvbiAhPT0gJ3JlY3YnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGRpcmVjdGlvbiBcIicgKyBkaXJlY3Rpb24gKyAnXCInKTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgbmV3IFRyYW5zcG9ydC5cblx0XHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgX1RyYW5zcG9ydDIuZGVmYXVsdChkaXJlY3Rpb24sIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCB0aGlzLl9zZXR0aW5ncywgYXBwRGF0YSk7XG5cblx0XHRcdC8vIFN0b3JlIGl0LlxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0cy5zZXQodHJhbnNwb3J0LmlkLCB0cmFuc3BvcnQpO1xuXG5cdFx0XHR0cmFuc3BvcnQub24oJ0ByZXF1ZXN0JywgZnVuY3Rpb24gKG1ldGhvZCwgZGF0YSwgY2FsbGJhY2ssIGVycmJhY2spIHtcblx0XHRcdFx0X3RoaXMzLl9zZW5kUmVxdWVzdChtZXRob2QsIGRhdGEpLnRoZW4oY2FsbGJhY2spLmNhdGNoKGVycmJhY2spO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRyYW5zcG9ydC5vbignQG5vdGlmeScsIGZ1bmN0aW9uIChtZXRob2QsIGRhdGEpIHtcblx0XHRcdFx0X3RoaXMzLl9zZW5kTm90aWZpY2F0aW9uKG1ldGhvZCwgZGF0YSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dHJhbnNwb3J0Lm9uKCdAY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzMy5fdHJhbnNwb3J0cy5kZWxldGUodHJhbnNwb3J0LmlkKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gdHJhbnNwb3J0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvZHVjZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2ltdWxjYXN0XVxuICAgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9kdWNlcn1cbiAgICpcbiAgICogQHRocm93cyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBqb2luZWQuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgY2Fubm90IHNlbmQgdGhlIGdpdmVuIGtpbmQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjcmVhdGVQcm9kdWNlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVByb2R1Y2VyKHRyYWNrLCBvcHRpb25zLCBhcHBEYXRhKSB7XG5cdFx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdjcmVhdGVQcm9kdWNlcigpIFt0cmFjazolbywgb3B0aW9uczolb10nLCB0cmFjaywgb3B0aW9ucyk7XG5cblx0XHRcdGlmICghdGhpcy5qb2luZWQpIHRocm93IG5ldyBfZXJyb3JzLkludmFsaWRTdGF0ZUVycm9yKCdpbnZhbGlkIHN0YXRlIFwiJyArIHRoaXMuX3N0YXRlICsgJ1wiJyk7ZWxzZSBpZiAoISh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd0cmFjayBpcyBub3QgYSBNZWRpYVN0cmVhbVRyYWNrJyk7ZWxzZSBpZiAoIXRoaXMuX2NhblNlbmRCeUtpbmRbdHJhY2sua2luZF0pIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNlbmQgJyArIHRyYWNrLmtpbmQpO2Vsc2UgaWYgKHRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpIHRocm93IG5ldyBFcnJvcigndHJhY2sucmVhZHlTdGF0ZSBpcyBcImVuZGVkXCInKTtcblxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRcdC8vIENyZWF0ZSBhIG5ldyBQcm9kdWNlci5cblx0XHRcdHZhciBwcm9kdWNlciA9IG5ldyBfUHJvZHVjZXIyLmRlZmF1bHQodHJhY2ssIG9wdGlvbnMsIGFwcERhdGEpO1xuXG5cdFx0XHQvLyBTdG9yZSBpdC5cblx0XHRcdHRoaXMuX3Byb2R1Y2Vycy5zZXQocHJvZHVjZXIuaWQsIHByb2R1Y2VyKTtcblxuXHRcdFx0cHJvZHVjZXIub24oJ0BjbG9zZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X3RoaXM0Ll9wcm9kdWNlcnMuZGVsZXRlKHByb2R1Y2VyLmlkKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gcHJvZHVjZXI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFByb2R1Y2UgYSBJQ0UgcmVzdGFydCBpbiBhbGwgdGhlIFRyYW5zcG9ydHMuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXN0YXJ0SWNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVzdGFydEljZSgpIHtcblx0XHRcdGlmICghdGhpcy5qb2luZWQpIHRocm93IG5ldyBfZXJyb3JzLkludmFsaWRTdGF0ZUVycm9yKCdpbnZhbGlkIHN0YXRlIFwiJyArIHRoaXMuX3N0YXRlICsgJ1wiJyk7XG5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWU7XG5cdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I4ID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I4ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3I4ID0gdGhpcy5fdHJhbnNwb3J0cy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwODsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IChfc3RlcDggPSBfaXRlcmF0b3I4Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciB0cmFuc3BvcnQgPSBfc3RlcDgudmFsdWU7XG5cblx0XHRcdFx0XHR0cmFuc3BvcnQucmVzdGFydEljZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3I4ID0gdHJ1ZTtcblx0XHRcdFx0X2l0ZXJhdG9yRXJyb3I4ID0gZXJyO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ICYmIF9pdGVyYXRvcjgucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRfaXRlcmF0b3I4LnJldHVybigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I4KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFByb3ZpZGUgdGhlIGxvY2FsIFJvb20gd2l0aCBhIG5vdGlmaWNhdGlvbiBnZW5lcmF0ZWQgYnkgbWVkaWFzb3VwIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWNhdGlvblxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVjZWl2ZU5vdGlmaWNhdGlvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG5cdFx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblxuXHRcdFx0aWYgKHRoaXMuY2xvc2VkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IF9lcnJvcnMuSW52YWxpZFN0YXRlRXJyb3IoJ1Jvb20gY2xvc2VkJykpO2Vsc2UgaWYgKCh0eXBlb2Ygbm90aWZpY2F0aW9uID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihub3RpZmljYXRpb24pKSAhPT0gJ29iamVjdCcpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCd3cm9uZyBub3RpZmljYXRpb24gT2JqZWN0JykpO2Vsc2UgaWYgKG5vdGlmaWNhdGlvbi5ub3RpZmljYXRpb24gIT09IHRydWUpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdub3QgYSBub3RpZmljYXRpb24nKSk7ZWxzZSBpZiAodHlwZW9mIG5vdGlmaWNhdGlvbi5tZXRob2QgIT09ICdzdHJpbmcnKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignd3JvbmcvbWlzc2luZyBub3RpZmljYXRpb24gbWV0aG9kJykpO1xuXG5cdFx0XHR2YXIgbWV0aG9kID0gbm90aWZpY2F0aW9uLm1ldGhvZDtcblxuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlY2VpdmVOb3RpZmljYXRpb24oKSBbbWV0aG9kOiVzLCBub3RpZmljYXRpb246JW9dJywgbWV0aG9kLCBub3RpZmljYXRpb24pO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHN3aXRjaCAobWV0aG9kKSB7XG5cdFx0XHRcdFx0Y2FzZSAnY2xvc2VkJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIGFwcERhdGEgPSBub3RpZmljYXRpb24uYXBwRGF0YTtcblxuXG5cdFx0XHRcdFx0XHRcdF90aGlzNS5yZW1vdGVDbG9zZShhcHBEYXRhKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcG9ydENsb3NlZCc6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciBpZCA9IG5vdGlmaWNhdGlvbi5pZCxcblx0XHRcdFx0XHRcdFx0ICAgIF9hcHBEYXRhID0gbm90aWZpY2F0aW9uLmFwcERhdGE7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHRyYW5zcG9ydCA9IF90aGlzNS5fdHJhbnNwb3J0cy5nZXQoaWQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghdHJhbnNwb3J0KSB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3QgZm91bmQgW2lkOlwiJyArIGlkICsgJ1wiXScpO1xuXG5cdFx0XHRcdFx0XHRcdHRyYW5zcG9ydC5yZW1vdGVDbG9zZShfYXBwRGF0YSk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICd0cmFuc3BvcnRTdGF0cyc6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciBfaWQgPSBub3RpZmljYXRpb24uaWQsXG5cdFx0XHRcdFx0XHRcdCAgICBzdGF0cyA9IG5vdGlmaWNhdGlvbi5zdGF0cztcblxuXHRcdFx0XHRcdFx0XHR2YXIgX3RyYW5zcG9ydCA9IF90aGlzNS5fdHJhbnNwb3J0cy5nZXQoX2lkKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIV90cmFuc3BvcnQpIHRocm93IG5ldyBFcnJvcigndHJhbnNwb3J0IG5vdCBmb3VuZCBbaWQ6JyArIF9pZCArICddJyk7XG5cblx0XHRcdFx0XHRcdFx0X3RyYW5zcG9ydC5yZW1vdGVTdGF0cyhzdGF0cyk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICduZXdQZWVyJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIG5hbWUgPSBub3RpZmljYXRpb24ubmFtZTtcblxuXG5cdFx0XHRcdFx0XHRcdGlmIChfdGhpczUuX3BlZXJzLmhhcyhuYW1lKSkgdGhyb3cgbmV3IEVycm9yKCdQZWVyIGFscmVhZHkgZXhpc3RzIFtuYW1lOlwiJyArIG5hbWUgKyAnXCJdJyk7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHBlZXJEYXRhID0gbm90aWZpY2F0aW9uO1xuXG5cdFx0XHRcdFx0XHRcdF90aGlzNS5faGFuZGxlUGVlckRhdGEocGVlckRhdGEpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAncGVlckNsb3NlZCc6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciBwZWVyTmFtZSA9IG5vdGlmaWNhdGlvbi5uYW1lO1xuXHRcdFx0XHRcdFx0XHR2YXIgX2FwcERhdGEyID0gbm90aWZpY2F0aW9uLmFwcERhdGE7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHBlZXIgPSBfdGhpczUuX3BlZXJzLmdldChwZWVyTmFtZSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFwZWVyKSB0aHJvdyBuZXcgRXJyb3IoJ25vIFBlZXIgZm91bmQgW25hbWU6XCInICsgcGVlck5hbWUgKyAnXCJdJyk7XG5cblx0XHRcdFx0XHRcdFx0cGVlci5yZW1vdGVDbG9zZShfYXBwRGF0YTIpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAncHJvZHVjZXJQYXVzZWQnOlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR2YXIgX2lkMiA9IG5vdGlmaWNhdGlvbi5pZCxcblx0XHRcdFx0XHRcdFx0ICAgIF9hcHBEYXRhMyA9IG5vdGlmaWNhdGlvbi5hcHBEYXRhO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBwcm9kdWNlciA9IF90aGlzNS5fcHJvZHVjZXJzLmdldChfaWQyKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIXByb2R1Y2VyKSB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y2VyIG5vdCBmb3VuZCBbaWQ6JyArIF9pZDIgKyAnXScpO1xuXG5cdFx0XHRcdFx0XHRcdHByb2R1Y2VyLnJlbW90ZVBhdXNlKF9hcHBEYXRhMyk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdwcm9kdWNlclJlc3VtZWQnOlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR2YXIgX2lkMyA9IG5vdGlmaWNhdGlvbi5pZCxcblx0XHRcdFx0XHRcdFx0ICAgIF9hcHBEYXRhNCA9IG5vdGlmaWNhdGlvbi5hcHBEYXRhO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBfcHJvZHVjZXIgPSBfdGhpczUuX3Byb2R1Y2Vycy5nZXQoX2lkMyk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFfcHJvZHVjZXIpIHRocm93IG5ldyBFcnJvcignUHJvZHVjZXIgbm90IGZvdW5kIFtpZDonICsgX2lkMyArICddJyk7XG5cblx0XHRcdFx0XHRcdFx0X3Byb2R1Y2VyLnJlbW90ZVJlc3VtZShfYXBwRGF0YTQpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAncHJvZHVjZXJDbG9zZWQnOlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR2YXIgX2lkNCA9IG5vdGlmaWNhdGlvbi5pZCxcblx0XHRcdFx0XHRcdFx0ICAgIF9hcHBEYXRhNSA9IG5vdGlmaWNhdGlvbi5hcHBEYXRhO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBfcHJvZHVjZXIyID0gX3RoaXM1Ll9wcm9kdWNlcnMuZ2V0KF9pZDQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX3Byb2R1Y2VyMikgdGhyb3cgbmV3IEVycm9yKCdQcm9kdWNlciBub3QgZm91bmQgW2lkOicgKyBfaWQ0ICsgJ10nKTtcblxuXHRcdFx0XHRcdFx0XHRfcHJvZHVjZXIyLnJlbW90ZUNsb3NlKF9hcHBEYXRhNSk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdwcm9kdWNlclN0YXRzJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIF9pZDUgPSBub3RpZmljYXRpb24uaWQsXG5cdFx0XHRcdFx0XHRcdCAgICBfc3RhdHMgPSBub3RpZmljYXRpb24uc3RhdHM7XG5cblx0XHRcdFx0XHRcdFx0dmFyIF9wcm9kdWNlcjMgPSBfdGhpczUuX3Byb2R1Y2Vycy5nZXQoX2lkNSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFfcHJvZHVjZXIzKSB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y2VyIG5vdCBmb3VuZCBbaWQ6JyArIF9pZDUgKyAnXScpO1xuXG5cdFx0XHRcdFx0XHRcdF9wcm9kdWNlcjMucmVtb3RlU3RhdHMoX3N0YXRzKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ25ld0NvbnN1bWVyJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIF9wZWVyTmFtZSA9IG5vdGlmaWNhdGlvbi5wZWVyTmFtZTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgX3BlZXIgPSBfdGhpczUuX3BlZXJzLmdldChfcGVlck5hbWUpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX3BlZXIpIHRocm93IG5ldyBFcnJvcignbm8gUGVlciBmb3VuZCBbbmFtZTpcIicgKyBfcGVlck5hbWUgKyAnXCJdJyk7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGNvbnN1bWVyRGF0YSA9IG5vdGlmaWNhdGlvbjtcblxuXHRcdFx0XHRcdFx0XHRfdGhpczUuX2hhbmRsZUNvbnN1bWVyRGF0YShjb25zdW1lckRhdGEsIF9wZWVyKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnN1bWVyQ2xvc2VkJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIF9pZDYgPSBub3RpZmljYXRpb24uaWQsXG5cdFx0XHRcdFx0XHRcdCAgICBfcGVlck5hbWUyID0gbm90aWZpY2F0aW9uLnBlZXJOYW1lLFxuXHRcdFx0XHRcdFx0XHQgICAgX2FwcERhdGE2ID0gbm90aWZpY2F0aW9uLmFwcERhdGE7XG5cblx0XHRcdFx0XHRcdFx0dmFyIF9wZWVyMiA9IF90aGlzNS5fcGVlcnMuZ2V0KF9wZWVyTmFtZTIpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX3BlZXIyKSB0aHJvdyBuZXcgRXJyb3IoJ25vIFBlZXIgZm91bmQgW25hbWU6XCInICsgX3BlZXJOYW1lMiArICdcIl0nKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgY29uc3VtZXIgPSBfcGVlcjIuZ2V0Q29uc3VtZXJCeUlkKF9pZDYpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghY29uc3VtZXIpIHRocm93IG5ldyBFcnJvcignQ29uc3VtZXIgbm90IGZvdW5kIFtpZDonICsgX2lkNiArICddJyk7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3VtZXIucmVtb3RlQ2xvc2UoX2FwcERhdGE2KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnN1bWVyUGF1c2VkJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIF9pZDcgPSBub3RpZmljYXRpb24uaWQsXG5cdFx0XHRcdFx0XHRcdCAgICBfcGVlck5hbWUzID0gbm90aWZpY2F0aW9uLnBlZXJOYW1lLFxuXHRcdFx0XHRcdFx0XHQgICAgX2FwcERhdGE3ID0gbm90aWZpY2F0aW9uLmFwcERhdGE7XG5cblx0XHRcdFx0XHRcdFx0dmFyIF9wZWVyMyA9IF90aGlzNS5fcGVlcnMuZ2V0KF9wZWVyTmFtZTMpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX3BlZXIzKSB0aHJvdyBuZXcgRXJyb3IoJ25vIFBlZXIgZm91bmQgW25hbWU6XCInICsgX3BlZXJOYW1lMyArICdcIl0nKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgX2NvbnN1bWVyID0gX3BlZXIzLmdldENvbnN1bWVyQnlJZChfaWQ3KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIV9jb25zdW1lcikgdGhyb3cgbmV3IEVycm9yKCdDb25zdW1lciBub3QgZm91bmQgW2lkOicgKyBfaWQ3ICsgJ10nKTtcblxuXHRcdFx0XHRcdFx0XHRfY29uc3VtZXIucmVtb3RlUGF1c2UoX2FwcERhdGE3KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnN1bWVyUmVzdW1lZCc6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciBfaWQ4ID0gbm90aWZpY2F0aW9uLmlkLFxuXHRcdFx0XHRcdFx0XHQgICAgX3BlZXJOYW1lNCA9IG5vdGlmaWNhdGlvbi5wZWVyTmFtZSxcblx0XHRcdFx0XHRcdFx0ICAgIF9hcHBEYXRhOCA9IG5vdGlmaWNhdGlvbi5hcHBEYXRhO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBfcGVlcjQgPSBfdGhpczUuX3BlZXJzLmdldChfcGVlck5hbWU0KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIV9wZWVyNCkgdGhyb3cgbmV3IEVycm9yKCdubyBQZWVyIGZvdW5kIFtuYW1lOlwiJyArIF9wZWVyTmFtZTQgKyAnXCJdJyk7XG5cblx0XHRcdFx0XHRcdFx0dmFyIF9jb25zdW1lcjIgPSBfcGVlcjQuZ2V0Q29uc3VtZXJCeUlkKF9pZDgpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX2NvbnN1bWVyMikgdGhyb3cgbmV3IEVycm9yKCdDb25zdW1lciBub3QgZm91bmQgW2lkOicgKyBfaWQ4ICsgJ10nKTtcblxuXHRcdFx0XHRcdFx0XHRfY29uc3VtZXIyLnJlbW90ZVJlc3VtZShfYXBwRGF0YTgpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAnY29uc3VtZXJQcmVmZXJyZWRQcm9maWxlU2V0Jzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIF9pZDkgPSBub3RpZmljYXRpb24uaWQsXG5cdFx0XHRcdFx0XHRcdCAgICBfcGVlck5hbWU1ID0gbm90aWZpY2F0aW9uLnBlZXJOYW1lLFxuXHRcdFx0XHRcdFx0XHQgICAgcHJvZmlsZSA9IG5vdGlmaWNhdGlvbi5wcm9maWxlO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBfcGVlcjUgPSBfdGhpczUuX3BlZXJzLmdldChfcGVlck5hbWU1KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIV9wZWVyNSkgdGhyb3cgbmV3IEVycm9yKCdubyBQZWVyIGZvdW5kIFtuYW1lOlwiJyArIF9wZWVyTmFtZTUgKyAnXCJdJyk7XG5cblx0XHRcdFx0XHRcdFx0dmFyIF9jb25zdW1lcjMgPSBfcGVlcjUuZ2V0Q29uc3VtZXJCeUlkKF9pZDkpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX2NvbnN1bWVyMykgdGhyb3cgbmV3IEVycm9yKCdDb25zdW1lciBub3QgZm91bmQgW2lkOicgKyBfaWQ5ICsgJ10nKTtcblxuXHRcdFx0XHRcdFx0XHRfY29uc3VtZXIzLnJlbW90ZVNldFByZWZlcnJlZFByb2ZpbGUocHJvZmlsZSk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdjb25zdW1lckVmZmVjdGl2ZVByb2ZpbGVDaGFuZ2VkJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIF9pZDEwID0gbm90aWZpY2F0aW9uLmlkLFxuXHRcdFx0XHRcdFx0XHQgICAgX3BlZXJOYW1lNiA9IG5vdGlmaWNhdGlvbi5wZWVyTmFtZSxcblx0XHRcdFx0XHRcdFx0ICAgIF9wcm9maWxlID0gbm90aWZpY2F0aW9uLnByb2ZpbGU7XG5cblx0XHRcdFx0XHRcdFx0dmFyIF9wZWVyNiA9IF90aGlzNS5fcGVlcnMuZ2V0KF9wZWVyTmFtZTYpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX3BlZXI2KSB0aHJvdyBuZXcgRXJyb3IoJ25vIFBlZXIgZm91bmQgW25hbWU6XCInICsgX3BlZXJOYW1lNiArICdcIl0nKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgX2NvbnN1bWVyNCA9IF9wZWVyNi5nZXRDb25zdW1lckJ5SWQoX2lkMTApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX2NvbnN1bWVyNCkgdGhyb3cgbmV3IEVycm9yKCdDb25zdW1lciBub3QgZm91bmQgW2lkOicgKyBfaWQxMCArICddJyk7XG5cblx0XHRcdFx0XHRcdFx0X2NvbnN1bWVyNC5yZW1vdGVFZmZlY3RpdmVQcm9maWxlQ2hhbmdlZChfcHJvZmlsZSk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdjb25zdW1lclN0YXRzJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIF9pZDExID0gbm90aWZpY2F0aW9uLmlkLFxuXHRcdFx0XHRcdFx0XHQgICAgX3BlZXJOYW1lNyA9IG5vdGlmaWNhdGlvbi5wZWVyTmFtZSxcblx0XHRcdFx0XHRcdFx0ICAgIF9zdGF0czIgPSBub3RpZmljYXRpb24uc3RhdHM7XG5cblx0XHRcdFx0XHRcdFx0dmFyIF9wZWVyNyA9IF90aGlzNS5fcGVlcnMuZ2V0KF9wZWVyTmFtZTcpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX3BlZXI3KSB0aHJvdyBuZXcgRXJyb3IoJ25vIFBlZXIgZm91bmQgW25hbWU6XCInICsgX3BlZXJOYW1lNyArICdcIl0nKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgX2NvbnN1bWVyNSA9IF9wZWVyNy5nZXRDb25zdW1lckJ5SWQoX2lkMTEpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX2NvbnN1bWVyNSkgdGhyb3cgbmV3IEVycm9yKCdDb25zdW1lciBub3QgZm91bmQgW2lkOicgKyBfaWQxMSArICddJyk7XG5cblx0XHRcdFx0XHRcdFx0X2NvbnN1bWVyNS5yZW1vdGVTdGF0cyhfc3RhdHMyKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gbm90aWZpY2F0aW9uIG1ldGhvZCBcIicgKyBtZXRob2QgKyAnXCInKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcigncmVjZWl2ZU5vdGlmaWNhdGlvbigpIGZhaWxlZCBbbm90aWZpY2F0aW9uOiVvXTogJXMnLCBub3RpZmljYXRpb24sIGVycm9yKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19zZW5kUmVxdWVzdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9zZW5kUmVxdWVzdChtZXRob2QsIGRhdGEpIHtcblx0XHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IG1ldGhvZCwgdGFyZ2V0OiAncGVlcicgfSwgZGF0YSk7XG5cblx0XHRcdC8vIFNob3VsZCBuZXZlciBoYXBwZW4uXG5cdFx0XHQvLyBJZ25vcmUgaWYgY2xvc2VkLlxuXHRcdFx0aWYgKHRoaXMuY2xvc2VkKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcignX3NlbmRSZXF1ZXN0KCkgfCBSb29tIGNsb3NlZCBbbWV0aG9kOiVzLCByZXF1ZXN0OiVvXScsIG1ldGhvZCwgcmVxdWVzdCk7XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBfZXJyb3JzLkludmFsaWRTdGF0ZUVycm9yKCdSb29tIGNsb3NlZCcpKTtcblx0XHRcdH1cblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdfc2VuZFJlcXVlc3QoKSBbbWV0aG9kOiVzLCByZXF1ZXN0OiVvXScsIG1ldGhvZCwgcmVxdWVzdCk7XG5cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdHZhciBkb25lID0gZmFsc2U7XG5cblx0XHRcdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmVycm9yKCdyZXF1ZXN0IGZhaWxlZCBbbWV0aG9kOiVzXTogdGltZW91dCcsIG1ldGhvZCk7XG5cblx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRyZWplY3QobmV3IF9lcnJvcnMuVGltZW91dEVycm9yKCd0aW1lb3V0JykpO1xuXHRcdFx0XHR9LCBfdGhpczYuX3NldHRpbmdzLnJlcXVlc3RUaW1lb3V0KTtcblxuXHRcdFx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhyZXNwb25zZSkge1xuXHRcdFx0XHRcdGlmIChkb25lKSByZXR1cm47XG5cblx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXG5cdFx0XHRcdFx0aWYgKF90aGlzNi5jbG9zZWQpIHtcblx0XHRcdFx0XHRcdGxvZ2dlci5lcnJvcigncmVxdWVzdCBmYWlsZWQgW21ldGhvZDolc106IFJvb20gY2xvc2VkJywgbWV0aG9kKTtcblxuXHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcignUm9vbSBjbG9zZWQnKSk7XG5cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlcXVlc3Qgc3VjY2VlZGVkIFttZXRob2Q6JXMsIHJlc3BvbnNlOiVvXScsIG1ldGhvZCwgcmVzcG9uc2UpO1xuXG5cdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIGVycmJhY2sgPSBmdW5jdGlvbiBlcnJiYWNrKGVycm9yKSB7XG5cdFx0XHRcdFx0aWYgKGRvbmUpIHJldHVybjtcblxuXHRcdFx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cblx0XHRcdFx0XHRpZiAoX3RoaXM2LmNsb3NlZCkge1xuXHRcdFx0XHRcdFx0bG9nZ2VyLmVycm9yKCdyZXF1ZXN0IGZhaWxlZCBbbWV0aG9kOiVzXTogUm9vbSBjbG9zZWQnLCBtZXRob2QpO1xuXG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEVycm9yKCdSb29tIGNsb3NlZCcpKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSBtZXNzYWdlIGlzIGFuIEVycm9yLlxuXHRcdFx0XHRcdGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSBlcnJvciA9IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcblxuXHRcdFx0XHRcdGxvZ2dlci5lcnJvcigncmVxdWVzdCBmYWlsZWQgW21ldGhvZDolc106JW8nLCBtZXRob2QsIGVycm9yKTtcblxuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0X3RoaXM2LnNhZmVFbWl0KCdyZXF1ZXN0JywgcmVxdWVzdCwgY2FsbGJhY2ssIGVycmJhY2spO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3NlbmROb3RpZmljYXRpb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfc2VuZE5vdGlmaWNhdGlvbihtZXRob2QsIGRhdGEpIHtcblx0XHRcdC8vIElnbm9yZSBpZiBjbG9zZWQuXG5cdFx0XHRpZiAodGhpcy5jbG9zZWQpIHJldHVybjtcblxuXHRcdFx0dmFyIG5vdGlmaWNhdGlvbiA9IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IG1ldGhvZCwgdGFyZ2V0OiAncGVlcicsIG5vdGlmaWNhdGlvbjogdHJ1ZSB9LCBkYXRhKTtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdfc2VuZE5vdGlmaWNhdGlvbigpIFttZXRob2Q6JXMsIG5vdGlmaWNhdGlvbjolb10nLCBtZXRob2QsIG5vdGlmaWNhdGlvbik7XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ25vdGlmeScsIG5vdGlmaWNhdGlvbik7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2hhbmRsZVBlZXJEYXRhJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVBlZXJEYXRhKHBlZXJEYXRhKSB7XG5cdFx0XHR2YXIgX3RoaXM3ID0gdGhpcztcblxuXHRcdFx0dmFyIG5hbWUgPSBwZWVyRGF0YS5uYW1lLFxuXHRcdFx0ICAgIGNvbnN1bWVycyA9IHBlZXJEYXRhLmNvbnN1bWVycyxcblx0XHRcdCAgICBhcHBEYXRhID0gcGVlckRhdGEuYXBwRGF0YTtcblxuXHRcdFx0dmFyIHBlZXIgPSBuZXcgX1BlZXIyLmRlZmF1bHQobmFtZSwgYXBwRGF0YSk7XG5cblx0XHRcdC8vIFN0b3JlIGl0LlxuXHRcdFx0dGhpcy5fcGVlcnMuc2V0KHBlZXIubmFtZSwgcGVlcik7XG5cblx0XHRcdHBlZXIub24oJ0BjbG9zZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X3RoaXM3Ll9wZWVycy5kZWxldGUocGVlci5uYW1lKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBZGQgY29uc3VtZXJzLlxuXHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZTtcblx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjkgPSBmYWxzZTtcblx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjkgPSB1bmRlZmluZWQ7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjkgPSBjb25zdW1lcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDk7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSAoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWUpIHtcblx0XHRcdFx0XHR2YXIgY29uc3VtZXJEYXRhID0gX3N0ZXA5LnZhbHVlO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoaXMuX2hhbmRsZUNvbnN1bWVyRGF0YShjb25zdW1lckRhdGEsIHBlZXIpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoJ2Vycm9yIGhhbmRsaW5nIGV4aXN0aW5nIENvbnN1bWVyIGluIFBlZXI6JW8nLCBlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgYWxyZWFkeSBqb2luZWQgZW1pdCBldmVudC5cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjkgPSB0cnVlO1xuXHRcdFx0XHRfaXRlcmF0b3JFcnJvcjkgPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgJiYgX2l0ZXJhdG9yOS5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdF9pdGVyYXRvcjkucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjkpIHtcblx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yOTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuam9pbmVkKSB0aGlzLnNhZmVFbWl0KCduZXdwZWVyJywgcGVlcik7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2hhbmRsZUNvbnN1bWVyRGF0YScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDb25zdW1lckRhdGEocHJvZHVjZXJEYXRhLCBwZWVyKSB7XG5cdFx0XHR2YXIgaWQgPSBwcm9kdWNlckRhdGEuaWQsXG5cdFx0XHQgICAga2luZCA9IHByb2R1Y2VyRGF0YS5raW5kLFxuXHRcdFx0ICAgIHJ0cFBhcmFtZXRlcnMgPSBwcm9kdWNlckRhdGEucnRwUGFyYW1ldGVycyxcblx0XHRcdCAgICBwYXVzZWQgPSBwcm9kdWNlckRhdGEucGF1c2VkLFxuXHRcdFx0ICAgIGFwcERhdGEgPSBwcm9kdWNlckRhdGEuYXBwRGF0YTtcblxuXHRcdFx0dmFyIGNvbnN1bWVyID0gbmV3IF9Db25zdW1lcjIuZGVmYXVsdChpZCwga2luZCwgcnRwUGFyYW1ldGVycywgcGVlciwgYXBwRGF0YSk7XG5cdFx0XHR2YXIgc3VwcG9ydGVkID0gb3J0Yy5jYW5SZWNlaXZlKGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMsIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdFx0aWYgKHN1cHBvcnRlZCkgY29uc3VtZXIuc2V0U3VwcG9ydGVkKHRydWUpO1xuXG5cdFx0XHRpZiAocGF1c2VkKSBjb25zdW1lci5yZW1vdGVQYXVzZSgpO1xuXG5cdFx0XHRwZWVyLmFkZENvbnN1bWVyKGNvbnN1bWVyKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdqb2luZWQnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0YXRlID09PSBSb29tU3RhdGUuam9pbmVkO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBXaGV0aGVyIHRoZSBSb29tIGlzIGNsb3NlZC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Nsb3NlZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3RhdGUgPT09IFJvb21TdGF0ZS5jbG9zZWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE15IG1lZGlhc291cCBQZWVyIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3BlZXJOYW1lJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wZWVyTmFtZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVGhlIGxpc3Qgb2YgVHJhbnNwb3J0cy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8VHJhbnNwb3J0Pn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RyYW5zcG9ydHMnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIEFycmF5LmZyb20odGhpcy5fdHJhbnNwb3J0cy52YWx1ZXMoKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFRoZSBsaXN0IG9mIFByb2R1Y2Vycy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8UHJvZHVjZXI+fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncHJvZHVjZXJzJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3Byb2R1Y2Vycy52YWx1ZXMoKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFRoZSBsaXN0IG9mIFBlZXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxQZWVyPn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3BlZXJzJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3BlZXJzLnZhbHVlcygpKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gUm9vbTtcbn0oX0VuaGFuY2VkRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm9vbTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfTG9nZ2VyID0gcmVxdWlyZSgnLi9Mb2dnZXInKTtcblxudmFyIF9Mb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTG9nZ2VyKTtcblxudmFyIF9FbmhhbmNlZEV2ZW50RW1pdHRlcjIgPSByZXF1aXJlKCcuL0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5cbnZhciBfRW5oYW5jZWRFdmVudEVtaXR0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRW5oYW5jZWRFdmVudEVtaXR0ZXIyKTtcblxudmFyIF9lcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX0RldmljZSA9IHJlcXVpcmUoJy4vRGV2aWNlJyk7XG5cbnZhciBfRGV2aWNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RldmljZSk7XG5cbnZhciBfQ29tbWFuZFF1ZXVlID0gcmVxdWlyZSgnLi9Db21tYW5kUXVldWUnKTtcblxudmFyIF9Db21tYW5kUXVldWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tbWFuZFF1ZXVlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgREVGQVVMVF9TVEFUU19JTlRFUlZBTCA9IDEwMDA7XG5cbnZhciBsb2dnZXIgPSBuZXcgX0xvZ2dlcjIuZGVmYXVsdCgnVHJhbnNwb3J0Jyk7XG5cbnZhciBUcmFuc3BvcnQgPSBmdW5jdGlvbiAoX0VuaGFuY2VkRXZlbnRFbWl0dGVyKSB7XG5cdF9pbmhlcml0cyhUcmFuc3BvcnQsIF9FbmhhbmNlZEV2ZW50RW1pdHRlcik7XG5cblx0LyoqXG4gICogQHByaXZhdGVcbiAgKlxuICAqIEBlbWl0cyB7c3RhdGU6IFN0cmluZ30gY29ubmVjdGlvbnN0YXRlY2hhbmdlXG4gICogQGVtaXRzIHtzdGF0czogT2JqZWN0fSBzdGF0c1xuICAqIEBlbWl0cyB7b3JpZ2luYXRvcjogU3RyaW5nLCBbYXBwRGF0YV06IEFueX0gY2xvc2VcbiAgKlxuICAqIEBlbWl0cyB7bWV0aG9kOiBTdHJpbmcsIFtkYXRhXTogT2JqZWN0LCBjYWxsYmFjazogRnVuY3Rpb24sIGVycmJhY2s6IEZ1bmN0aW9ufSBAcmVxdWVzdFxuICAqIEBlbWl0cyB7bWV0aG9kOiBTdHJpbmcsIFtkYXRhXTogT2JqZWN0fSBAbm90aWZ5XG4gICogQGVtaXRzIEBjbG9zZVxuICAqL1xuXHRmdW5jdGlvbiBUcmFuc3BvcnQoZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcywgc2V0dGluZ3MsIGFwcERhdGEpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNwb3J0KTtcblxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUcmFuc3BvcnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUcmFuc3BvcnQpKS5jYWxsKHRoaXMsIGxvZ2dlcikpO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzOiVvXScsIGRpcmVjdGlvbiwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0Ly8gSWQuXG5cdFx0Ly8gQHR5cGUge051bWJlcn1cblx0XHRfdGhpcy5faWQgPSB1dGlscy5yYW5kb21OdW1iZXIoKTtcblxuXHRcdC8vIENsb3NlZCBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdF90aGlzLl9jbG9zZWQgPSBmYWxzZTtcblxuXHRcdC8vIERpcmVjdGlvbi5cblx0XHQvLyBAdHlwZSB7U3RyaW5nfVxuXHRcdF90aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cblx0XHQvLyBSb29tIHNldHRpbmdzLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0X3RoaXMuX3NldHRpbmdzID0gc2V0dGluZ3M7XG5cblx0XHQvLyBBcHAgY3VzdG9tIGRhdGEuXG5cdFx0Ly8gQHR5cGUge0FueX1cblx0XHRfdGhpcy5fYXBwRGF0YSA9IGFwcERhdGE7XG5cblx0XHQvLyBQZXJpb2RpYyBzdGF0cyBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdF90aGlzLl9zdGF0c0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbW1hbmRzIGhhbmRsZXIuXG5cdFx0Ly8gQHR5cGUge0NvbW1hbmRRdWV1ZX1cblx0XHRfdGhpcy5fY29tbWFuZFF1ZXVlID0gbmV3IF9Db21tYW5kUXVldWUyLmRlZmF1bHQoKTtcblxuXHRcdC8vIERldmljZSBzcGVjaWZpYyBoYW5kbGVyLlxuXHRcdF90aGlzLl9oYW5kbGVyID0gbmV3IF9EZXZpY2UyLmRlZmF1bHQuSGFuZGxlcihkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCBzZXR0aW5ncyk7XG5cblx0XHQvLyBUcmFuc3BvcnQgc3RhdGUuIFZhbHVlcyBjYW4gYmU6XG5cdFx0Ly8gJ25ldycvJ2Nvbm5lY3RpbmcnLydjb25uZWN0ZWQnLydmYWlsZWQnLydkaXNjb25uZWN0ZWQnLydjbG9zZWQnXG5cdFx0Ly8gQHR5cGUge1N0cmluZ31cblx0XHRfdGhpcy5fY29ubmVjdGlvblN0YXRlID0gJ25ldyc7XG5cblx0XHRfdGhpcy5fY29tbWFuZFF1ZXVlLm9uKCdleGVjJywgX3RoaXMuX2V4ZWNDb21tYW5kLmJpbmQoX3RoaXMpKTtcblxuXHRcdF90aGlzLl9oYW5kbGVIYW5kbGVyKCk7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0LyoqXG4gICogVHJhbnNwb3J0IGlkLlxuICAqXG4gICogQHJldHVybiB7TnVtYmVyfVxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKFRyYW5zcG9ydCwgW3tcblx0XHRrZXk6ICdjbG9zZScsXG5cblxuXHRcdC8qKlxuICAgKiBDbG9zZSB0aGUgVHJhbnNwb3J0LlxuICAgKlxuICAgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoYXBwRGF0YSkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHJldHVybjtcblxuXHRcdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHRoaXMuX3N0YXRzRW5hYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9zdGF0c0VuYWJsZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5kaXNhYmxlU3RhdHMoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdjbG9zZVRyYW5zcG9ydCcsIHsgaWQ6IHRoaXMuX2lkLCBhcHBEYXRhOiBhcHBEYXRhIH0pO1xuXG5cdFx0XHR0aGlzLmVtaXQoJ0BjbG9zZScpO1xuXHRcdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAnbG9jYWwnLCBhcHBEYXRhKTtcblxuXHRcdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBNeSByZW1vdGUgVHJhbnNwb3J0IHdhcyBjbG9zZWQuXG4gICAqIEludm9rZWQgdmlhIHJlbW90ZSBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdGVDbG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW90ZUNsb3NlKGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlQ2xvc2UoKScpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuZW1pdCgnQGNsb3NlJyk7XG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdjbG9zZScsICdyZW1vdGUnLCBhcHBEYXRhKTtcblxuXHRcdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19kZXN0cm95Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG5cdFx0XHQvLyBDbG9zZSB0aGUgQ29tbWFuZFF1ZXVlLlxuXHRcdFx0dGhpcy5fY29tbWFuZFF1ZXVlLmNsb3NlKCk7XG5cblx0XHRcdC8vIENsb3NlIHRoZSBoYW5kbGVyLlxuXHRcdFx0dGhpcy5faGFuZGxlci5jbG9zZSgpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3Jlc3RhcnRJY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXN0YXJ0SWNlKCkge1xuXHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHJldHVybjtlbHNlIGlmICh0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICduZXcnKSByZXR1cm47XG5cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRpZDogX3RoaXMyLl9pZFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczIuc2FmZUVtaXRBc1Byb21pc2UoJ0ByZXF1ZXN0JywgJ3Jlc3RhcnRUcmFuc3BvcnQnLCBkYXRhKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRcdHZhciByZW1vdGVJY2VQYXJhbWV0ZXJzID0gcmVzcG9uc2UuaWNlUGFyYW1ldGVycztcblxuXHRcdFx0XHQvLyBFbnF1ZXVlIGNvbW1hbmQuXG5cdFx0XHRcdHJldHVybiBfdGhpczIuX2NvbW1hbmRRdWV1ZS5wdXNoKCdyZXN0YXJ0SWNlJywgeyByZW1vdGVJY2VQYXJhbWV0ZXJzOiByZW1vdGVJY2VQYXJhbWV0ZXJzIH0pO1xuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcigncmVzdGFydEljZSgpIHwgZmFpbGVkOiAlbycsIGVycm9yKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2VuYWJsZVN0YXRzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU3RhdHMoKSB7XG5cdFx0XHR2YXIgaW50ZXJ2YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IERFRkFVTFRfU1RBVFNfSU5URVJWQUw7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnZW5hYmxlU3RhdHMoKSBbaW50ZXJ2YWw6JXNdJywgaW50ZXJ2YWwpO1xuXG5cdFx0XHRpZiAodHlwZW9mIGludGVydmFsICE9PSAnbnVtYmVyJyB8fCBpbnRlcnZhbCA8IDEwMDApIGludGVydmFsID0gREVGQVVMVF9TVEFUU19JTlRFUlZBTDtcblxuXHRcdFx0dGhpcy5fc3RhdHNFbmFibGVkID0gdHJ1ZTtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlkOiB0aGlzLl9pZCxcblx0XHRcdFx0aW50ZXJ2YWw6IGludGVydmFsXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ2VuYWJsZVRyYW5zcG9ydFN0YXRzJywgZGF0YSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzYWJsZVN0YXRzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVN0YXRzKCkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdkaXNhYmxlU3RhdHMoKScpO1xuXG5cdFx0XHR0aGlzLl9zdGF0c0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlkOiB0aGlzLl9pZFxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdkaXNhYmxlVHJhbnNwb3J0U3RhdHMnLCBkYXRhKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfaGFuZGxlSGFuZGxlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVIYW5kbGVyKCkge1xuXHRcdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHRcdHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcblxuXHRcdFx0aGFuZGxlci5vbignQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGZ1bmN0aW9uIChzdGF0ZSkge1xuXHRcdFx0XHRpZiAoX3RoaXMzLl9jb25uZWN0aW9uU3RhdGUgPT09IHN0YXRlKSByZXR1cm47XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdUcmFuc3BvcnQgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkIHRvICVzJywgc3RhdGUpO1xuXG5cdFx0XHRcdF90aGlzMy5fY29ubmVjdGlvblN0YXRlID0gc3RhdGU7XG5cblx0XHRcdFx0aWYgKCFfdGhpczMuX2Nsb3NlZCkgX3RoaXMzLnNhZmVFbWl0KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBzdGF0ZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGFuZGxlci5vbignQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCBmdW5jdGlvbiAodHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLCBjYWxsYmFjaywgZXJyYmFjaykge1xuXHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRpZDogX3RoaXMzLl9pZCxcblx0XHRcdFx0XHRkaXJlY3Rpb246IF90aGlzMy5fZGlyZWN0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnM6IF90aGlzMy5fc2V0dGluZ3MudHJhbnNwb3J0T3B0aW9ucyxcblx0XHRcdFx0XHRhcHBEYXRhOiBfdGhpczMuX2FwcERhdGFcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAodHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKSBkYXRhLmR0bHNQYXJhbWV0ZXJzID0gdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdF90aGlzMy5zYWZlRW1pdCgnQHJlcXVlc3QnLCAnY3JlYXRlVHJhbnNwb3J0JywgZGF0YSwgY2FsbGJhY2ssIGVycmJhY2spO1xuXHRcdFx0fSk7XG5cblx0XHRcdGhhbmRsZXIub24oJ0BuZWVkdXBkYXRldHJhbnNwb3J0JywgZnVuY3Rpb24gKHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycykge1xuXHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRpZDogX3RoaXMzLl9pZCxcblx0XHRcdFx0XHRkdGxzUGFyYW1ldGVyczogdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0X3RoaXMzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ3VwZGF0ZVRyYW5zcG9ydCcsIGRhdGEpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGhhbmRsZXIub24oJ0BuZWVkdXBkYXRlcHJvZHVjZXInLCBmdW5jdGlvbiAocHJvZHVjZXIsIHJ0cFBhcmFtZXRlcnMpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0aWQ6IHByb2R1Y2VyLmlkLFxuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnNcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBVcGRhdGUgUHJvZHVjZXIgUlRQIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHByb2R1Y2VyLnNldFJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0Ly8gTm90aWZ5IHRoZSBzZXJ2ZXIuXG5cdFx0XHRcdF90aGlzMy5zYWZlRW1pdCgnQG5vdGlmeScsICd1cGRhdGVQcm9kdWNlcicsIGRhdGEpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNlbmQgdGhlIGdpdmVuIFByb2R1Y2VyIG92ZXIgdGhpcyBUcmFuc3BvcnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7UHJvZHVjZXJ9IHByb2R1Y2VyXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhZGRQcm9kdWNlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZFByb2R1Y2VyKHByb2R1Y2VyKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgW3Byb2R1Y2VyOiVvXScsIHByb2R1Y2VyKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBfZXJyb3JzLkludmFsaWRTdGF0ZUVycm9yKCdUcmFuc3BvcnQgY2xvc2VkJykpO1xuXHRcdFx0aWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdub3QgYSBzZW5kaW5nIFRyYW5zcG9ydCcpKTtcblxuXHRcdFx0Ly8gRW5xdWV1ZSBjb21tYW5kLlxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbW1hbmRRdWV1ZS5wdXNoKCdhZGRQcm9kdWNlcicsIHsgcHJvZHVjZXI6IHByb2R1Y2VyIH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlUHJvZHVjZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVQcm9kdWNlcihwcm9kdWNlciwgb3JpZ2luYXRvciwgYXBwRGF0YSkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdmVQcm9kdWNlcigpIFtwcm9kdWNlcjolb10nLCBwcm9kdWNlcik7XG5cblx0XHRcdC8vIEVucXVldWUgY29tbWFuZC5cblx0XHRcdGlmICghdGhpcy5fY2xvc2VkKSB7XG5cdFx0XHRcdHRoaXMuX2NvbW1hbmRRdWV1ZS5wdXNoKCdyZW1vdmVQcm9kdWNlcicsIHsgcHJvZHVjZXI6IHByb2R1Y2VyIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9yaWdpbmF0b3IgPT09ICdsb2NhbCcpIHRoaXMuc2FmZUVtaXQoJ0Bub3RpZnknLCAnY2xvc2VQcm9kdWNlcicsIHsgaWQ6IHByb2R1Y2VyLmlkLCBhcHBEYXRhOiBhcHBEYXRhIH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncGF1c2VQcm9kdWNlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHBhdXNlUHJvZHVjZXIocHJvZHVjZXIsIGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncGF1c2VQcm9kdWNlcigpIFtwcm9kdWNlcjolb10nLCBwcm9kdWNlcik7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRpZDogcHJvZHVjZXIuaWQsXG5cdFx0XHRcdGFwcERhdGE6IGFwcERhdGFcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ0Bub3RpZnknLCAncGF1c2VQcm9kdWNlcicsIGRhdGEpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVzdW1lUHJvZHVjZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXN1bWVQcm9kdWNlcihwcm9kdWNlciwgYXBwRGF0YSkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXN1bWVQcm9kdWNlcigpIFtwcm9kdWNlcjolb10nLCBwcm9kdWNlcik7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRpZDogcHJvZHVjZXIuaWQsXG5cdFx0XHRcdGFwcERhdGE6IGFwcERhdGFcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ0Bub3RpZnknLCAncmVzdW1lUHJvZHVjZXInLCBkYXRhKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlcGxhY2VQcm9kdWNlclRyYWNrJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVByb2R1Y2VyVHJhY2socHJvZHVjZXIsIHRyYWNrKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlcGxhY2VQcm9kdWNlclRyYWNrKCkgW3Byb2R1Y2VyOiVvXScsIHByb2R1Y2VyKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbW1hbmRRdWV1ZS5wdXNoKCdyZXBsYWNlUHJvZHVjZXJUcmFjaycsIHsgcHJvZHVjZXI6IHByb2R1Y2VyLCB0cmFjazogdHJhY2sgfSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlbmFibGVQcm9kdWNlclN0YXRzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW5hYmxlUHJvZHVjZXJTdGF0cyhwcm9kdWNlciwgaW50ZXJ2YWwpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnZW5hYmxlUHJvZHVjZXJTdGF0cygpIFtwcm9kdWNlcjolb10nLCBwcm9kdWNlcik7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRpZDogcHJvZHVjZXIuaWQsXG5cdFx0XHRcdGludGVydmFsOiBpbnRlcnZhbFxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdlbmFibGVQcm9kdWNlclN0YXRzJywgZGF0YSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNhYmxlUHJvZHVjZXJTdGF0cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVQcm9kdWNlclN0YXRzKHByb2R1Y2VyKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2Rpc2FibGVQcm9kdWNlclN0YXRzKCkgW3Byb2R1Y2VyOiVvXScsIHByb2R1Y2VyKTtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlkOiBwcm9kdWNlci5pZFxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdkaXNhYmxlUHJvZHVjZXJTdGF0cycsIGRhdGEpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZWNlaXZlIHRoZSBnaXZlbiBDb25zdW1lciBvdmVyIHRoaXMgVHJhbnNwb3J0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0NvbnN1bWVyfSBjb25zdW1lclxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byBhIHJlbW90ZSBNZWRpYVN0cmVhbVRyYWNrLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYWRkQ29uc3VtZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRDb25zdW1lcihjb25zdW1lcikge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRDb25zdW1lcigpIFtjb25zdW1lcjolb10nLCBjb25zdW1lcik7XG5cblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgX2Vycm9ycy5JbnZhbGlkU3RhdGVFcnJvcignVHJhbnNwb3J0IGNsb3NlZCcpKTtcblx0XHRcdGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2JykgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignbm90IGEgcmVjZWl2aW5nIFRyYW5zcG9ydCcpKTtcblxuXHRcdFx0Ly8gRW5xdWV1ZSBjb21tYW5kLlxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbW1hbmRRdWV1ZS5wdXNoKCdhZGRDb25zdW1lcicsIHsgY29uc3VtZXI6IGNvbnN1bWVyIH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQ29uc3VtZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDb25zdW1lcihjb25zdW1lcikge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdmVDb25zdW1lcigpIFtjb25zdW1lcjolb10nLCBjb25zdW1lcik7XG5cblx0XHRcdC8vIEVucXVldWUgY29tbWFuZC5cblx0XHRcdHRoaXMuX2NvbW1hbmRRdWV1ZS5wdXNoKCdyZW1vdmVDb25zdW1lcicsIHsgY29uc3VtZXI6IGNvbnN1bWVyIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3BhdXNlQ29uc3VtZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwYXVzZUNvbnN1bWVyKGNvbnN1bWVyLCBhcHBEYXRhKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3BhdXNlQ29uc3VtZXIoKSBbY29uc3VtZXI6JW9dJywgY29uc3VtZXIpO1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0aWQ6IGNvbnN1bWVyLmlkLFxuXHRcdFx0XHRhcHBEYXRhOiBhcHBEYXRhXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ3BhdXNlQ29uc3VtZXInLCBkYXRhKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3Jlc3VtZUNvbnN1bWVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVzdW1lQ29uc3VtZXIoY29uc3VtZXIsIGFwcERhdGEpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdW1lQ29uc3VtZXIoKSBbY29uc3VtZXI6JW9dJywgY29uc3VtZXIpO1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0aWQ6IGNvbnN1bWVyLmlkLFxuXHRcdFx0XHRhcHBEYXRhOiBhcHBEYXRhXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ3Jlc3VtZUNvbnN1bWVyJywgZGF0YSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRDb25zdW1lclByZWZlcnJlZFByb2ZpbGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRDb25zdW1lclByZWZlcnJlZFByb2ZpbGUoY29uc3VtZXIsIHByb2ZpbGUpIHtcblx0XHRcdGxvZ2dlci5kZWJ1Zygnc2V0Q29uc3VtZXJQcmVmZXJyZWRQcm9maWxlKCkgW2NvbnN1bWVyOiVvXScsIGNvbnN1bWVyKTtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlkOiBjb25zdW1lci5pZCxcblx0XHRcdFx0cHJvZmlsZTogcHJvZmlsZVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdzZXRDb25zdW1lclByZWZlcnJlZFByb2ZpbGUnLCBkYXRhKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2VuYWJsZUNvbnN1bWVyU3RhdHMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlbmFibGVDb25zdW1lclN0YXRzKGNvbnN1bWVyLCBpbnRlcnZhbCkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdlbmFibGVDb25zdW1lclN0YXRzKCkgW2NvbnN1bWVyOiVvXScsIGNvbnN1bWVyKTtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlkOiBjb25zdW1lci5pZCxcblx0XHRcdFx0aW50ZXJ2YWw6IGludGVydmFsXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ2VuYWJsZUNvbnN1bWVyU3RhdHMnLCBkYXRhKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc2FibGVDb25zdW1lclN0YXRzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUNvbnN1bWVyU3RhdHMoY29uc3VtZXIpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnZGlzYWJsZUNvbnN1bWVyU3RhdHMoKSBbY29uc3VtZXI6JW9dJywgY29uc3VtZXIpO1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0aWQ6IGNvbnN1bWVyLmlkXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ2Rpc2FibGVDb25zdW1lclN0YXRzJywgZGF0YSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlY2VpdmUgcmVtb3RlIHN0YXRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW90ZVN0YXRzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3RlU3RhdHMoc3RhdHMpIHtcblx0XHRcdHRoaXMuc2FmZUVtaXQoJ3N0YXRzJywgc3RhdHMpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19leGVjQ29tbWFuZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9leGVjQ29tbWFuZChjb21tYW5kLCBwcm9taXNlSG9sZGVyKSB7XG5cdFx0XHR2YXIgcHJvbWlzZSA9IHZvaWQgMDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c3dpdGNoIChjb21tYW5kLm1ldGhvZCkge1xuXHRcdFx0XHRcdGNhc2UgJ2FkZFByb2R1Y2VyJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIHByb2R1Y2VyID0gY29tbWFuZC5wcm9kdWNlcjtcblxuXG5cdFx0XHRcdFx0XHRcdHByb21pc2UgPSB0aGlzLl9leGVjQWRkUHJvZHVjZXIocHJvZHVjZXIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ3JlbW92ZVByb2R1Y2VyJzpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIF9wcm9kdWNlciA9IGNvbW1hbmQucHJvZHVjZXI7XG5cblxuXHRcdFx0XHRcdFx0XHRwcm9taXNlID0gdGhpcy5fZXhlY1JlbW92ZVByb2R1Y2VyKF9wcm9kdWNlcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAncmVwbGFjZVByb2R1Y2VyVHJhY2snOlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR2YXIgX3Byb2R1Y2VyMiA9IGNvbW1hbmQucHJvZHVjZXIsXG5cdFx0XHRcdFx0XHRcdCAgICB0cmFjayA9IGNvbW1hbmQudHJhY2s7XG5cblxuXHRcdFx0XHRcdFx0XHRwcm9taXNlID0gdGhpcy5fZXhlY1JlcGxhY2VQcm9kdWNlclRyYWNrKF9wcm9kdWNlcjIsIHRyYWNrKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdhZGRDb25zdW1lcic6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciBjb25zdW1lciA9IGNvbW1hbmQuY29uc3VtZXI7XG5cblxuXHRcdFx0XHRcdFx0XHRwcm9taXNlID0gdGhpcy5fZXhlY0FkZENvbnN1bWVyKGNvbnN1bWVyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdyZW1vdmVDb25zdW1lcic6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciBfY29uc3VtZXIgPSBjb21tYW5kLmNvbnN1bWVyO1xuXG5cblx0XHRcdFx0XHRcdFx0cHJvbWlzZSA9IHRoaXMuX2V4ZWNSZW1vdmVDb25zdW1lcihfY29uc3VtZXIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ3Jlc3RhcnRJY2UnOlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR2YXIgcmVtb3RlSWNlUGFyYW1ldGVycyA9IGNvbW1hbmQucmVtb3RlSWNlUGFyYW1ldGVycztcblxuXG5cdFx0XHRcdFx0XHRcdHByb21pc2UgPSB0aGlzLl9leGVjUmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgbWV0aG9kIFwiJyArIGNvbW1hbmQubWV0aG9kICsgJ1wiJykpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaWxsIHRoZSBnaXZlbiBQcm9taXNlIGhvbGRlci5cblx0XHRcdHByb21pc2VIb2xkZXIucHJvbWlzZSA9IHByb21pc2U7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2V4ZWNBZGRQcm9kdWNlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9leGVjQWRkUHJvZHVjZXIocHJvZHVjZXIpIHtcblx0XHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ19leGVjQWRkUHJvZHVjZXIoKScpO1xuXG5cdFx0XHR2YXIgcHJvZHVjZXJSdHBQYXJhbWV0ZXJzID0gdm9pZCAwO1xuXG5cdFx0XHQvLyBDYWxsIHRoZSBoYW5kbGVyLlxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXM0Ll9oYW5kbGVyLmFkZFByb2R1Y2VyKHByb2R1Y2VyKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKHJ0cFBhcmFtZXRlcnMpIHtcblx0XHRcdFx0cHJvZHVjZXJSdHBQYXJhbWV0ZXJzID0gcnRwUGFyYW1ldGVycztcblxuXHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRpZDogcHJvZHVjZXIuaWQsXG5cdFx0XHRcdFx0a2luZDogcHJvZHVjZXIua2luZCxcblx0XHRcdFx0XHR0cmFuc3BvcnRJZDogX3RoaXM0Ll9pZCxcblx0XHRcdFx0XHRydHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdHBhdXNlZDogcHJvZHVjZXIubG9jYWxseVBhdXNlZCxcblx0XHRcdFx0XHRhcHBEYXRhOiBwcm9kdWNlci5hcHBEYXRhXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNC5zYWZlRW1pdEFzUHJvbWlzZSgnQHJlcXVlc3QnLCAnY3JlYXRlUHJvZHVjZXInLCBkYXRhKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwcm9kdWNlci5zZXRSdHBQYXJhbWV0ZXJzKHByb2R1Y2VyUnRwUGFyYW1ldGVycyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfZXhlY1JlbW92ZVByb2R1Y2VyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2V4ZWNSZW1vdmVQcm9kdWNlcihwcm9kdWNlcikge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdfZXhlY1JlbW92ZVByb2R1Y2VyKCknKTtcblxuXHRcdFx0Ly8gQ2FsbCB0aGUgaGFuZGxlci5cblx0XHRcdHJldHVybiB0aGlzLl9oYW5kbGVyLnJlbW92ZVByb2R1Y2VyKHByb2R1Y2VyKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfZXhlY1JlcGxhY2VQcm9kdWNlclRyYWNrJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2V4ZWNSZXBsYWNlUHJvZHVjZXJUcmFjayhwcm9kdWNlciwgdHJhY2spIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnX2V4ZWNSZXBsYWNlUHJvZHVjZXJUcmFjaygpJyk7XG5cblx0XHRcdC8vIENhbGwgdGhlIGhhbmRsZXIuXG5cdFx0XHRyZXR1cm4gdGhpcy5faGFuZGxlci5yZXBsYWNlUHJvZHVjZXJUcmFjayhwcm9kdWNlciwgdHJhY2spO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19leGVjQWRkQ29uc3VtZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZXhlY0FkZENvbnN1bWVyKGNvbnN1bWVyKSB7XG5cdFx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdfZXhlY0FkZENvbnN1bWVyKCknKTtcblxuXHRcdFx0dmFyIGNvbnN1bWVyVHJhY2sgPSB2b2lkIDA7XG5cblx0XHRcdC8vIENhbGwgdGhlIGhhbmRsZXIuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczUuX2hhbmRsZXIuYWRkQ29uc3VtZXIoY29uc3VtZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdFx0Y29uc3VtZXJUcmFjayA9IHRyYWNrO1xuXG5cdFx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRcdGlkOiBjb25zdW1lci5pZCxcblx0XHRcdFx0XHR0cmFuc3BvcnRJZDogX3RoaXM1LmlkLFxuXHRcdFx0XHRcdHBhdXNlZDogY29uc3VtZXIubG9jYWxseVBhdXNlZCxcblx0XHRcdFx0XHRwcmVmZXJyZWRQcm9maWxlOiBjb25zdW1lci5wcmVmZXJyZWRQcm9maWxlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNS5zYWZlRW1pdEFzUHJvbWlzZSgnQHJlcXVlc3QnLCAnZW5hYmxlQ29uc3VtZXInLCBkYXRhKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRcdHZhciBwYXVzZWQgPSByZXNwb25zZS5wYXVzZWQsXG5cdFx0XHRcdCAgICBwcmVmZXJyZWRQcm9maWxlID0gcmVzcG9uc2UucHJlZmVycmVkUHJvZmlsZSxcblx0XHRcdFx0ICAgIGVmZmVjdGl2ZVByb2ZpbGUgPSByZXNwb25zZS5lZmZlY3RpdmVQcm9maWxlO1xuXG5cblx0XHRcdFx0aWYgKHBhdXNlZCkgY29uc3VtZXIucmVtb3RlUGF1c2UoKTtcblxuXHRcdFx0XHRpZiAocHJlZmVycmVkUHJvZmlsZSkgY29uc3VtZXIucmVtb3RlU2V0UHJlZmVycmVkUHJvZmlsZShwcmVmZXJyZWRQcm9maWxlKTtcblxuXHRcdFx0XHRpZiAoZWZmZWN0aXZlUHJvZmlsZSkgY29uc3VtZXIucmVtb3RlRWZmZWN0aXZlUHJvZmlsZUNoYW5nZWQoZWZmZWN0aXZlUHJvZmlsZSk7XG5cblx0XHRcdFx0cmV0dXJuIGNvbnN1bWVyVHJhY2s7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfZXhlY1JlbW92ZUNvbnN1bWVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2V4ZWNSZW1vdmVDb25zdW1lcihjb25zdW1lcikge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdfZXhlY1JlbW92ZUNvbnN1bWVyKCknKTtcblxuXHRcdFx0Ly8gQ2FsbCB0aGUgaGFuZGxlci5cblx0XHRcdHJldHVybiB0aGlzLl9oYW5kbGVyLnJlbW92ZUNvbnN1bWVyKGNvbnN1bWVyKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfZXhlY1Jlc3RhcnRJY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZXhlY1Jlc3RhcnRJY2UocmVtb3RlSWNlUGFyYW1ldGVycykge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdfZXhlY1Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0XHQvLyBDYWxsIHRoZSBoYW5kbGVyLlxuXHRcdFx0cmV0dXJuIHRoaXMuX2hhbmRsZXIucmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdpZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFdoZXRoZXIgdGhlIFRyYW5zcG9ydCBpcyBjbG9zZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjbG9zZWQnLFxuXHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVHJhbnNwb3J0IGRpcmVjdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlyZWN0aW9uJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kaXJlY3Rpb247XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7QW55fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXBwRGF0YScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYXBwRGF0YTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ29ubmVjdGlvbiBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY29ubmVjdGlvblN0YXRlJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jb25uZWN0aW9uU3RhdGU7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFRyYW5zcG9ydDtcbn0oX0VuaGFuY2VkRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNwb3J0OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEVycm9yIHByb2R1Y2VkIHdoZW4gY2FsbGluZyBhIG1ldGhvZCBpbiBhbiBpbnZhbGlkIHN0YXRlLlxuICovXG52YXIgSW52YWxpZFN0YXRlRXJyb3IgPSBleHBvcnRzLkludmFsaWRTdGF0ZUVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuXHRfaW5oZXJpdHMoSW52YWxpZFN0YXRlRXJyb3IsIF9FcnJvcik7XG5cblx0ZnVuY3Rpb24gSW52YWxpZFN0YXRlRXJyb3IobWVzc2FnZSkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnZhbGlkU3RhdGVFcnJvcik7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSW52YWxpZFN0YXRlRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbnZhbGlkU3RhdGVFcnJvcikpLmNhbGwodGhpcywgbWVzc2FnZSkpO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAnbmFtZScsIHtcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6ICdJbnZhbGlkU3RhdGVFcnJvcidcblx0XHR9KTtcblxuXHRcdGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkgLy8gSnVzdCBpbiBWOC5cblx0XHRcdHtcblx0XHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIEludmFsaWRTdGF0ZUVycm9yKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICdzdGFjaycsIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFja1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdHJldHVybiBJbnZhbGlkU3RhdGVFcnJvcjtcbn0oRXJyb3IpO1xuXG4vKipcbiAqIEVycm9yIHByb2R1Y2VkIHdoZW4gYSBQcm9taXNlIGlzIHJlamVjdGVkIGR1ZSB0byBhIHRpbWVvdXQuXG4gKi9cblxuXG52YXIgVGltZW91dEVycm9yID0gZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBmdW5jdGlvbiAoX0Vycm9yMikge1xuXHRfaW5oZXJpdHMoVGltZW91dEVycm9yLCBfRXJyb3IyKTtcblxuXHRmdW5jdGlvbiBUaW1lb3V0RXJyb3IobWVzc2FnZSkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lb3V0RXJyb3IpO1xuXG5cdFx0dmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUaW1lb3V0RXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lb3V0RXJyb3IpKS5jYWxsKHRoaXMsIG1lc3NhZ2UpKTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpczIsICduYW1lJywge1xuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogJ1RpbWVvdXRFcnJvcidcblx0XHR9KTtcblxuXHRcdGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkgLy8gSnVzdCBpbiBWOC5cblx0XHRcdHtcblx0XHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMyLCBUaW1lb3V0RXJyb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpczIsICdzdGFjaycsIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFja1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBfdGhpczI7XG5cdH1cblxuXHRyZXR1cm4gVGltZW91dEVycm9yO1xufShFcnJvcik7XG5cbi8qKlxuICogRXJyb3IgaW5kaWNhdGluZyBub3Qgc3VwcG9ydCBmb3Igc29tZXRoaW5nLlxuICovXG5cblxudmFyIFVuc3VwcG9ydGVkRXJyb3IgPSBleHBvcnRzLlVuc3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiAoX0Vycm9yMykge1xuXHRfaW5oZXJpdHMoVW5zdXBwb3J0ZWRFcnJvciwgX0Vycm9yMyk7XG5cblx0ZnVuY3Rpb24gVW5zdXBwb3J0ZWRFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVuc3VwcG9ydGVkRXJyb3IpO1xuXG5cdFx0dmFyIF90aGlzMyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChVbnN1cHBvcnRlZEVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVW5zdXBwb3J0ZWRFcnJvcikpLmNhbGwodGhpcywgbWVzc2FnZSkpO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzMywgJ25hbWUnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiAnVW5zdXBwb3J0ZWRFcnJvcidcblx0XHR9KTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpczMsICdkYXRhJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiBkYXRhXG5cdFx0fSk7XG5cblx0XHRpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIC8vIEp1c3QgaW4gVjguXG5cdFx0XHR7XG5cdFx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzMywgVW5zdXBwb3J0ZWRFcnJvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzMywgJ3N0YWNrJywge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0XHR2YWx1ZTogbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIF90aGlzMztcblx0fVxuXG5cdHJldHVybiBVbnN1cHBvcnRlZEVycm9yO1xufShFcnJvcik7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NkcFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3NkcC10cmFuc2Zvcm0nKTtcblxudmFyIF9zZHBUcmFuc2Zvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2RwVHJhbnNmb3JtKTtcblxudmFyIF9Mb2dnZXIgPSByZXF1aXJlKCcuLi9Mb2dnZXInKTtcblxudmFyIF9Mb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTG9nZ2VyKTtcblxudmFyIF9FbmhhbmNlZEV2ZW50RW1pdHRlcjIgPSByZXF1aXJlKCcuLi9FbmhhbmNlZEV2ZW50RW1pdHRlcicpO1xuXG52YXIgX0VuaGFuY2VkRXZlbnRFbWl0dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VuaGFuY2VkRXZlbnRFbWl0dGVyMik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX29ydGMgPSByZXF1aXJlKCcuLi9vcnRjJyk7XG5cbnZhciBvcnRjID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX29ydGMpO1xuXG52YXIgX2NvbW1vblV0aWxzID0gcmVxdWlyZSgnLi9zZHAvY29tbW9uVXRpbHMnKTtcblxudmFyIHNkcENvbW1vblV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvbW1vblV0aWxzKTtcblxudmFyIF9wbGFuQlV0aWxzID0gcmVxdWlyZSgnLi9zZHAvcGxhbkJVdGlscycpO1xuXG52YXIgc2RwUGxhbkJVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9wbGFuQlV0aWxzKTtcblxudmFyIF9SZW1vdGVQbGFuQlNkcCA9IHJlcXVpcmUoJy4vc2RwL1JlbW90ZVBsYW5CU2RwJyk7XG5cbnZhciBfUmVtb3RlUGxhbkJTZHAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVtb3RlUGxhbkJTZHApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBsb2dnZXIgPSBuZXcgX0xvZ2dlcjIuZGVmYXVsdCgnQ2hyb21lNTUnKTtcblxudmFyIEhhbmRsZXIgPSBmdW5jdGlvbiAoX0VuaGFuY2VkRXZlbnRFbWl0dGVyKSB7XG5cdF9pbmhlcml0cyhIYW5kbGVyLCBfRW5oYW5jZWRFdmVudEVtaXR0ZXIpO1xuXG5cdGZ1bmN0aW9uIEhhbmRsZXIoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIYW5kbGVyKTtcblxuXHRcdC8vIFJUQ1BlZXJDb25uZWN0aW9uIGluc3RhbmNlLlxuXHRcdC8vIEB0eXBlIHtSVENQZWVyQ29ubmVjdGlvbn1cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSGFuZGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEhhbmRsZXIpKS5jYWxsKHRoaXMsIGxvZ2dlcikpO1xuXG5cdFx0X3RoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcblx0XHRcdGljZVNlcnZlcnM6IHNldHRpbmdzLnR1cm5TZXJ2ZXJzIHx8IFtdLFxuXHRcdFx0aWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcblx0XHRcdGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuXHRcdFx0cnRjcE11eFBvbGljeTogJ3JlcXVpcmUnXG5cdFx0fSk7XG5cblx0XHQvLyBHZW5lcmljIHNlbmRpbmcgUlRQIHBhcmFtZXRlcnMgZm9yIGF1ZGlvIGFuZCB2aWRlby5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdF90aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kID0gcnRwUGFyYW1ldGVyc0J5S2luZDtcblxuXHRcdC8vIFJlbW90ZSBTRFAgaGFuZGxlci5cblx0XHQvLyBAdHlwZSB7UmVtb3RlUGxhbkJTZHB9XG5cdFx0X3RoaXMuX3JlbW90ZVNkcCA9IG5ldyBfUmVtb3RlUGxhbkJTZHAyLmRlZmF1bHQoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kKTtcblxuXHRcdC8vIEhhbmRsZSBSVENQZWVyQ29ubmVjdGlvbiBjb25uZWN0aW9uIHN0YXR1cy5cblx0XHRfdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0c3dpdGNoIChfdGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgJ2NoZWNraW5nJzpcblx0XHRcdFx0XHRfdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnY29ubmVjdGVkJzpcblx0XHRcdFx0Y2FzZSAnY29tcGxldGVkJzpcblx0XHRcdFx0XHRfdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdF90aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG5cdFx0XHRcdFx0X3RoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnY2xvc2VkJzpcblx0XHRcdFx0XHRfdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhIYW5kbGVyLCBbe1xuXHRcdGtleTogJ2Nsb3NlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcblxuXHRcdFx0Ly8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9wYy5jbG9zZSgpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHt9XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEhhbmRsZXI7XG59KF9FbmhhbmNlZEV2ZW50RW1pdHRlcjMuZGVmYXVsdCk7XG5cbnZhciBTZW5kSGFuZGxlciA9IGZ1bmN0aW9uIChfSGFuZGxlcikge1xuXHRfaW5oZXJpdHMoU2VuZEhhbmRsZXIsIF9IYW5kbGVyKTtcblxuXHRmdW5jdGlvbiBTZW5kSGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZW5kSGFuZGxlcik7XG5cblx0XHQvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNlbmRIYW5kbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2VuZEhhbmRsZXIpKS5jYWxsKHRoaXMsICdzZW5kJywgcnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpKTtcblxuXHRcdF90aGlzMi5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcblxuXHRcdC8vIExvY2FsIHN0cmVhbS5cblx0XHQvLyBAdHlwZSB7TWVkaWFTdHJlYW19XG5cdFx0X3RoaXMyLl9zdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcblx0XHRyZXR1cm4gX3RoaXMyO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFNlbmRIYW5kbGVyLCBbe1xuXHRcdGtleTogJ2FkZFByb2R1Y2VyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkUHJvZHVjZXIocHJvZHVjZXIpIHtcblx0XHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0XHR2YXIgdHJhY2sgPSBwcm9kdWNlci50cmFjaztcblxuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsIHByb2R1Y2VyLmlkLCBwcm9kdWNlci5raW5kLCB0cmFjay5pZCk7XG5cblx0XHRcdGlmICh0aGlzLl9zdHJlYW0uZ2V0VHJhY2tCeUlkKHRyYWNrLmlkKSkgcmV0dXJuIFByb21pc2UucmVqZWN0KCd0cmFjayBhbHJlYWR5IGFkZGVkJyk7XG5cblx0XHRcdHZhciBsb2NhbFNkcE9iaiA9IHZvaWQgMDtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBBZGQgdGhlIHRyYWNrIHRvIHRoZSBsb2NhbCBzdHJlYW0uXG5cdFx0XHRcdF90aGlzMy5fc3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIHN0cmVhbSB0byB0aGUgUGVlckNvbm5lY3Rpb24uXG5cdFx0XHRcdF90aGlzMy5fcGMuYWRkU3RyZWFtKF90aGlzMy5fc3RyZWFtKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMzLl9wYy5jcmVhdGVPZmZlcigpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAob2ZmZXIpIHtcblx0XHRcdFx0Ly8gSWYgc2ltdWxjYXN0IGlzIHNldCwgbWFuZ2xlIHRoZSBvZmZlci5cblx0XHRcdFx0aWYgKHByb2R1Y2VyLnNpbXVsY2FzdCkge1xuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSB8IGVuYWJsaW5nIHNpbXVsY2FzdCcpO1xuXG5cdFx0XHRcdFx0dmFyIHNkcE9iamVjdCA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2Uob2ZmZXIuc2RwKTtcblxuXHRcdFx0XHRcdHNkcFBsYW5CVXRpbHMuYWRkU2ltdWxjYXN0Rm9yVHJhY2soc2RwT2JqZWN0LCB0cmFjayk7XG5cblx0XHRcdFx0XHR2YXIgb2ZmZXJTZHAgPSBfc2RwVHJhbnNmb3JtMi5kZWZhdWx0LndyaXRlKHNkcE9iamVjdCk7XG5cblx0XHRcdFx0XHRvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBvZmZlclNkcCB9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIV90aGlzMy5fdHJhbnNwb3J0UmVhZHkpIHJldHVybiBfdGhpczMuX3NldHVwVHJhbnNwb3J0KCk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bG9jYWxTZHBPYmogPSBfc2RwVHJhbnNmb3JtMi5kZWZhdWx0LnBhcnNlKF90aGlzMy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuXG5cdFx0XHRcdHZhciByZW1vdGVTZHAgPSBfdGhpczMuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHR2YXIgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZShfdGhpczMuX3J0cFBhcmFtZXRlcnNCeUtpbmRbcHJvZHVjZXIua2luZF0pO1xuXG5cdFx0XHRcdC8vIEZpbGwgdGhlIFJUUCBwYXJhbWV0ZXJzIGZvciB0aGlzIHRyYWNrLlxuXHRcdFx0XHRzZHBQbGFuQlV0aWxzLmZpbGxSdHBQYXJhbWV0ZXJzRm9yVHJhY2socnRwUGFyYW1ldGVycywgbG9jYWxTZHBPYmosIHRyYWNrKTtcblxuXHRcdFx0XHRyZXR1cm4gcnRwUGFyYW1ldGVycztcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHQvLyBQYW5pYyBoZXJlLiBUcnkgdG8gdW5kbyB0aGluZ3MuXG5cblx0XHRcdFx0X3RoaXMzLl9zdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuXHRcdFx0XHRfdGhpczMuX3BjLmFkZFN0cmVhbShfdGhpczMuX3N0cmVhbSk7XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVQcm9kdWNlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVByb2R1Y2VyKHByb2R1Y2VyKSB7XG5cdFx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRcdFx0dmFyIHRyYWNrID0gcHJvZHVjZXIudHJhY2s7XG5cblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdmVQcm9kdWNlcigpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLCBwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgdHJhY2sgZnJvbSB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHRfdGhpczQuX3N0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBzdHJlYW0gdG8gdGhlIFBlZXJDb25uZWN0aW9uLlxuXHRcdFx0XHRfdGhpczQuX3BjLmFkZFN0cmVhbShfdGhpczQuX3N0cmVhbSk7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNC5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNC5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0Ly8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcblx0XHRcdFx0Ly8gXCJGYWlsZWQgdG8gY3JlYXRlIGNoYW5uZWxzXCIuIElmIHNvLCBpZ25vcmUgaXQuXG5cdFx0XHRcdGlmIChfdGhpczQuX3N0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRsb2dnZXIud2FybigncmVtb3ZlUHJvZHVjZXIoKSB8IGlnbm9yaW5nIGV4cGVjdGVkIGVycm9yIGR1ZSBubyBzZW5kaW5nIHRyYWNrczogJXMnLCBlcnJvci50b1N0cmluZygpKTtcblxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChfdGhpczQuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykgcmV0dXJuO1xuXG5cdFx0XHRcdHZhciBsb2NhbFNkcE9iaiA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2UoX3RoaXM0Ll9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cdFx0XHRcdHZhciByZW1vdGVTZHAgPSBfdGhpczQuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHR2YXIgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZVByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczQuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlUHJvZHVjZXJUcmFjaycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VQcm9kdWNlclRyYWNrKHByb2R1Y2VyLCB0cmFjaykge1xuXHRcdFx0dmFyIF90aGlzNSA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVwbGFjZVByb2R1Y2VyVHJhY2soKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJywgcHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdFx0dmFyIG9sZFRyYWNrID0gcHJvZHVjZXIudHJhY2s7XG5cdFx0XHR2YXIgbG9jYWxTZHBPYmogPSB2b2lkIDA7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBvbGQgdHJhY2sgZnJvbSB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHRfdGhpczUuX3N0cmVhbS5yZW1vdmVUcmFjayhvbGRUcmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBuZXcgdHJhY2sgdG8gdGhlIGxvY2FsIHN0cmVhbS5cblx0XHRcdFx0X3RoaXM1Ll9zdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgc3RyZWFtIHRvIHRoZSBQZWVyQ29ubmVjdGlvbi5cblx0XHRcdFx0X3RoaXM1Ll9wYy5hZGRTdHJlYW0oX3RoaXM1Ll9zdHJlYW0pO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczUuX3BjLmNyZWF0ZU9mZmVyKCk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChvZmZlcikge1xuXHRcdFx0XHQvLyBJZiBzaW11bGNhc3QgaXMgc2V0LCBtYW5nbGUgdGhlIG9mZmVyLlxuXHRcdFx0XHRpZiAocHJvZHVjZXIuc2ltdWxjYXN0KSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRQcm9kdWNlcigpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG5cblx0XHRcdFx0XHR2YXIgc2RwT2JqZWN0ID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShvZmZlci5zZHApO1xuXG5cdFx0XHRcdFx0c2RwUGxhbkJVdGlscy5hZGRTaW11bGNhc3RGb3JUcmFjayhzZHBPYmplY3QsIHRyYWNrKTtcblxuXHRcdFx0XHRcdHZhciBvZmZlclNkcCA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQud3JpdGUoc2RwT2JqZWN0KTtcblxuXHRcdFx0XHRcdG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IG9mZmVyU2RwIH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlcGxhY2VQcm9kdWNlclRyYWNrKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczUuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGxvY2FsU2RwT2JqID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShfdGhpczUuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblxuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXM1Ll9yZW1vdGVTZHAuY3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKTtcblx0XHRcdFx0dmFyIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXBsYWNlUHJvZHVjZXJUcmFjaygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXM1Ll9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBydHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUoX3RoaXM1Ll9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhlIG5ldyB0cmFjay5cblx0XHRcdFx0c2RwUGxhbkJVdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0Ly8gV2UgbmVlZCB0byBwcm92aWRlIG5ldyBSVFAgcGFyYW1ldGVycy5cblx0XHRcdFx0X3RoaXM1LnNhZmVFbWl0KCdAbmVlZHVwZGF0ZXByb2R1Y2VyJywgcHJvZHVjZXIsIHJ0cFBhcmFtZXRlcnMpO1xuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdC8vIFBhbmljIGhlcmUuIFRyeSB0byB1bmRvIHRoaW5ncy5cblxuXHRcdFx0XHRfdGhpczUuX3N0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cdFx0XHRcdF90aGlzNS5fc3RyZWFtLmFkZFRyYWNrKG9sZFRyYWNrKTtcblx0XHRcdFx0X3RoaXM1Ll9wYy5hZGRTdHJlYW0oX3RoaXM1Ll9zdHJlYW0pO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncmVzdGFydEljZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlc3RhcnRJY2UocmVtb3RlSWNlUGFyYW1ldGVycykge1xuXHRcdFx0dmFyIF90aGlzNiA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG5cdFx0XHR0aGlzLl9yZW1vdGVTZHAudXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycyhyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXM2Ll9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChvZmZlcikge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNi5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGxvY2FsU2RwT2JqID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShfdGhpczYuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblx0XHRcdFx0dmFyIHJlbW90ZVNkcCA9IF90aGlzNi5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdHZhciBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXM2Ll9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3NldHVwVHJhbnNwb3J0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3NldHVwVHJhbnNwb3J0KCkge1xuXHRcdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnX3NldHVwVHJhbnNwb3J0KCknKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cblx0XHRcdFx0dmFyIHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHt9O1xuXHRcdFx0XHR2YXIgc2RwID0gX3RoaXM3Ll9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcDtcblx0XHRcdFx0dmFyIHNkcE9iaiA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2Uoc2RwKTtcblx0XHRcdFx0dmFyIGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHNkcE9iaik7XG5cblx0XHRcdFx0Ly8gTGV0J3MgZGVjaWRlIHRoYXQgd2UnbGwgYmUgRFRMUyBzZXJ2ZXIgKGJlY2F1c2Ugd2UgY2FuKS5cblx0XHRcdFx0ZHRsc1BhcmFtZXRlcnMucm9sZSA9ICdzZXJ2ZXInO1xuXG5cdFx0XHRcdHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycy5kdGxzUGFyYW1ldGVycyA9IGR0bHNQYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRfdGhpczcuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRMb2NhbFBhcmFtZXRlcnModHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHQvLyBXZSBuZWVkIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0cmV0dXJuIF90aGlzNy5zYWZlRW1pdEFzUHJvbWlzZSgnQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykge1xuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdF90aGlzNy5fcmVtb3RlU2RwLnNldFRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnModHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0X3RoaXM3Ll90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gU2VuZEhhbmRsZXI7XG59KEhhbmRsZXIpO1xuXG52YXIgUmVjdkhhbmRsZXIgPSBmdW5jdGlvbiAoX0hhbmRsZXIyKSB7XG5cdF9pbmhlcml0cyhSZWN2SGFuZGxlciwgX0hhbmRsZXIyKTtcblxuXHRmdW5jdGlvbiBSZWN2SGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWN2SGFuZGxlcik7XG5cblx0XHQvLyBHb3QgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHZhciBfdGhpczggPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmVjdkhhbmRsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSZWN2SGFuZGxlcikpLmNhbGwodGhpcywgJ3JlY3YnLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncykpO1xuXG5cdFx0X3RoaXM4Ll90cmFuc3BvcnRDcmVhdGVkID0gZmFsc2U7XG5cblx0XHQvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0X3RoaXM4Ll90cmFuc3BvcnRVcGRhdGVkID0gZmFsc2U7XG5cblx0XHQvLyBTZWVuIG1lZGlhIGtpbmRzLlxuXHRcdC8vIEB0eXBlIHtTZXQ8U3RyaW5nPn1cblx0XHRfdGhpczguX2tpbmRzID0gbmV3IFNldCgpO1xuXG5cdFx0Ly8gTWFwIG9mIENvbnN1bWVycyBpbmZvcm1hdGlvbiBpbmRleGVkIGJ5IGNvbnN1bWVyLmlkLlxuXHRcdC8vIC0ga2luZCB7U3RyaW5nfVxuXHRcdC8vIC0gdHJhY2tJZCB7U3RyaW5nfVxuXHRcdC8vIC0gc3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gcnR4U3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gY25hbWUge1N0cmluZ31cblx0XHQvLyBAdHlwZSB7TWFwPE51bWJlciwgT2JqZWN0Pn1cblx0XHRfdGhpczguX2NvbnN1bWVySW5mb3MgPSBuZXcgTWFwKCk7XG5cdFx0cmV0dXJuIF90aGlzODtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhSZWN2SGFuZGxlciwgW3tcblx0XHRrZXk6ICdhZGRDb25zdW1lcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZENvbnN1bWVyKGNvbnN1bWVyKSB7XG5cdFx0XHR2YXIgX3RoaXM5ID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRDb25zdW1lcigpIFtpZDolcywga2luZDolc10nLCBjb25zdW1lci5pZCwgY29uc3VtZXIua2luZCk7XG5cblx0XHRcdGlmICh0aGlzLl9jb25zdW1lckluZm9zLmhhcyhjb25zdW1lci5pZCkpIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ29uc3VtZXIgYWxyZWFkeSBhZGRlZCcpO1xuXG5cdFx0XHR2YXIgZW5jb2RpbmcgPSBjb25zdW1lci5ydHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcblx0XHRcdHZhciBjbmFtZSA9IGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZTtcblx0XHRcdHZhciBjb25zdW1lckluZm8gPSB7XG5cdFx0XHRcdGtpbmQ6IGNvbnN1bWVyLmtpbmQsXG5cdFx0XHRcdHRyYWNrSWQ6ICdjb25zdW1lci0nICsgY29uc3VtZXIua2luZCArICctJyArIGNvbnN1bWVyLmlkLFxuXHRcdFx0XHRzc3JjOiBlbmNvZGluZy5zc3JjLFxuXHRcdFx0XHRjbmFtZTogY25hbWVcblx0XHRcdH07XG5cblx0XHRcdGlmIChlbmNvZGluZy5ydHggJiYgZW5jb2RpbmcucnR4LnNzcmMpIGNvbnN1bWVySW5mby5ydHhTc3JjID0gZW5jb2RpbmcucnR4LnNzcmM7XG5cblx0XHRcdHRoaXMuX2NvbnN1bWVySW5mb3Muc2V0KGNvbnN1bWVyLmlkLCBjb25zdW1lckluZm8pO1xuXHRcdFx0dGhpcy5fa2luZHMuYWRkKGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICghX3RoaXM5Ll90cmFuc3BvcnRDcmVhdGVkKSByZXR1cm4gX3RoaXM5Ll9zZXR1cFRyYW5zcG9ydCgpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciByZW1vdGVTZHAgPSBfdGhpczkuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChBcnJheS5mcm9tKF90aGlzOS5fa2luZHMpLCBBcnJheS5mcm9tKF90aGlzOS5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHR2YXIgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzOS5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczkuX3BjLmNyZWF0ZUFuc3dlcigpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoYW5zd2VyKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXM5Ll9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCFfdGhpczkuX3RyYW5zcG9ydFVwZGF0ZWQpIHJldHVybiBfdGhpczkuX3VwZGF0ZVRyYW5zcG9ydCgpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBzdHJlYW0gPSBfdGhpczkuX3BjLmdldFJlbW90ZVN0cmVhbXMoKVswXTtcblx0XHRcdFx0dmFyIHRyYWNrID0gc3RyZWFtLmdldFRyYWNrQnlJZChjb25zdW1lckluZm8udHJhY2tJZCk7XG5cblx0XHRcdFx0aWYgKCF0cmFjaykgdGhyb3cgbmV3IEVycm9yKCdyZW1vdGUgdHJhY2sgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0cmV0dXJuIHRyYWNrO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQ29uc3VtZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDb25zdW1lcihjb25zdW1lcikge1xuXHRcdFx0dmFyIF90aGlzMTAgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZUNvbnN1bWVyKCkgW2lkOiVzLCBraW5kOiVzXScsIGNvbnN1bWVyLmlkLCBjb25zdW1lci5raW5kKTtcblxuXHRcdFx0aWYgKCF0aGlzLl9jb25zdW1lckluZm9zLmhhcyhjb25zdW1lci5pZCkpIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ29uc3VtZXIgbm90IGZvdW5kJyk7XG5cblx0XHRcdHRoaXMuX2NvbnN1bWVySW5mb3MuZGVsZXRlKGNvbnN1bWVyLmlkKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXMxMC5fcmVtb3RlU2RwLmNyZWF0ZU9mZmVyU2RwKEFycmF5LmZyb20oX3RoaXMxMC5fa2luZHMpLCBBcnJheS5mcm9tKF90aGlzMTAuX2NvbnN1bWVySW5mb3MudmFsdWVzKCkpKTtcblx0XHRcdFx0dmFyIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczEwLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzMTAuX3BjLmNyZWF0ZUFuc3dlcigpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoYW5zd2VyKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMxMC5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncmVzdGFydEljZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlc3RhcnRJY2UocmVtb3RlSWNlUGFyYW1ldGVycykge1xuXHRcdFx0dmFyIF90aGlzMTEgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuXHRcdFx0dGhpcy5fcmVtb3RlU2RwLnVwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMocmVtb3RlSWNlUGFyYW1ldGVycyk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHJlbW90ZVNkcCA9IF90aGlzMTEuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChBcnJheS5mcm9tKF90aGlzMTEuX2tpbmRzKSwgQXJyYXkuZnJvbShfdGhpczExLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdHZhciBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczExLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzMTEuX3BjLmNyZWF0ZUFuc3dlcigpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoYW5zd2VyKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczExLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfc2V0dXBUcmFuc3BvcnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBUcmFuc3BvcnQoKSB7XG5cdFx0XHR2YXIgX3RoaXMxMiA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnX3NldHVwVHJhbnNwb3J0KCknKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBXZSBuZWVkIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0cmV0dXJuIF90aGlzMTIuc2FmZUVtaXRBc1Byb21pc2UoJ0BuZWVkY3JlYXRldHJhbnNwb3J0JywgbnVsbCk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0X3RoaXMxMi5fcmVtb3RlU2RwLnNldFRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnModHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0X3RoaXMxMi5fdHJhbnNwb3J0Q3JlYXRlZCA9IHRydWU7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfdXBkYXRlVHJhbnNwb3J0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVRyYW5zcG9ydCgpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnX3VwZGF0ZVRyYW5zcG9ydCgpJyk7XG5cblx0XHRcdC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuXHRcdFx0Ly8gY29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0XHR2YXIgc2RwID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cdFx0XHR2YXIgc2RwT2JqID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShzZHApO1xuXHRcdFx0dmFyIGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHNkcE9iaik7XG5cdFx0XHR2YXIgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0geyBkdGxzUGFyYW1ldGVyczogZHRsc1BhcmFtZXRlcnMgfTtcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBwcm92aWRlIHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLlxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5lZWR1cGRhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXG5cdFx0XHR0aGlzLl90cmFuc3BvcnRVcGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gUmVjdkhhbmRsZXI7XG59KEhhbmRsZXIpO1xuXG52YXIgQ2hyb21lNTUgPSBmdW5jdGlvbiAoKSB7XG5cdF9jcmVhdGVDbGFzcyhDaHJvbWU1NSwgbnVsbCwgW3tcblx0XHRrZXk6ICdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG5cblx0XHRcdHZhciBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG5cdFx0XHRcdGljZVNlcnZlcnM6IFtdLFxuXHRcdFx0XHRpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuXHRcdFx0XHRidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcblx0XHRcdFx0cnRjcE11eFBvbGljeTogJ3JlcXVpcmUnXG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHBjLmNyZWF0ZU9mZmVyKHtcblx0XHRcdFx0b2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcblx0XHRcdFx0b2ZmZXJUb1JlY2VpdmVWaWRlbzogdHJ1ZVxuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAob2ZmZXIpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwYy5jbG9zZSgpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge31cblxuXHRcdFx0XHR2YXIgc2RwT2JqID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShvZmZlci5zZHApO1xuXHRcdFx0XHR2YXIgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyhzZHBPYmopO1xuXG5cdFx0XHRcdHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwYy5jbG9zZSgpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcjIpIHt9XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICduYW1lJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiAnQ2hyb21lNTUnO1xuXHRcdH1cblx0fV0pO1xuXG5cdGZ1bmN0aW9uIENocm9tZTU1KGRpcmVjdGlvbiwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIENocm9tZTU1KTtcblxuXHRcdGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSBbZGlyZWN0aW9uOiVzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllczolb10nLCBkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdHZhciBydHBQYXJhbWV0ZXJzQnlLaW5kID0gdm9pZCAwO1xuXG5cdFx0c3dpdGNoIChkaXJlY3Rpb24pIHtcblx0XHRcdGNhc2UgJ3NlbmQnOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcblx0XHRcdFx0XHRcdGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0XHRcdHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFNlbmRIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAncmVjdic6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRydHBQYXJhbWV0ZXJzQnlLaW5kID0ge1xuXHRcdFx0XHRcdFx0YXVkaW86IG9ydGMuZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuXHRcdFx0XHRcdFx0dmlkZW86IG9ydGMuZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVjdkhhbmRsZXIocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXHRcdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIENocm9tZTU1O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDaHJvbWU1NTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfTG9nZ2VyID0gcmVxdWlyZSgnLi4vTG9nZ2VyJyk7XG5cbnZhciBfTG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xvZ2dlcik7XG5cbnZhciBfRW5oYW5jZWRFdmVudEVtaXR0ZXIyID0gcmVxdWlyZSgnLi4vRW5oYW5jZWRFdmVudEVtaXR0ZXInKTtcblxudmFyIF9FbmhhbmNlZEV2ZW50RW1pdHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbmhhbmNlZEV2ZW50RW1pdHRlcjIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxudmFyIF9vcnRjID0gcmVxdWlyZSgnLi4vb3J0YycpO1xuXG52YXIgb3J0YyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9vcnRjKTtcblxudmFyIF9lZGdlVXRpbHMgPSByZXF1aXJlKCcuL29ydGMvZWRnZVV0aWxzJyk7XG5cbnZhciBlZGdlVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZWRnZVV0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKiBnbG9iYWwgUlRDSWNlR2F0aGVyZXIsIFJUQ0ljZVRyYW5zcG9ydCwgUlRDRHRsc1RyYW5zcG9ydCwgUlRDUnRwUmVjZWl2ZXIsIFJUQ1J0cFNlbmRlciAqL1xuXG52YXIgQ05BTUUgPSAnQ05BTUUtRURHRS0nICsgdXRpbHMucmFuZG9tTnVtYmVyKCk7XG5cbnZhciBsb2dnZXIgPSBuZXcgX0xvZ2dlcjIuZGVmYXVsdCgnRWRnZTExJyk7XG5cbnZhciBFZGdlMTEgPSBmdW5jdGlvbiAoX0VuaGFuY2VkRXZlbnRFbWl0dGVyKSB7XG5cdF9pbmhlcml0cyhFZGdlMTEsIF9FbmhhbmNlZEV2ZW50RW1pdHRlcik7XG5cblx0X2NyZWF0ZUNsYXNzKEVkZ2UxMSwgbnVsbCwgW3tcblx0XHRrZXk6ICdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG5cblx0XHRcdHJldHVybiBlZGdlVXRpbHMuZ2V0Q2FwYWJpbGl0aWVzKCk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnbmFtZScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gJ0VkZ2UxMSc7XG5cdFx0fVxuXHR9XSk7XG5cblx0ZnVuY3Rpb24gRWRnZTExKGRpcmVjdGlvbiwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2UxMSk7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRWRnZTExLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRWRnZTExKSkuY2FsbCh0aGlzLCBsb2dnZXIpKTtcblxuXHRcdGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSBbZGlyZWN0aW9uOiVzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllczolb10nLCBkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdC8vIEdlbmVyaWMgc2VuZGluZyBSVFAgcGFyYW1ldGVycyBmb3IgYXVkaW8gYW5kIHZpZGVvLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0X3RoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG5cdFx0XHRhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG5cdFx0XHR2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcblx0XHR9O1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0X3RoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG5cblx0XHQvLyBJQ0UgZ2F0aGVyZXIuXG5cdFx0X3RoaXMuX2ljZUdhdGhlcmVyID0gbnVsbDtcblxuXHRcdC8vIElDRSB0cmFuc3BvcnQuXG5cdFx0X3RoaXMuX2ljZVRyYW5zcG9ydCA9IG51bGw7XG5cblx0XHQvLyBEVExTIHRyYW5zcG9ydC5cblx0XHQvLyBAdHlwZSB7UlRDRHRsc1RyYW5zcG9ydH1cblx0XHRfdGhpcy5fZHRsc1RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHQvLyBNYXAgb2YgUlRDUnRwU2VuZGVycyBpbmRleGVkIGJ5IFByb2R1Y2VyLmlkLlxuXHRcdC8vIEB0eXBlIHtNYXA8TnVtYmVyLCBSVENSdHBTZW5kZXJ9XG5cdFx0X3RoaXMuX3J0cFNlbmRlcnMgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBNYXAgb2YgUlRDUnRwUmVjZWl2ZXJzIGluZGV4ZWQgYnkgQ29uc3VtZXIuaWQuXG5cdFx0Ly8gQHR5cGUge01hcDxOdW1iZXIsIFJUQ1J0cFJlY2VpdmVyfVxuXHRcdF90aGlzLl9ydHBSZWNlaXZlcnMgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBSZW1vdGUgVHJhbnNwb3J0IHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHRfdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyA9IG51bGw7XG5cblx0XHRfdGhpcy5fc2V0SWNlR2F0aGVyZXIoc2V0dGluZ3MpO1xuXHRcdF90aGlzLl9zZXRJY2VUcmFuc3BvcnQoKTtcblx0XHRfdGhpcy5fc2V0RHRsc1RyYW5zcG9ydCgpO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhFZGdlMTEsIFt7XG5cdFx0a2V5OiAnY2xvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0XHQvLyBDbG9zZSB0aGUgSUNFIGdhdGhlcmVyLlxuXHRcdFx0Ly8gTk9URTogTm90IHlldCBpbXBsZW1lbnRlZCBieSBFZGdlLlxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5faWNlR2F0aGVyZXIuY2xvc2UoKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7fVxuXG5cdFx0XHQvLyBDbG9zZSB0aGUgSUNFIHRyYW5zcG9ydC5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX2ljZVRyYW5zcG9ydC5zdG9wKCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge31cblxuXHRcdFx0Ly8gQ2xvc2UgdGhlIERUTFMgdHJhbnNwb3J0LlxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fZHRsc1RyYW5zcG9ydC5zdG9wKCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge31cblxuXHRcdFx0Ly8gQ2xvc2UgUlRDUnRwU2VuZGVycy5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLl9ydHBTZW5kZXJzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciBydHBTZW5kZXIgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRydHBTZW5kZXIuc3RvcCgpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2xvc2UgUlRDUnRwUmVjZWl2ZXJzLlxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gdGhpcy5fcnRwUmVjZWl2ZXJzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG5cdFx0XHRcdFx0dmFyIHJ0cFJlY2VpdmVyID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHJ0cFJlY2VpdmVyLnN0b3AoKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge31cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yMiA9IGVycjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FkZFByb2R1Y2VyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkUHJvZHVjZXIocHJvZHVjZXIpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHR2YXIgdHJhY2sgPSBwcm9kdWNlci50cmFjaztcblxuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsIHByb2R1Y2VyLmlkLCBwcm9kdWNlci5raW5kLCB0cmFjay5pZCk7XG5cblx0XHRcdGlmICh0aGlzLl9ydHBTZW5kZXJzLmhhcyhwcm9kdWNlci5pZCkpIHJldHVybiBQcm9taXNlLnJlamVjdCgnUHJvZHVjZXIgYWxyZWFkeSBhZGRlZCcpO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICghX3RoaXMyLl90cmFuc3BvcnRSZWFkeSkgcmV0dXJuIF90aGlzMi5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgfCBjYWxsaW5nIG5ldyBSVENSdHBTZW5kZXIoKScpO1xuXG5cdFx0XHRcdHZhciBydHBTZW5kZXIgPSBuZXcgUlRDUnRwU2VuZGVyKHRyYWNrLCBfdGhpczIuX2R0bHNUcmFuc3BvcnQpO1xuXHRcdFx0XHR2YXIgcnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKF90aGlzMi5fcnRwUGFyYW1ldGVyc0J5S2luZFtwcm9kdWNlci5raW5kXSk7XG5cblx0XHRcdFx0Ly8gRmlsbCBSVENSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5cblx0XHRcdFx0dmFyIGVuY29kaW5nID0ge1xuXHRcdFx0XHRcdHNzcmM6IHV0aWxzLnJhbmRvbU51bWJlcigpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKHJ0cFBhcmFtZXRlcnMuY29kZWNzLnNvbWUoZnVuY3Rpb24gKGNvZGVjKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVjLm5hbWUgPT09ICdydHgnO1xuXHRcdFx0XHR9KSkge1xuXHRcdFx0XHRcdGVuY29kaW5nLnJ0eCA9IHtcblx0XHRcdFx0XHRcdHNzcmM6IHV0aWxzLnJhbmRvbU51bWJlcigpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xuXG5cdFx0XHRcdC8vIEZpbGwgUlRDUnRwUGFyYW1ldGVycy5ydGNwLlxuXHRcdFx0XHRydHBQYXJhbWV0ZXJzLnJ0Y3AgPSB7XG5cdFx0XHRcdFx0Y25hbWU6IENOQU1FLFxuXHRcdFx0XHRcdHJlZHVjZWRTaXplOiB0cnVlLFxuXHRcdFx0XHRcdG11eDogdHJ1ZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIE5PVEU6IENvbnZlcnQgb3VyIHN0YW5kYXJkIFJUQ1J0cFBhcmFtZXRlcnMgaW50byB0aG9zZSB0aGF0IEVkZ2Vcblx0XHRcdFx0Ly8gZXhwZWN0cy5cblx0XHRcdFx0dmFyIGVkZ2VSdHBQYXJhbWV0ZXJzID0gZWRnZVV0aWxzLm1hbmdsZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBydHBTZW5kZXIuc2VuZCgpIFtwYXJhbXM6JW9dJywgZWRnZVJ0cFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdHJ0cFNlbmRlci5zZW5kKGVkZ2VSdHBQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHQvLyBTdG9yZSBpdC5cblx0XHRcdFx0X3RoaXMyLl9ydHBTZW5kZXJzLnNldChwcm9kdWNlci5pZCwgcnRwU2VuZGVyKTtcblxuXHRcdFx0XHRyZXR1cm4gcnRwUGFyYW1ldGVycztcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZVByb2R1Y2VyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlUHJvZHVjZXIocHJvZHVjZXIpIHtcblx0XHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0XHR2YXIgdHJhY2sgPSBwcm9kdWNlci50cmFjaztcblxuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZVByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsIHByb2R1Y2VyLmlkLCBwcm9kdWNlci5raW5kLCB0cmFjay5pZCk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHJ0cFNlbmRlciA9IF90aGlzMy5fcnRwU2VuZGVycy5nZXQocHJvZHVjZXIuaWQpO1xuXG5cdFx0XHRcdGlmICghcnRwU2VuZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcblxuXHRcdFx0XHRfdGhpczMuX3J0cFNlbmRlcnMuZGVsZXRlKHByb2R1Y2VyLmlkKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlUHJvZHVjZXIoKSB8IGNhbGxpbmcgcnRwU2VuZGVyLnN0b3AoKScpO1xuXG5cdFx0XHRcdFx0cnRwU2VuZGVyLnN0b3AoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRsb2dnZXIud2FybigncnRwU2VuZGVyLnN0b3AoKSBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlcGxhY2VQcm9kdWNlclRyYWNrJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVByb2R1Y2VyVHJhY2socHJvZHVjZXIsIHRyYWNrKSB7XG5cdFx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXBsYWNlUHJvZHVjZXJUcmFjaygpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLCBwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBydHBTZW5kZXIgPSBfdGhpczQuX3J0cFNlbmRlcnMuZ2V0KHByb2R1Y2VyLmlkKTtcblxuXHRcdFx0XHRpZiAoIXJ0cFNlbmRlcikgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0cnRwU2VuZGVyLnNldFRyYWNrKHRyYWNrKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FkZENvbnN1bWVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkQ29uc3VtZXIoY29uc3VtZXIpIHtcblx0XHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ2FkZENvbnN1bWVyKCkgW2lkOiVzLCBraW5kOiVzXScsIGNvbnN1bWVyLmlkLCBjb25zdW1lci5raW5kKTtcblxuXHRcdFx0aWYgKHRoaXMuX3J0cFJlY2VpdmVycy5oYXMoY29uc3VtZXIuaWQpKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NvbnN1bWVyIGFscmVhZHkgYWRkZWQnKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgfCBjYWxsaW5nIG5ldyBSVENSdHBSZWNlaXZlcigpJyk7XG5cblx0XHRcdFx0dmFyIHJ0cFJlY2VpdmVyID0gbmV3IFJUQ1J0cFJlY2VpdmVyKF90aGlzNS5fZHRsc1RyYW5zcG9ydCwgY29uc3VtZXIua2luZCk7XG5cblx0XHRcdFx0cnRwUmVjZWl2ZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoJ2ljZUdhdGhlcmVyIFwiZXJyb3JcIiBldmVudCBbZXZlbnQ6JW9dJywgZXZlbnQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBOT1RFOiBDb252ZXJ0IG91ciBzdGFuZGFyZCBSVENSdHBQYXJhbWV0ZXJzIGludG8gdGhvc2UgdGhhdCBFZGdlXG5cdFx0XHRcdC8vIGV4cGVjdHMuXG5cdFx0XHRcdHZhciBlZGdlUnRwUGFyYW1ldGVycyA9IGVkZ2VVdGlscy5tYW5nbGVSdHBQYXJhbWV0ZXJzKGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcnRwUmVjZWl2ZXIucmVjZWl2ZSgpIFtwYXJhbXM6JW9dJywgZWRnZVJ0cFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdHJ0cFJlY2VpdmVyLnJlY2VpdmUoZWRnZVJ0cFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdC8vIFN0b3JlIGl0LlxuXHRcdFx0XHRfdGhpczUuX3J0cFJlY2VpdmVycy5zZXQoY29uc3VtZXIuaWQsIHJ0cFJlY2VpdmVyKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUNvbnN1bWVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ29uc3VtZXIoY29uc3VtZXIpIHtcblx0XHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZUNvbnN1bWVyKCkgW2lkOiVzLCBraW5kOiVzXScsIGNvbnN1bWVyLmlkLCBjb25zdW1lci5raW5kKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcnRwUmVjZWl2ZXIgPSBfdGhpczYuX3J0cFJlY2VpdmVycy5nZXQoY29uc3VtZXIuaWQpO1xuXG5cdFx0XHRcdGlmICghcnRwUmVjZWl2ZXIpIHRocm93IG5ldyBFcnJvcignUlRDUnRwUmVjZWl2ZXIgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0X3RoaXM2Ll9ydHBSZWNlaXZlcnMuZGVsZXRlKGNvbnN1bWVyLmlkKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlQ29uc3VtZXIoKSB8IGNhbGxpbmcgcnRwUmVjZWl2ZXIuc3RvcCgpJyk7XG5cblx0XHRcdFx0XHRydHBSZWNlaXZlci5zdG9wKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLndhcm4oJ3J0cFJlY2VpdmVyLnN0b3AoKSBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3Jlc3RhcnRJY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpIHtcblx0XHRcdHZhciBfdGhpczcgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X3RoaXM3Ll90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZVBhcmFtZXRlcnMgPSByZW1vdGVJY2VQYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdHZhciByZW1vdGVJY2VDYW5kaWRhdGVzID0gX3RoaXM3Ll90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZUNhbmRpZGF0ZXM7XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIGljZVRyYW5zcG9ydC5zdGFydCgpJyk7XG5cblx0XHRcdFx0X3RoaXM3Ll9pY2VUcmFuc3BvcnQuc3RhcnQoX3RoaXM3Ll9pY2VHYXRoZXJlciwgcmVtb3RlSWNlUGFyYW1ldGVycywgJ2NvbnRyb2xsaW5nJyk7XG5cblx0XHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcblx0XHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IHJlbW90ZUljZUNhbmRpZGF0ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0XHRcdHZhciBjYW5kaWRhdGUgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0XHRcdF90aGlzNy5faWNlVHJhbnNwb3J0LmFkZFJlbW90ZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcblx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3RoaXM3Ll9pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKHt9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19zZXRJY2VHYXRoZXJlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9zZXRJY2VHYXRoZXJlcihzZXR0aW5ncykge1xuXHRcdFx0dmFyIGljZUdhdGhlcmVyID0gbmV3IFJUQ0ljZUdhdGhlcmVyKHtcblx0XHRcdFx0aWNlU2VydmVyczogc2V0dGluZ3MudHVyblNlcnZlcnMgfHwgW10sXG5cdFx0XHRcdGdhdGhlclBvbGljeTogJ2FsbCdcblx0XHRcdH0pO1xuXG5cdFx0XHRpY2VHYXRoZXJlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ2ljZUdhdGhlcmVyIFwiZXJyb3JcIiBldmVudCBbZXZlbnQ6JW9dJywgZXZlbnQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIE5PVEU6IE5vdCB5ZXQgaW1wbGVtZW50ZWQgYnkgRWRnZSwgd2hpY2ggc3RhcnRzIGdhdGhlcmluZyBhdXRvbWF0aWNhbGx5LlxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWNlR2F0aGVyZXIuZ2F0aGVyKCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2ljZUdhdGhlcmVyLmdhdGhlcigpIGZhaWxlZDogJXMnLCBlcnJvci50b1N0cmluZygpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faWNlR2F0aGVyZXIgPSBpY2VHYXRoZXJlcjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfc2V0SWNlVHJhbnNwb3J0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3NldEljZVRyYW5zcG9ydCgpIHtcblx0XHRcdHZhciBfdGhpczggPSB0aGlzO1xuXG5cdFx0XHR2YXIgaWNlVHJhbnNwb3J0ID0gbmV3IFJUQ0ljZVRyYW5zcG9ydCh0aGlzLl9pY2VHYXRoZXJlcik7XG5cblx0XHRcdC8vIE5PVEU6IE5vdCB5ZXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cblx0XHRcdGljZVRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c3dpdGNoIChpY2VUcmFuc3BvcnQuc3RhdGUpIHtcblx0XHRcdFx0XHRjYXNlICdjaGVja2luZyc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRcdGNhc2UgJ2NvbXBsZXRlZCc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gTk9URTogTm90IHN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cblx0XHRcdGljZVRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdpY2VzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c3dpdGNoIChpY2VUcmFuc3BvcnQuc3RhdGUpIHtcblx0XHRcdFx0XHRjYXNlICdjaGVja2luZyc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRcdGNhc2UgJ2NvbXBsZXRlZCc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0XHRfdGhpczguZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWNlVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbmRpZGF0ZXBhaXJjaGFuZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdpY2VUcmFuc3BvcnQgXCJjYW5kaWRhdGVwYWlyY2hhbmdlXCIgZXZlbnQgW3BhaXI6JW9dJywgZXZlbnQucGFpcik7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5faWNlVHJhbnNwb3J0ID0gaWNlVHJhbnNwb3J0O1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19zZXREdGxzVHJhbnNwb3J0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3NldER0bHNUcmFuc3BvcnQoKSB7XG5cdFx0XHR2YXIgZHRsc1RyYW5zcG9ydCA9IG5ldyBSVENEdGxzVHJhbnNwb3J0KHRoaXMuX2ljZVRyYW5zcG9ydCk7XG5cblx0XHRcdC8vIE5PVEU6IE5vdCB5ZXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cblx0XHRcdGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnZHRsc1RyYW5zcG9ydCBcInN0YXRlY2hhbmdlXCIgZXZlbnQgW3N0YXRlOiVzXScsIGR0bHNUcmFuc3BvcnQuc3RhdGUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIE5PVEU6IE5vdCBzdGFuZGFyZCwgYnV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG5cdFx0XHRkdGxzVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2R0bHNzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdkdGxzVHJhbnNwb3J0IFwiZHRsc3N0YXRlY2hhbmdlXCIgZXZlbnQgW3N0YXRlOiVzXScsIGR0bHNUcmFuc3BvcnQuc3RhdGUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdkdGxzVHJhbnNwb3J0IFwiZXJyb3JcIiBldmVudCBbZXZlbnQ6JW9dJywgZXZlbnQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX2R0bHNUcmFuc3BvcnQgPSBkdGxzVHJhbnNwb3J0O1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19zZXR1cFRyYW5zcG9ydCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFRyYW5zcG9ydCgpIHtcblx0XHRcdHZhciBfdGhpczkgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHZhciB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7fTtcblx0XHRcdFx0dmFyIGR0bHNQYXJhbWV0ZXJzID0gX3RoaXM5Ll9kdGxzVHJhbnNwb3J0LmdldExvY2FsUGFyYW1ldGVycygpO1xuXG5cdFx0XHRcdC8vIExldCdzIGRlY2lkZSB0aGF0IHdlJ2xsIGJlIERUTFMgc2VydmVyIChiZWNhdXNlIHdlIGNhbikuXG5cdFx0XHRcdGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnc2VydmVyJztcblxuXHRcdFx0XHR0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMuZHRsc1BhcmFtZXRlcnMgPSBkdGxzUGFyYW1ldGVycztcblxuXHRcdFx0XHQvLyBXZSBuZWVkIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0cmV0dXJuIF90aGlzOS5zYWZlRW1pdEFzUHJvbWlzZSgnQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykge1xuXHRcdFx0XHRfdGhpczkuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMgPSB0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdHZhciByZW1vdGVJY2VQYXJhbWV0ZXJzID0gdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VQYXJhbWV0ZXJzO1xuXHRcdFx0XHR2YXIgcmVtb3RlSWNlQ2FuZGlkYXRlcyA9IHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuaWNlQ2FuZGlkYXRlcztcblx0XHRcdFx0dmFyIHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5kdGxzUGFyYW1ldGVycztcblxuXHRcdFx0XHQvLyBTdGFydCB0aGUgUlRDSWNlVHJhbnNwb3J0LlxuXHRcdFx0XHRfdGhpczkuX2ljZVRyYW5zcG9ydC5zdGFydChfdGhpczkuX2ljZUdhdGhlcmVyLCByZW1vdGVJY2VQYXJhbWV0ZXJzLCAnY29udHJvbGxpbmcnKTtcblxuXHRcdFx0XHQvLyBBZGQgcmVtb3RlIElDRSBjYW5kaWRhdGVzLlxuXHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlO1xuXHRcdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG5cdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3I0ID0gcmVtb3RlSWNlQ2FuZGlkYXRlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGNhbmRpZGF0ZSA9IF9zdGVwNC52YWx1ZTtcblxuXHRcdFx0XHRcdFx0X3RoaXM5Ll9pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQWxzbyBzaWduYWwgYSAnY29tcGxldGUnIGNhbmRpZGF0ZSBhcyBwZXIgc3BlYy5cblx0XHRcdFx0XHQvLyBOT1RFOiBJdCBzaG91bGQgYmUge2NvbXBsZXRlOiB0cnVlfSBidXQgRWRnZSBwcmVmZXJzIHt9LlxuXHRcdFx0XHRcdC8vIE5PVEU6IElmIHdlIGRvbid0IHNpZ25hbCBlbmQgb2YgY2FuZGlkYXRlcywgdGhlIEVkZ2UgUlRDSWNlVHJhbnNwb3J0XG5cdFx0XHRcdFx0Ly8gd29uJ3QgZW50ZXIgdGhlICdjb21wbGV0ZWQnIHN0YXRlLlxuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuXHRcdFx0XHRcdF9pdGVyYXRvckVycm9yNCA9IGVycjtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuXHRcdFx0XHRcdFx0XHRfaXRlcmF0b3I0LnJldHVybigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yNDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfdGhpczkuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuXG5cdFx0XHRcdC8vIE5PVEU6IEVkZ2UgZG9lcyBub3QgbGlrZSBTSEEgbGVzcyB0aGFuIDI1Ni5cblx0XHRcdFx0cmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzID0gcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzLmZpbHRlcihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTI1NicgfHwgZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTM4NCcgfHwgZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTUxMic7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFN0YXJ0IHRoZSBSVENEdGxzVHJhbnNwb3J0LlxuXHRcdFx0XHRfdGhpczkuX2R0bHNUcmFuc3BvcnQuc3RhcnQocmVtb3RlRHRsc1BhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdF90aGlzOS5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEVkZ2UxMTtcbn0oX0VuaGFuY2VkRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRWRnZTExOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9zZHBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzZHAtdHJhbnNmb3JtJyk7XG5cbnZhciBfc2RwVHJhbnNmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NkcFRyYW5zZm9ybSk7XG5cbnZhciBfTG9nZ2VyID0gcmVxdWlyZSgnLi4vTG9nZ2VyJyk7XG5cbnZhciBfTG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xvZ2dlcik7XG5cbnZhciBfRW5oYW5jZWRFdmVudEVtaXR0ZXIyID0gcmVxdWlyZSgnLi4vRW5oYW5jZWRFdmVudEVtaXR0ZXInKTtcblxudmFyIF9FbmhhbmNlZEV2ZW50RW1pdHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbmhhbmNlZEV2ZW50RW1pdHRlcjIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxudmFyIF9vcnRjID0gcmVxdWlyZSgnLi4vb3J0YycpO1xuXG52YXIgb3J0YyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9vcnRjKTtcblxudmFyIF9jb21tb25VdGlscyA9IHJlcXVpcmUoJy4vc2RwL2NvbW1vblV0aWxzJyk7XG5cbnZhciBzZHBDb21tb25VdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb21tb25VdGlscyk7XG5cbnZhciBfdW5pZmllZFBsYW5VdGlscyA9IHJlcXVpcmUoJy4vc2RwL3VuaWZpZWRQbGFuVXRpbHMnKTtcblxudmFyIHNkcFVuaWZpZWRQbGFuVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdW5pZmllZFBsYW5VdGlscyk7XG5cbnZhciBfUmVtb3RlVW5pZmllZFBsYW5TZHAgPSByZXF1aXJlKCcuL3NkcC9SZW1vdGVVbmlmaWVkUGxhblNkcCcpO1xuXG52YXIgX1JlbW90ZVVuaWZpZWRQbGFuU2RwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlbW90ZVVuaWZpZWRQbGFuU2RwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgbG9nZ2VyID0gbmV3IF9Mb2dnZXIyLmRlZmF1bHQoJ0ZpcmVmb3g1MCcpO1xuXG52YXIgSGFuZGxlciA9IGZ1bmN0aW9uIChfRW5oYW5jZWRFdmVudEVtaXR0ZXIpIHtcblx0X2luaGVyaXRzKEhhbmRsZXIsIF9FbmhhbmNlZEV2ZW50RW1pdHRlcik7XG5cblx0ZnVuY3Rpb24gSGFuZGxlcihkaXJlY3Rpb24sIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhbmRsZXIpO1xuXG5cdFx0Ly8gUlRDUGVlckNvbm5lY3Rpb24gaW5zdGFuY2UuXG5cdFx0Ly8gQHR5cGUge1JUQ1BlZXJDb25uZWN0aW9ufVxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChIYW5kbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSGFuZGxlcikpLmNhbGwodGhpcywgbG9nZ2VyKSk7XG5cblx0XHRfdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuXHRcdFx0aWNlU2VydmVyczogc2V0dGluZ3MudHVyblNlcnZlcnMgfHwgW10sXG5cdFx0XHRpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuXHRcdFx0YnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG5cdFx0XHRydGNwTXV4UG9saWN5OiAncmVxdWlyZSdcblx0XHR9KTtcblxuXHRcdC8vIEdlbmVyaWMgc2VuZGluZyBSVFAgcGFyYW1ldGVycyBmb3IgYXVkaW8gYW5kIHZpZGVvLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0X3RoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmQgPSBydHBQYXJhbWV0ZXJzQnlLaW5kO1xuXG5cdFx0Ly8gUmVtb3RlIFNEUCBoYW5kbGVyLlxuXHRcdC8vIEB0eXBlIHtSZW1vdGVVbmlmaWVkUGxhblNkcH1cblx0XHRfdGhpcy5fcmVtb3RlU2RwID0gbmV3IF9SZW1vdGVVbmlmaWVkUGxhblNkcDIuZGVmYXVsdChkaXJlY3Rpb24sIHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXG5cdFx0Ly8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuXHRcdF90aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzd2l0Y2ggKF90aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcblx0XHRcdFx0Y2FzZSAnY2hlY2tpbmcnOlxuXHRcdFx0XHRcdF90aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRjYXNlICdjb21wbGV0ZWQnOlxuXHRcdFx0XHRcdF90aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0X3RoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGlzY29ubmVjdGVkJzpcblx0XHRcdFx0XHRfdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjbG9zZWQnOlxuXHRcdFx0XHRcdF90aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKEhhbmRsZXIsIFt7XG5cdFx0a2V5OiAnY2xvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0XHQvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3BjLmNsb3NlKCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge31cblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gSGFuZGxlcjtcbn0oX0VuaGFuY2VkRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxudmFyIFNlbmRIYW5kbGVyID0gZnVuY3Rpb24gKF9IYW5kbGVyKSB7XG5cdF9pbmhlcml0cyhTZW5kSGFuZGxlciwgX0hhbmRsZXIpO1xuXG5cdGZ1bmN0aW9uIFNlbmRIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbmRIYW5kbGVyKTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2VuZEhhbmRsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTZW5kSGFuZGxlcikpLmNhbGwodGhpcywgJ3NlbmQnLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncykpO1xuXG5cdFx0X3RoaXMyLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuXG5cdFx0Ly8gTG9jYWwgc3RyZWFtLlxuXHRcdC8vIEB0eXBlIHtNZWRpYVN0cmVhbX1cblx0XHRfdGhpczIuX3N0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuXG5cdFx0Ly8gUklEIHZhbHVlIGNvdW50ZXIgZm9yIHNpbXVsY2FzdCAoc28gdGhleSBuZXZlciBtYXRjaCkuXG5cdFx0Ly8gQHR5cGUge051bWJlcn1cblx0XHRfdGhpczIuX25leHRSaWQgPSAxO1xuXHRcdHJldHVybiBfdGhpczI7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU2VuZEhhbmRsZXIsIFt7XG5cdFx0a2V5OiAnYWRkUHJvZHVjZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRQcm9kdWNlcihwcm9kdWNlcikge1xuXHRcdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHRcdHZhciB0cmFjayA9IHByb2R1Y2VyLnRyYWNrO1xuXG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJywgcHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdFx0aWYgKHRoaXMuX3N0cmVhbS5nZXRUcmFja0J5SWQodHJhY2suaWQpKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3RyYWNrIGFscmVhZHkgYWRkZWQnKTtcblxuXHRcdFx0dmFyIHJ0cFNlbmRlciA9IHZvaWQgMDtcblx0XHRcdHZhciBsb2NhbFNkcE9iaiA9IHZvaWQgMDtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfdGhpczMuX3N0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBzdHJlYW0gdG8gdGhlIFBlZXJDb25uZWN0aW9uLlxuXHRcdFx0XHRydHBTZW5kZXIgPSBfdGhpczMuX3BjLmFkZFRyYWNrKHRyYWNrLCBfdGhpczMuX3N0cmVhbSk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gSWYgc2ltdWxjYXN0IGlzIG5vdCBlbmFibGVkLCBkbyBub3RoaW5nLlxuXHRcdFx0XHRpZiAoIXByb2R1Y2VyLnNpbXVsY2FzdCkgcmV0dXJuO1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSB8IGVuYWJsaW5nIHNpbXVsY2FzdCcpO1xuXG5cdFx0XHRcdHZhciBlbmNvZGluZ3MgPSBbXTtcblxuXHRcdFx0XHRpZiAocHJvZHVjZXIuc2ltdWxjYXN0LmhpZ2gpIHtcblx0XHRcdFx0XHRlbmNvZGluZ3MucHVzaCh7XG5cdFx0XHRcdFx0XHRyaWQ6ICdoaWdoJyArIF90aGlzMy5fbmV4dFJpZCxcblx0XHRcdFx0XHRcdGFjdGl2ZTogdHJ1ZSxcblx0XHRcdFx0XHRcdHByaW9yaXR5OiAnaGlnaCcsXG5cdFx0XHRcdFx0XHRtYXhCaXRyYXRlOiBwcm9kdWNlci5zaW11bGNhc3QuaGlnaFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb2R1Y2VyLnNpbXVsY2FzdC5tZWRpdW0pIHtcblx0XHRcdFx0XHRlbmNvZGluZ3MucHVzaCh7XG5cdFx0XHRcdFx0XHRyaWQ6ICdtZWRpdW0nICsgX3RoaXMzLl9uZXh0UmlkLFxuXHRcdFx0XHRcdFx0YWN0aXZlOiB0cnVlLFxuXHRcdFx0XHRcdFx0cHJpb3JpdHk6ICdtZWRpdW0nLFxuXHRcdFx0XHRcdFx0bWF4Qml0cmF0ZTogcHJvZHVjZXIuc2ltdWxjYXN0Lm1lZGl1bVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb2R1Y2VyLnNpbXVsY2FzdC5sb3cpIHtcblx0XHRcdFx0XHRlbmNvZGluZ3MucHVzaCh7XG5cdFx0XHRcdFx0XHRyaWQ6ICdsb3cnICsgX3RoaXMzLl9uZXh0UmlkLFxuXHRcdFx0XHRcdFx0YWN0aXZlOiB0cnVlLFxuXHRcdFx0XHRcdFx0cHJpb3JpdHk6ICdsb3cnLFxuXHRcdFx0XHRcdFx0bWF4Qml0cmF0ZTogcHJvZHVjZXIuc2ltdWxjYXN0Lmxvd1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIFJJRCBjb3VudGVyIGZvciBmdXR1cmUgb25lcy5cblx0XHRcdFx0X3RoaXMzLl9uZXh0UmlkKys7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHsgZW5jb2RpbmdzOiBlbmNvZGluZ3MgfSk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzMy5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzMy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCFfdGhpczMuX3RyYW5zcG9ydFJlYWR5KSByZXR1cm4gX3RoaXMzLl9zZXR1cFRyYW5zcG9ydCgpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGxvY2FsU2RwT2JqID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShfdGhpczMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblxuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXMzLl9yZW1vdGVTZHAuY3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKTtcblx0XHRcdFx0dmFyIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBydHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUoX3RoaXMzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhpcyB0cmFjay5cblx0XHRcdFx0c2RwVW5pZmllZFBsYW5VdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFBhcmFtZXRlcnM7XG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0Ly8gUGFuaWMgaGVyZS4gVHJ5IHRvIHVuZG8gdGhpbmdzLlxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0X3RoaXMzLl9wYy5yZW1vdmVUcmFjayhydHBTZW5kZXIpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcjIpIHt9XG5cblx0XHRcdFx0X3RoaXMzLl9zdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlUHJvZHVjZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVQcm9kdWNlcihwcm9kdWNlcikge1xuXHRcdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cblx0XHRcdHZhciB0cmFjayA9IHByb2R1Y2VyLnRyYWNrO1xuXG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlUHJvZHVjZXIoKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJywgcHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBHZXQgdGhlIGFzc29jaWF0ZWQgUlRDUnRwU2VuZGVyLlxuXHRcdFx0XHR2YXIgcnRwU2VuZGVyID0gX3RoaXM0Ll9wYy5nZXRTZW5kZXJzKCkuZmluZChmdW5jdGlvbiAocykge1xuXHRcdFx0XHRcdHJldHVybiBzLnRyYWNrID09PSB0cmFjaztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKCFydHBTZW5kZXIpIHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIGZvdW5kJyk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBhc3NvY2lhdGVkIFJ0cFNlbmRlci5cblx0XHRcdFx0X3RoaXM0Ll9wYy5yZW1vdmVUcmFjayhydHBTZW5kZXIpO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgdHJhY2sgZnJvbSB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHRfdGhpczQuX3N0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0Ly8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBjYXVzZVxuXHRcdFx0XHQvLyBGaXJlZm94IHRvIGNsb3NlIERUTFMuIFRoaXMgaXMgZml4ZWQgZm9yIHRoZSByZWNlaXZpbmcgUGVlckNvbm5lY3Rpb25cblx0XHRcdFx0Ly8gKGJ5IGFkZGluZyBhIGZha2UgRGF0YUNoYW5uZWwpIGJ1dCBub3QgZm9yIHRoZSBzZW5kaW5nIG9uZS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gSVNTVUU6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJzYXRpY2EvbWVkaWFzb3VwLWNsaWVudC9pc3N1ZXMvMlxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF90aGlzNC5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdFx0fSkudGhlbihmdW5jdGlvbiAob2ZmZXIpIHtcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZVByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIF90aGlzNC5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBsb2NhbFNkcE9iaiA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2UoX3RoaXM0Ll9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cdFx0XHRcdHZhciByZW1vdGVTZHAgPSBfdGhpczQuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHR2YXIgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZVByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczQuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlUHJvZHVjZXJUcmFjaycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VQcm9kdWNlclRyYWNrKHByb2R1Y2VyLCB0cmFjaykge1xuXHRcdFx0dmFyIF90aGlzNSA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVwbGFjZVByb2R1Y2VyVHJhY2soKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJywgcHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdFx0dmFyIG9sZFRyYWNrID0gcHJvZHVjZXIudHJhY2s7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlci5cblx0XHRcdFx0dmFyIHJ0cFNlbmRlciA9IF90aGlzNS5fcGMuZ2V0U2VuZGVycygpLmZpbmQoZnVuY3Rpb24gKHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gcy50cmFjayA9PT0gb2xkVHJhY2s7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICghcnRwU2VuZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ2xvY2FsIHRyYWNrIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRcdHJldHVybiBydHBTZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIG9sZCB0cmFjayBmcm9tIHRoZSBsb2NhbCBzdHJlYW0uXG5cdFx0XHRcdF90aGlzNS5fc3RyZWFtLnJlbW92ZVRyYWNrKG9sZFRyYWNrKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHRfdGhpczUuX3N0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdyZXN0YXJ0SWNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKSB7XG5cdFx0XHR2YXIgX3RoaXM2ID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cblx0XHRcdHRoaXMuX3JlbW90ZVNkcC51cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzKHJlbW90ZUljZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczYuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXM2Ll9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgbG9jYWxTZHBPYmogPSBfc2RwVHJhbnNmb3JtMi5kZWZhdWx0LnBhcnNlKF90aGlzNi5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXM2Ll9yZW1vdGVTZHAuY3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKTtcblx0XHRcdFx0dmFyIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczYuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfc2V0dXBUcmFuc3BvcnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBUcmFuc3BvcnQoKSB7XG5cdFx0XHR2YXIgX3RoaXM3ID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdfc2V0dXBUcmFuc3BvcnQoKScpO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR2YXIgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0XHRcdHZhciBzZHAgPSBfdGhpczcuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXHRcdFx0XHR2YXIgc2RwT2JqID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShzZHApO1xuXHRcdFx0XHR2YXIgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKTtcblxuXHRcdFx0XHQvLyBMZXQncyBkZWNpZGUgdGhhdCB3ZSdsbCBiZSBEVExTIHNlcnZlciAoYmVjYXVzZSB3ZSBjYW4pLlxuXHRcdFx0XHRkdGxzUGFyYW1ldGVycy5yb2xlID0gJ3NlcnZlcic7XG5cblx0XHRcdFx0dHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzID0gZHRsc1BhcmFtZXRlcnM7XG5cblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0XHRcdF90aGlzNy5fcmVtb3RlU2RwLnNldFRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyh0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdC8vIFdlIG5lZWQgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gX3RoaXM3LnNhZmVFbWl0QXNQcm9taXNlKCdAbmVlZGNyZWF0ZXRyYW5zcG9ydCcsIHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0X3RoaXM3Ll9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHRfdGhpczcuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBTZW5kSGFuZGxlcjtcbn0oSGFuZGxlcik7XG5cbnZhciBSZWN2SGFuZGxlciA9IGZ1bmN0aW9uIChfSGFuZGxlcjIpIHtcblx0X2luaGVyaXRzKFJlY3ZIYW5kbGVyLCBfSGFuZGxlcjIpO1xuXG5cdGZ1bmN0aW9uIFJlY3ZIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY3ZIYW5kbGVyKTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dmFyIF90aGlzOCA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChSZWN2SGFuZGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJlY3ZIYW5kbGVyKSkuY2FsbCh0aGlzLCAncmVjdicsIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKSk7XG5cblx0XHRfdGhpczguX3RyYW5zcG9ydENyZWF0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHRfdGhpczguX3RyYW5zcG9ydFVwZGF0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIE1hcCBvZiBDb25zdW1lcnMgaW5mb3JtYXRpb24gaW5kZXhlZCBieSBjb25zdW1lci5pZC5cblx0XHQvLyAtIG1pZCB7U3RyaW5nfVxuXHRcdC8vIC0ga2luZCB7U3RyaW5nfVxuXHRcdC8vIC0gY2xvc2VkIHtCb29sZWFufVxuXHRcdC8vIC0gdHJhY2tJZCB7U3RyaW5nfVxuXHRcdC8vIC0gc3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gcnR4U3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gY25hbWUge1N0cmluZ31cblx0XHQvLyBAdHlwZSB7TWFwPE51bWJlciwgT2JqZWN0Pn1cblx0XHRfdGhpczguX2NvbnN1bWVySW5mb3MgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBBZGQgYW4gZW50cnkgaW50byBjb25zdW1lcnMgaW5mbyB0byBob2xkIGEgZmFrZSBEYXRhQ2hhbm5lbCwgc29cblx0XHQvLyB0aGUgZmlyc3QgbT0gc2VjdGlvbiBvZiB0aGUgcmVtb3RlIFNEUCBpcyBhbHdheXMgXCJhY3RpdmVcIiBhbmQgRmlyZWZveFxuXHRcdC8vIGRvZXMgbm90IGNsb3NlIHRoZSB0cmFuc3BvcnQgd2hlbiB0aGVyZSBpcyBubyByZW1vdGUgYXVkaW8vdmlkZW8gQ29uc3VtZXJzLlxuXHRcdC8vXG5cdFx0Ly8gSVNTVUU6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJzYXRpY2EvbWVkaWFzb3VwLWNsaWVudC9pc3N1ZXMvMlxuXHRcdHZhciBmYWtlRGF0YUNoYW5uZWxDb25zdW1lckluZm8gPSB7XG5cdFx0XHRtaWQ6ICdmYWtlLWRhdGFjaGFubmVsLWNvbnN1bWVyJyxcblx0XHRcdGtpbmQ6ICdhcHBsaWNhdGlvbicsXG5cdFx0XHRjbG9zZWQ6IGZhbHNlLFxuXHRcdFx0Y25hbWU6IG51bGxcblx0XHR9O1xuXG5cdFx0X3RoaXM4Ll9jb25zdW1lckluZm9zLnNldCg1NTUsIGZha2VEYXRhQ2hhbm5lbENvbnN1bWVySW5mbyk7XG5cdFx0cmV0dXJuIF90aGlzODtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhSZWN2SGFuZGxlciwgW3tcblx0XHRrZXk6ICdhZGRDb25zdW1lcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZENvbnN1bWVyKGNvbnN1bWVyKSB7XG5cdFx0XHR2YXIgX3RoaXM5ID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRDb25zdW1lcigpIFtpZDolcywga2luZDolc10nLCBjb25zdW1lci5pZCwgY29uc3VtZXIua2luZCk7XG5cblx0XHRcdGlmICh0aGlzLl9jb25zdW1lckluZm9zLmhhcyhjb25zdW1lci5pZCkpIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ29uc3VtZXIgYWxyZWFkeSBhZGRlZCcpO1xuXG5cdFx0XHR2YXIgZW5jb2RpbmcgPSBjb25zdW1lci5ydHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcblx0XHRcdHZhciBjbmFtZSA9IGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZTtcblx0XHRcdHZhciBjb25zdW1lckluZm8gPSB7XG5cdFx0XHRcdG1pZDogJ2NvbnN1bWVyLScgKyBjb25zdW1lci5raW5kICsgJy0nICsgY29uc3VtZXIuaWQsXG5cdFx0XHRcdGtpbmQ6IGNvbnN1bWVyLmtpbmQsXG5cdFx0XHRcdGNsb3NlZDogY29uc3VtZXIuY2xvc2VkLFxuXHRcdFx0XHR0cmFja0lkOiAnY29uc3VtZXItJyArIGNvbnN1bWVyLmtpbmQgKyAnLScgKyBjb25zdW1lci5pZCxcblx0XHRcdFx0c3NyYzogZW5jb2Rpbmcuc3NyYyxcblx0XHRcdFx0Y25hbWU6IGNuYW1lXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoZW5jb2RpbmcucnR4ICYmIGVuY29kaW5nLnJ0eC5zc3JjKSBjb25zdW1lckluZm8ucnR4U3NyYyA9IGVuY29kaW5nLnJ0eC5zc3JjO1xuXG5cdFx0XHR0aGlzLl9jb25zdW1lckluZm9zLnNldChjb25zdW1lci5pZCwgY29uc3VtZXJJbmZvKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIV90aGlzOS5fdHJhbnNwb3J0Q3JlYXRlZCkgcmV0dXJuIF90aGlzOS5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXM5Ll9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoQXJyYXkuZnJvbShfdGhpczkuX2NvbnN1bWVySW5mb3MudmFsdWVzKCkpKTtcblx0XHRcdFx0dmFyIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczkuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXM5Ll9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKGFuc3dlcikge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZENvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzOS5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICghX3RoaXM5Ll90cmFuc3BvcnRVcGRhdGVkKSByZXR1cm4gX3RoaXM5Ll91cGRhdGVUcmFuc3BvcnQoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgbmV3UnRwUmVjZWl2ZXIgPSBfdGhpczkuX3BjLmdldFJlY2VpdmVycygpLmZpbmQoZnVuY3Rpb24gKHJ0cFJlY2VpdmVyKSB7XG5cdFx0XHRcdFx0dmFyIHRyYWNrID0gcnRwUmVjZWl2ZXIudHJhY2s7XG5cblxuXHRcdFx0XHRcdGlmICghdHJhY2spIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdHJldHVybiB0cmFjay5pZCA9PT0gY29uc3VtZXJJbmZvLnRyYWNrSWQ7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICghbmV3UnRwUmVjZWl2ZXIpIHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRcdHJldHVybiBuZXdSdHBSZWNlaXZlci50cmFjaztcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUNvbnN1bWVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ29uc3VtZXIoY29uc3VtZXIpIHtcblx0XHRcdHZhciBfdGhpczEwID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdmVDb25zdW1lcigpIFtpZDolcywga2luZDolc10nLCBjb25zdW1lci5pZCwgY29uc3VtZXIua2luZCk7XG5cblx0XHRcdHZhciBjb25zdW1lckluZm8gPSB0aGlzLl9jb25zdW1lckluZm9zLmdldChjb25zdW1lci5pZCk7XG5cblx0XHRcdGlmICghY29uc3VtZXJJbmZvKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NvbnN1bWVyIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRjb25zdW1lckluZm8uY2xvc2VkID0gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXMxMC5fcmVtb3RlU2RwLmNyZWF0ZU9mZmVyU2RwKEFycmF5LmZyb20oX3RoaXMxMC5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHR2YXIgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdmVDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzMTAuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXMxMC5fcGMuY3JlYXRlQW5zd2VyKCk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChhbnN3ZXIpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdmVDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczEwLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdyZXN0YXJ0SWNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKSB7XG5cdFx0XHR2YXIgX3RoaXMxMSA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG5cdFx0XHR0aGlzLl9yZW1vdGVTZHAudXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycyhyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXMxMS5fcmVtb3RlU2RwLmNyZWF0ZU9mZmVyU2RwKEFycmF5LmZyb20oX3RoaXMxMS5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHR2YXIgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMxMS5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczExLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKGFuc3dlcikge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMxMS5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3NldHVwVHJhbnNwb3J0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3NldHVwVHJhbnNwb3J0KCkge1xuXHRcdFx0dmFyIF90aGlzMTIgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gV2UgbmVlZCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHJldHVybiBfdGhpczEyLnNhZmVFbWl0QXNQcm9taXNlKCdAbmVlZGNyZWF0ZXRyYW5zcG9ydCcsIG51bGwpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykge1xuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdF90aGlzMTIuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdF90aGlzMTIuX3RyYW5zcG9ydENyZWF0ZWQgPSB0cnVlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3VwZGF0ZVRyYW5zcG9ydCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVUcmFuc3BvcnQoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ191cGRhdGVUcmFuc3BvcnQoKScpO1xuXG5cdFx0XHQvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cblx0XHRcdC8vIGNvbnN0IHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHt9O1xuXHRcdFx0dmFyIHNkcCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXHRcdFx0dmFyIHNkcE9iaiA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2Uoc2RwKTtcblx0XHRcdHZhciBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyhzZHBPYmopO1xuXHRcdFx0dmFyIHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHsgZHRsc1BhcmFtZXRlcnM6IGR0bHNQYXJhbWV0ZXJzIH07XG5cblx0XHRcdC8vIFdlIG5lZWQgdG8gcHJvdmlkZSB0cmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycy5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ0BuZWVkdXBkYXRldHJhbnNwb3J0JywgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0VXBkYXRlZCA9IHRydWU7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFJlY3ZIYW5kbGVyO1xufShIYW5kbGVyKTtcblxudmFyIEZpcmVmb3g1MCA9IGZ1bmN0aW9uICgpIHtcblx0X2NyZWF0ZUNsYXNzKEZpcmVmb3g1MCwgbnVsbCwgW3tcblx0XHRrZXk6ICdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG5cblx0XHRcdHZhciBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG5cdFx0XHRcdGljZVNlcnZlcnM6IFtdLFxuXHRcdFx0XHRpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuXHRcdFx0XHRidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcblx0XHRcdFx0cnRjcE11eFBvbGljeTogJ3JlcXVpcmUnXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gTk9URTogV2UgbmVlZCB0byBhZGQgYSByZWFsIHZpZGVvIHRyYWNrIHRvIGdldCB0aGUgUklEIGV4dGVuc2lvbiBtYXBwaW5nLlxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0XHQvLyBOT1RFOiBPdGhlcndpc2UgRmlyZWZveCBmYWlscyBpbiBuZXh0IGxpbmUuXG5cdFx0XHRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdFx0dmFyIGZha2VTdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgpO1xuXHRcdFx0dmFyIGZha2VWaWRlb1RyYWNrID0gZmFrZVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuXHRcdFx0dmFyIHJ0cFNlbmRlciA9IHBjLmFkZFRyYWNrKGZha2VWaWRlb1RyYWNrLCBmYWtlU3RyZWFtKTtcblxuXHRcdFx0cnRwU2VuZGVyLnNldFBhcmFtZXRlcnMoe1xuXHRcdFx0XHRlbmNvZGluZ3M6IFt7IHJpZDogJ1JJRDEnLCBtYXhCaXRyYXRlOiA0MDAwMCB9LCB7IHJpZDogJ1JJRDInLCBtYXhCaXRyYXRlOiAxMDAwMCB9XVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBwYy5jcmVhdGVPZmZlcih7XG5cdFx0XHRcdG9mZmVyVG9SZWNlaXZlQXVkaW86IHRydWUsXG5cdFx0XHRcdG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWVcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2FudmFzLnJlbW92ZSgpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge31cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHBjLmNsb3NlKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7fVxuXG5cdFx0XHRcdHZhciBzZHBPYmogPSBfc2RwVHJhbnNmb3JtMi5kZWZhdWx0LnBhcnNlKG9mZmVyLnNkcCk7XG5cdFx0XHRcdHZhciBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHNkcE9iaik7XG5cblx0XHRcdFx0cmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNhbnZhcy5yZW1vdmUoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IyKSB7fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cGMuY2xvc2UoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IyKSB7fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnbmFtZScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gJ0ZpcmVmb3g1MCc7XG5cdFx0fVxuXHR9XSk7XG5cblx0ZnVuY3Rpb24gRmlyZWZveDUwKGRpcmVjdGlvbiwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpcmVmb3g1MCk7XG5cblx0XHRsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCkgW2RpcmVjdGlvbjolcywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXM6JW9dJywgZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHR2YXIgcnRwUGFyYW1ldGVyc0J5S2luZCA9IHZvaWQgMDtcblxuXHRcdHN3aXRjaCAoZGlyZWN0aW9uKSB7XG5cdFx0XHRjYXNlICdzZW5kJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG5cdFx0XHRcdFx0XHRhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG5cdFx0XHRcdFx0XHR2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBTZW5kSGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ3JlY3YnOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcblx0XHRcdFx0XHRcdGF1ZGlvOiBvcnRjLmdldFJlY2VpdmluZ0Z1bGxSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0XHRcdHZpZGVvOiBvcnRjLmdldFJlY2VpdmluZ0Z1bGxSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlY3ZIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblx0XHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBGaXJlZm94NTA7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEZpcmVmb3g1MDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc2RwVHJhbnNmb3JtID0gcmVxdWlyZSgnc2RwLXRyYW5zZm9ybScpO1xuXG52YXIgX3NkcFRyYW5zZm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZHBUcmFuc2Zvcm0pO1xuXG52YXIgX0xvZ2dlciA9IHJlcXVpcmUoJy4uL0xvZ2dlcicpO1xuXG52YXIgX0xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Mb2dnZXIpO1xuXG52YXIgX0VuaGFuY2VkRXZlbnRFbWl0dGVyMiA9IHJlcXVpcmUoJy4uL0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5cbnZhciBfRW5oYW5jZWRFdmVudEVtaXR0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRW5oYW5jZWRFdmVudEVtaXR0ZXIyKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbnZhciBfb3J0YyA9IHJlcXVpcmUoJy4uL29ydGMnKTtcblxudmFyIG9ydGMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfb3J0Yyk7XG5cbnZhciBfY29tbW9uVXRpbHMgPSByZXF1aXJlKCcuL3NkcC9jb21tb25VdGlscycpO1xuXG52YXIgc2RwQ29tbW9uVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29tbW9uVXRpbHMpO1xuXG52YXIgX3BsYW5CVXRpbHMgPSByZXF1aXJlKCcuL3NkcC9wbGFuQlV0aWxzJyk7XG5cbnZhciBzZHBQbGFuQlV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3BsYW5CVXRpbHMpO1xuXG52YXIgX1JlbW90ZVBsYW5CU2RwID0gcmVxdWlyZSgnLi9zZHAvUmVtb3RlUGxhbkJTZHAnKTtcblxudmFyIF9SZW1vdGVQbGFuQlNkcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZW1vdGVQbGFuQlNkcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGxvZ2dlciA9IG5ldyBfTG9nZ2VyMi5kZWZhdWx0KCdTYWZhcmkxMScpO1xuXG52YXIgSGFuZGxlciA9IGZ1bmN0aW9uIChfRW5oYW5jZWRFdmVudEVtaXR0ZXIpIHtcblx0X2luaGVyaXRzKEhhbmRsZXIsIF9FbmhhbmNlZEV2ZW50RW1pdHRlcik7XG5cblx0ZnVuY3Rpb24gSGFuZGxlcihkaXJlY3Rpb24sIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhbmRsZXIpO1xuXG5cdFx0Ly8gUlRDUGVlckNvbm5lY3Rpb24gaW5zdGFuY2UuXG5cdFx0Ly8gQHR5cGUge1JUQ1BlZXJDb25uZWN0aW9ufVxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChIYW5kbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSGFuZGxlcikpLmNhbGwodGhpcywgbG9nZ2VyKSk7XG5cblx0XHRfdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuXHRcdFx0aWNlU2VydmVyczogc2V0dGluZ3MudHVyblNlcnZlcnMgfHwgW10sXG5cdFx0XHRpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuXHRcdFx0YnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG5cdFx0XHRydGNwTXV4UG9saWN5OiAncmVxdWlyZSdcblx0XHR9KTtcblxuXHRcdC8vIEdlbmVyaWMgc2VuZGluZyBSVFAgcGFyYW1ldGVycyBmb3IgYXVkaW8gYW5kIHZpZGVvLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0X3RoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmQgPSBydHBQYXJhbWV0ZXJzQnlLaW5kO1xuXG5cdFx0Ly8gUmVtb3RlIFNEUCBoYW5kbGVyLlxuXHRcdC8vIEB0eXBlIHtSZW1vdGVQbGFuQlNkcH1cblx0XHRfdGhpcy5fcmVtb3RlU2RwID0gbmV3IF9SZW1vdGVQbGFuQlNkcDIuZGVmYXVsdChkaXJlY3Rpb24sIHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXG5cdFx0Ly8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuXHRcdF90aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzd2l0Y2ggKF90aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcblx0XHRcdFx0Y2FzZSAnY2hlY2tpbmcnOlxuXHRcdFx0XHRcdF90aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRjYXNlICdjb21wbGV0ZWQnOlxuXHRcdFx0XHRcdF90aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0X3RoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGlzY29ubmVjdGVkJzpcblx0XHRcdFx0XHRfdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjbG9zZWQnOlxuXHRcdFx0XHRcdF90aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKEhhbmRsZXIsIFt7XG5cdFx0a2V5OiAnY2xvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0XHQvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3BjLmNsb3NlKCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge31cblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gSGFuZGxlcjtcbn0oX0VuaGFuY2VkRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxudmFyIFNlbmRIYW5kbGVyID0gZnVuY3Rpb24gKF9IYW5kbGVyKSB7XG5cdF9pbmhlcml0cyhTZW5kSGFuZGxlciwgX0hhbmRsZXIpO1xuXG5cdGZ1bmN0aW9uIFNlbmRIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbmRIYW5kbGVyKTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2VuZEhhbmRsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTZW5kSGFuZGxlcikpLmNhbGwodGhpcywgJ3NlbmQnLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncykpO1xuXG5cdFx0X3RoaXMyLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuXG5cdFx0Ly8gTG9jYWwgc3RyZWFtLlxuXHRcdC8vIEB0eXBlIHtNZWRpYVN0cmVhbX1cblx0XHRfdGhpczIuX3N0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuXHRcdHJldHVybiBfdGhpczI7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU2VuZEhhbmRsZXIsIFt7XG5cdFx0a2V5OiAnYWRkUHJvZHVjZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRQcm9kdWNlcihwcm9kdWNlcikge1xuXHRcdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHRcdHZhciB0cmFjayA9IHByb2R1Y2VyLnRyYWNrO1xuXG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJywgcHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdFx0aWYgKHRoaXMuX3N0cmVhbS5nZXRUcmFja0J5SWQodHJhY2suaWQpKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3RyYWNrIGFscmVhZHkgYWRkZWQnKTtcblxuXHRcdFx0dmFyIHJ0cFNlbmRlciA9IHZvaWQgMDtcblx0XHRcdHZhciBsb2NhbFNkcE9iaiA9IHZvaWQgMDtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfdGhpczMuX3N0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBzdHJlYW0gdG8gdGhlIFBlZXJDb25uZWN0aW9uLlxuXHRcdFx0XHRydHBTZW5kZXIgPSBfdGhpczMuX3BjLmFkZFRyYWNrKHRyYWNrLCBfdGhpczMuX3N0cmVhbSk7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzMy5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzMy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCFfdGhpczMuX3RyYW5zcG9ydFJlYWR5KSByZXR1cm4gX3RoaXMzLl9zZXR1cFRyYW5zcG9ydCgpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGxvY2FsU2RwT2JqID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShfdGhpczMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblxuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXMzLl9yZW1vdGVTZHAuY3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKTtcblx0XHRcdFx0dmFyIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBydHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUoX3RoaXMzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhpcyB0cmFjay5cblx0XHRcdFx0c2RwUGxhbkJVdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFBhcmFtZXRlcnM7XG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0Ly8gUGFuaWMgaGVyZS4gVHJ5IHRvIHVuZG8gdGhpbmdzLlxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0X3RoaXMzLl9wYy5yZW1vdmVUcmFjayhydHBTZW5kZXIpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcjIpIHt9XG5cblx0XHRcdFx0X3RoaXMzLl9zdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlUHJvZHVjZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVQcm9kdWNlcihwcm9kdWNlcikge1xuXHRcdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cblx0XHRcdHZhciB0cmFjayA9IHByb2R1Y2VyLnRyYWNrO1xuXG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlUHJvZHVjZXIoKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJywgcHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBHZXQgdGhlIGFzc29jaWF0ZWQgUlRDUnRwU2VuZGVyLlxuXHRcdFx0XHR2YXIgcnRwU2VuZGVyID0gX3RoaXM0Ll9wYy5nZXRTZW5kZXJzKCkuZmluZChmdW5jdGlvbiAocykge1xuXHRcdFx0XHRcdHJldHVybiBzLnRyYWNrID09PSB0cmFjaztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKCFydHBTZW5kZXIpIHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIGZvdW5kJyk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBhc3NvY2lhdGVkIFJ0cFNlbmRlci5cblx0XHRcdFx0X3RoaXM0Ll9wYy5yZW1vdmVUcmFjayhydHBTZW5kZXIpO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgdHJhY2sgZnJvbSB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHRfdGhpczQuX3N0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNC5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNC5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0Ly8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcblx0XHRcdFx0Ly8gXCJGYWlsZWQgdG8gY3JlYXRlIGNoYW5uZWxzXCIuIElmIHNvLCBpZ25vcmUgaXQuXG5cdFx0XHRcdGlmIChfdGhpczQuX3N0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRsb2dnZXIud2FybigncmVtb3ZlTG9jYWxUcmFjaygpIHwgaWdub3JpbmcgZXhwZWN0ZWQgZXJyb3IgZHVlIG5vIHNlbmRpbmcgdHJhY2tzOiAlcycsIGVycm9yLnRvU3RyaW5nKCkpO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKF90aGlzNC5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSByZXR1cm47XG5cblx0XHRcdFx0dmFyIGxvY2FsU2RwT2JqID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC5wYXJzZShfdGhpczQuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblx0XHRcdFx0dmFyIHJlbW90ZVNkcCA9IF90aGlzNC5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdHZhciBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNC5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlcGxhY2VQcm9kdWNlclRyYWNrJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVByb2R1Y2VyVHJhY2socHJvZHVjZXIsIHRyYWNrKSB7XG5cdFx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXBsYWNlUHJvZHVjZXJUcmFjaygpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLCBwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0XHR2YXIgb2xkVHJhY2sgPSBwcm9kdWNlci50cmFjaztcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBHZXQgdGhlIGFzc29jaWF0ZWQgUlRDUnRwU2VuZGVyLlxuXHRcdFx0XHR2YXIgcnRwU2VuZGVyID0gX3RoaXM1Ll9wYy5nZXRTZW5kZXJzKCkuZmluZChmdW5jdGlvbiAocykge1xuXHRcdFx0XHRcdHJldHVybiBzLnRyYWNrID09PSBvbGRUcmFjaztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKCFydHBTZW5kZXIpIHRocm93IG5ldyBFcnJvcignbG9jYWwgdHJhY2sgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgb2xkIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cblx0XHRcdFx0X3RoaXM1Ll9zdHJlYW0ucmVtb3ZlVHJhY2sob2xkVHJhY2spO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgbmV3IHRyYWNrIHRvIHRoZSBsb2NhbCBzdHJlYW0uXG5cdFx0XHRcdF90aGlzNS5fc3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3Jlc3RhcnRJY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpIHtcblx0XHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuXHRcdFx0dGhpcy5fcmVtb3RlU2RwLnVwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMocmVtb3RlSWNlUGFyYW1ldGVycyk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzNi5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAob2ZmZXIpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczYuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBsb2NhbFNkcE9iaiA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2UoX3RoaXM2Ll9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cdFx0XHRcdHZhciByZW1vdGVTZHAgPSBfdGhpczYuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHR2YXIgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzNi5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19zZXR1cFRyYW5zcG9ydCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFRyYW5zcG9ydCgpIHtcblx0XHRcdHZhciBfdGhpczcgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHZhciB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7fTtcblx0XHRcdFx0dmFyIHNkcCA9IF90aGlzNy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cdFx0XHRcdHZhciBzZHBPYmogPSBfc2RwVHJhbnNmb3JtMi5kZWZhdWx0LnBhcnNlKHNkcCk7XG5cdFx0XHRcdHZhciBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyhzZHBPYmopO1xuXG5cdFx0XHRcdC8vIExldCdzIGRlY2lkZSB0aGF0IHdlJ2xsIGJlIERUTFMgc2VydmVyIChiZWNhdXNlIHdlIGNhbikuXG5cdFx0XHRcdGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnc2VydmVyJztcblxuXHRcdFx0XHR0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMuZHRsc1BhcmFtZXRlcnMgPSBkdGxzUGFyYW1ldGVycztcblxuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycy5cblx0XHRcdFx0X3RoaXM3Ll9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0Ly8gV2UgbmVlZCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHJldHVybiBfdGhpczcuc2FmZUVtaXRBc1Byb21pc2UoJ0BuZWVkY3JlYXRldHJhbnNwb3J0JywgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpIHtcblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRfdGhpczcuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdF90aGlzNy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFNlbmRIYW5kbGVyO1xufShIYW5kbGVyKTtcblxudmFyIFJlY3ZIYW5kbGVyID0gZnVuY3Rpb24gKF9IYW5kbGVyMikge1xuXHRfaW5oZXJpdHMoUmVjdkhhbmRsZXIsIF9IYW5kbGVyMik7XG5cblx0ZnVuY3Rpb24gUmVjdkhhbmRsZXIocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdkhhbmRsZXIpO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR2YXIgX3RoaXM4ID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJlY3ZIYW5kbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmVjdkhhbmRsZXIpKS5jYWxsKHRoaXMsICdyZWN2JywgcnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpKTtcblxuXHRcdF90aGlzOC5fdHJhbnNwb3J0Q3JlYXRlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdF90aGlzOC5fdHJhbnNwb3J0VXBkYXRlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gU2VlbiBtZWRpYSBraW5kcy5cblx0XHQvLyBAdHlwZSB7U2V0PFN0cmluZz59XG5cdFx0X3RoaXM4Ll9raW5kcyA9IG5ldyBTZXQoKTtcblxuXHRcdC8vIE1hcCBvZiBDb25zdW1lcnMgaW5mb3JtYXRpb24gaW5kZXhlZCBieSBjb25zdW1lci5pZC5cblx0XHQvLyAtIGtpbmQge1N0cmluZ31cblx0XHQvLyAtIHRyYWNrSWQge1N0cmluZ31cblx0XHQvLyAtIHNzcmMge051bWJlcn1cblx0XHQvLyAtIHJ0eFNzcmMge051bWJlcn1cblx0XHQvLyAtIGNuYW1lIHtTdHJpbmd9XG5cdFx0Ly8gQHR5cGUge01hcDxOdW1iZXIsIE9iamVjdD59XG5cdFx0X3RoaXM4Ll9jb25zdW1lckluZm9zID0gbmV3IE1hcCgpO1xuXHRcdHJldHVybiBfdGhpczg7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoUmVjdkhhbmRsZXIsIFt7XG5cdFx0a2V5OiAnYWRkQ29uc3VtZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRDb25zdW1lcihjb25zdW1lcikge1xuXHRcdFx0dmFyIF90aGlzOSA9IHRoaXM7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkQ29uc3VtZXIoKSBbaWQ6JXMsIGtpbmQ6JXNdJywgY29uc3VtZXIuaWQsIGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0XHRpZiAodGhpcy5fY29uc3VtZXJJbmZvcy5oYXMoY29uc3VtZXIuaWQpKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NvbnN1bWVyIGFscmVhZHkgYWRkZWQnKTtcblxuXHRcdFx0dmFyIGVuY29kaW5nID0gY29uc3VtZXIucnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF07XG5cdFx0XHR2YXIgY25hbWUgPSBjb25zdW1lci5ydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWU7XG5cdFx0XHR2YXIgY29uc3VtZXJJbmZvID0ge1xuXHRcdFx0XHRraW5kOiBjb25zdW1lci5raW5kLFxuXHRcdFx0XHR0cmFja0lkOiAnY29uc3VtZXItJyArIGNvbnN1bWVyLmtpbmQgKyAnLScgKyBjb25zdW1lci5pZCxcblx0XHRcdFx0c3NyYzogZW5jb2Rpbmcuc3NyYyxcblx0XHRcdFx0Y25hbWU6IGNuYW1lXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoZW5jb2RpbmcucnR4ICYmIGVuY29kaW5nLnJ0eC5zc3JjKSBjb25zdW1lckluZm8ucnR4U3NyYyA9IGVuY29kaW5nLnJ0eC5zc3JjO1xuXG5cdFx0XHR0aGlzLl9jb25zdW1lckluZm9zLnNldChjb25zdW1lci5pZCwgY29uc3VtZXJJbmZvKTtcblx0XHRcdHRoaXMuX2tpbmRzLmFkZChjb25zdW1lci5raW5kKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIV90aGlzOS5fdHJhbnNwb3J0Q3JlYXRlZCkgcmV0dXJuIF90aGlzOS5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcmVtb3RlU2RwID0gX3RoaXM5Ll9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoQXJyYXkuZnJvbShfdGhpczkuX2tpbmRzKSwgQXJyYXkuZnJvbShfdGhpczkuX2NvbnN1bWVySW5mb3MudmFsdWVzKCkpKTtcblx0XHRcdFx0dmFyIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiBfdGhpczkuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXM5Ll9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKGFuc3dlcikge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZENvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzOS5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICghX3RoaXM5Ll90cmFuc3BvcnRVcGRhdGVkKSByZXR1cm4gX3RoaXM5Ll91cGRhdGVUcmFuc3BvcnQoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgbmV3UnRwUmVjZWl2ZXIgPSBfdGhpczkuX3BjLmdldFJlY2VpdmVycygpLmZpbmQoZnVuY3Rpb24gKHJ0cFJlY2VpdmVyKSB7XG5cdFx0XHRcdFx0dmFyIHRyYWNrID0gcnRwUmVjZWl2ZXIudHJhY2s7XG5cblxuXHRcdFx0XHRcdGlmICghdHJhY2spIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdHJldHVybiB0cmFjay5pZCA9PT0gY29uc3VtZXJJbmZvLnRyYWNrSWQ7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICghbmV3UnRwUmVjZWl2ZXIpIHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRcdHJldHVybiBuZXdSdHBSZWNlaXZlci50cmFjaztcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUNvbnN1bWVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ29uc3VtZXIoY29uc3VtZXIpIHtcblx0XHRcdHZhciBfdGhpczEwID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdmVDb25zdW1lcigpIFtpZDolcywga2luZDolc10nLCBjb25zdW1lci5pZCwgY29uc3VtZXIua2luZCk7XG5cblx0XHRcdGlmICghdGhpcy5fY29uc3VtZXJJbmZvcy5oYXMoY29uc3VtZXIuaWQpKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NvbnN1bWVyIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHR0aGlzLl9jb25zdW1lckluZm9zLmRlbGV0ZShjb25zdW1lci5pZCk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHJlbW90ZVNkcCA9IF90aGlzMTAuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChBcnJheS5mcm9tKF90aGlzMTAuX2tpbmRzKSwgQXJyYXkuZnJvbShfdGhpczEwLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdHZhciBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZUNvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMxMC5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczEwLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKGFuc3dlcikge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZUNvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIF90aGlzMTAuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3Jlc3RhcnRJY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpIHtcblx0XHRcdHZhciBfdGhpczExID0gdGhpcztcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cblx0XHRcdHRoaXMuX3JlbW90ZVNkcC51cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzKHJlbW90ZUljZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciByZW1vdGVTZHAgPSBfdGhpczExLl9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoQXJyYXkuZnJvbShfdGhpczExLl9raW5kcyksIEFycmF5LmZyb20oX3RoaXMxMS5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHR2YXIgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMxMS5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczExLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKGFuc3dlcikge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gX3RoaXMxMS5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3NldHVwVHJhbnNwb3J0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3NldHVwVHJhbnNwb3J0KCkge1xuXHRcdFx0dmFyIF90aGlzMTIgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gV2UgbmVlZCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHJldHVybiBfdGhpczEyLnNhZmVFbWl0QXNQcm9taXNlKCdAbmVlZGNyZWF0ZXRyYW5zcG9ydCcsIG51bGwpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykge1xuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdF90aGlzMTIuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdF90aGlzMTIuX3RyYW5zcG9ydENyZWF0ZWQgPSB0cnVlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3VwZGF0ZVRyYW5zcG9ydCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVUcmFuc3BvcnQoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ191cGRhdGVUcmFuc3BvcnQoKScpO1xuXG5cdFx0XHQvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cblx0XHRcdC8vIGNvbnN0IHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHt9O1xuXHRcdFx0dmFyIHNkcCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXHRcdFx0dmFyIHNkcE9iaiA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2Uoc2RwKTtcblx0XHRcdHZhciBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyhzZHBPYmopO1xuXHRcdFx0dmFyIHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHsgZHRsc1BhcmFtZXRlcnM6IGR0bHNQYXJhbWV0ZXJzIH07XG5cblx0XHRcdC8vIFdlIG5lZWQgdG8gcHJvdmlkZSB0cmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycy5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ0BuZWVkdXBkYXRldHJhbnNwb3J0JywgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0VXBkYXRlZCA9IHRydWU7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFJlY3ZIYW5kbGVyO1xufShIYW5kbGVyKTtcblxudmFyIFNhZmFyaTExID0gZnVuY3Rpb24gKCkge1xuXHRfY3JlYXRlQ2xhc3MoU2FmYXJpMTEsIG51bGwsIFt7XG5cdFx0a2V5OiAnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuXG5cdFx0XHR2YXIgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuXHRcdFx0XHRpY2VTZXJ2ZXJzOiBbXSxcblx0XHRcdFx0aWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcblx0XHRcdFx0YnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG5cdFx0XHRcdHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJ1xuXHRcdFx0fSk7XG5cblx0XHRcdHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuXHRcdFx0cGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG5cblx0XHRcdHJldHVybiBwYy5jcmVhdGVPZmZlcigpLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cGMuY2xvc2UoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHt9XG5cblx0XHRcdFx0dmFyIHNkcE9iaiA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2Uob2ZmZXIuc2RwKTtcblx0XHRcdFx0dmFyIG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoc2RwT2JqKTtcblxuXHRcdFx0XHRyZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cGMuY2xvc2UoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IyKSB7fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnbmFtZScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gJ1NhZmFyaTExJztcblx0XHR9XG5cdH1dKTtcblxuXHRmdW5jdGlvbiBTYWZhcmkxMShkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCBzZXR0aW5ncykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYWZhcmkxMSk7XG5cblx0XHRsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCkgW2RpcmVjdGlvbjolcywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXM6JW9dJywgZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHR2YXIgcnRwUGFyYW1ldGVyc0J5S2luZCA9IHZvaWQgMDtcblxuXHRcdHN3aXRjaCAoZGlyZWN0aW9uKSB7XG5cdFx0XHRjYXNlICdzZW5kJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnNCeUtpbmQgPSB7XG5cdFx0XHRcdFx0XHRhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG5cdFx0XHRcdFx0XHR2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBTZW5kSGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgJ3JlY3YnOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cnRwUGFyYW1ldGVyc0J5S2luZCA9IHtcblx0XHRcdFx0XHRcdGF1ZGlvOiBvcnRjLmdldFJlY2VpdmluZ0Z1bGxSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0XHRcdHZpZGVvOiBvcnRjLmdldFJlY2VpdmluZ0Z1bGxSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlY3ZIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblx0XHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBTYWZhcmkxMTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU2FmYXJpMTE7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRDYXBhYmlsaXRpZXMgPSBnZXRDYXBhYmlsaXRpZXM7XG5leHBvcnRzLm1hbmdsZVJ0cFBhcmFtZXRlcnMgPSBtYW5nbGVSdHBQYXJhbWV0ZXJzO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKiBOb3JtYWxpemUgRWRnZSdzIFJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcygpIHRvIHByb2R1Y2UgYSBmdWxsXG4gKiBjb21wbGlhbnQgT1JUQyBSVENSdHBDYXBhYmlsaXRpZXMuXG4gKlxuICogQHJldHVybiB7UlRDUnRwQ2FwYWJpbGl0aWVzfVxuICovXG5mdW5jdGlvbiBnZXRDYXBhYmlsaXRpZXMoKSB7XG5cdHZhciBuYXRpdmVDYXBzID0gUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCk7XG5cdHZhciBjYXBzID0gdXRpbHMuY2xvbmUobmF0aXZlQ2Fwcyk7XG5cblx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gY2Fwcy5jb2RlY3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHR2YXIgY29kZWMgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0Ly8gUmVuYW1lIG51bUNoYW5uZWxzIHRvIGNoYW5uZWxzLlxuXHRcdFx0Y29kZWMuY2hhbm5lbHMgPSBjb2RlYy5udW1DaGFubmVscztcblx0XHRcdGRlbGV0ZSBjb2RlYy5udW1DaGFubmVscztcblxuXHRcdFx0Ly8gTm9ybWFsaXplIGNoYW5uZWxzLlxuXHRcdFx0aWYgKGNvZGVjLmtpbmQgIT09ICdhdWRpbycpIGRlbGV0ZSBjb2RlYy5jaGFubmVscztlbHNlIGlmICghY29kZWMuY2hhbm5lbHMpIGNvZGVjLmNoYW5uZWxzID0gMTtcblxuXHRcdFx0Ly8gQWRkIG1pbWVUeXBlLlxuXHRcdFx0Y29kZWMubWltZVR5cGUgPSBjb2RlYy5raW5kICsgJy8nICsgY29kZWMubmFtZTtcblxuXHRcdFx0Ly8gTk9URTogRWRnZSBzZXRzIHBhcmFtZXRlcnMuYXB0IGFzIFN0cmluZyByYXRoZXIgdGhhbiBOdW1iZXIuIEZpeCBpdC5cblx0XHRcdGlmIChjb2RlYy5uYW1lID09PSAncnR4JykgY29kZWMucGFyYW1ldGVycy5hcHQgPSBOdW1iZXIoY29kZWMucGFyYW1ldGVycy5hcHQpO1xuXG5cdFx0XHQvLyBEZWxldGUgZW10eSBwYXJhbWV0ZXIgU3RyaW5nIGluIHJ0Y3BGZWVkYmFjay5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gKGNvZGVjLnJ0Y3BGZWVkYmFjayB8fCBbXSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0XHR2YXIgZmVlZGJhY2sgPSBfc3RlcDIudmFsdWU7XG5cblx0XHRcdFx0XHRpZiAoIWZlZWRiYWNrLnBhcmFtZXRlcikgZGVsZXRlIGZlZWRiYWNrLnBhcmFtZXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yMiA9IGVycjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2Fwcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBSVENSdHBQYXJhbWV0ZXJzIGFzIEVkZ2UgbGlrZSB0aGVtLlxuICpcbiAqIEBwYXJhbSAge1JUQ1J0cFBhcmFtZXRlcnN9IHJ0cFBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge1JUQ1J0cFBhcmFtZXRlcnN9XG4gKi9cbi8qIGdsb2JhbCBSVENSdHBSZWNlaXZlciAqL1xuXG5mdW5jdGlvbiBtYW5nbGVSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpIHtcblx0dmFyIHBhcmFtcyA9IHV0aWxzLmNsb25lKHJ0cFBhcmFtZXRlcnMpO1xuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvcjMgPSBwYXJhbXMuY29kZWNzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG5cdFx0XHR2YXIgY29kZWMgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdC8vIFJlbmFtZSBjaGFubmVscyB0byBudW1DaGFubmVscy5cblx0XHRcdGlmIChjb2RlYy5jaGFubmVscykge1xuXHRcdFx0XHRjb2RlYy5udW1DaGFubmVscyA9IGNvZGVjLmNoYW5uZWxzO1xuXHRcdFx0XHRkZWxldGUgY29kZWMuY2hhbm5lbHM7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBtaW1lVHlwZS5cblx0XHRcdGRlbGV0ZSBjb2RlYy5taW1lVHlwZTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvcjMucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwYXJhbXM7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NkcFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3NkcC10cmFuc2Zvcm0nKTtcblxudmFyIF9zZHBUcmFuc2Zvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2RwVHJhbnNmb3JtKTtcblxudmFyIF9Mb2dnZXIgPSByZXF1aXJlKCcuLi8uLi9Mb2dnZXInKTtcblxudmFyIF9Mb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTG9nZ2VyKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGxvZ2dlciA9IG5ldyBfTG9nZ2VyMi5kZWZhdWx0KCdSZW1vdGVQbGFuQlNkcCcpO1xuXG52YXIgUmVtb3RlU2RwID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBSZW1vdGVTZHAocnRwUGFyYW1ldGVyc0J5S2luZCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1vdGVTZHApO1xuXG5cdFx0Ly8gR2VuZXJpYyBzZW5kaW5nIFJUUCBwYXJhbWV0ZXJzIGZvciBhdWRpbyBhbmQgdmlkZW8uXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kID0gcnRwUGFyYW1ldGVyc0J5S2luZDtcblxuXHRcdC8vIFRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLCBpbmNsdWRpbmcgRFRMUyBwYXJhbWV0ZXJlcy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3RyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IG51bGw7XG5cblx0XHQvLyBUcmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMsIGluY2x1ZGluZyBJQ0UgcGFyYW1ldGVycywgSUNFIGNhbmRpZGF0ZXNcblx0XHQvLyBhbmQgRFRMUyBwYXJhbWV0ZXJlcy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMgPSBudWxsO1xuXG5cdFx0Ly8gU0RQIGdsb2JhbCBmaWVsZHMuXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl9zZHBHbG9iYWxGaWVsZHMgPSB7XG5cdFx0XHRpZDogdXRpbHMucmFuZG9tTnVtYmVyKCksXG5cdFx0XHR2ZXJzaW9uOiAwXG5cdFx0fTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhSZW1vdGVTZHAsIFt7XG5cdFx0a2V5OiAnc2V0VHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycykge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdzZXRUcmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMoKSBbdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzOiVvXScsIHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyk7XG5cblx0XHRcdHRoaXMuX3RyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdzZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3NldFRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMoKSBbdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVyczolb10nLCB0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyA9IHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnM7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAndXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMocmVtb3RlSWNlUGFyYW1ldGVycykge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCd1cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzKCkgW3JlbW90ZUljZVBhcmFtZXRlcnM6JW9dJywgcmVtb3RlSWNlUGFyYW1ldGVycyk7XG5cblx0XHRcdHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuaWNlUGFyYW1ldGVycyA9IHJlbW90ZUljZVBhcmFtZXRlcnM7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFJlbW90ZVNkcDtcbn0oKTtcblxudmFyIFNlbmRSZW1vdGVTZHAgPSBmdW5jdGlvbiAoX1JlbW90ZVNkcCkge1xuXHRfaW5oZXJpdHMoU2VuZFJlbW90ZVNkcCwgX1JlbW90ZVNkcCk7XG5cblx0ZnVuY3Rpb24gU2VuZFJlbW90ZVNkcChydHBQYXJhbWV0ZXJzQnlLaW5kKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbmRSZW1vdGVTZHApO1xuXG5cdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTZW5kUmVtb3RlU2RwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2VuZFJlbW90ZVNkcCkpLmNhbGwodGhpcywgcnRwUGFyYW1ldGVyc0J5S2luZCkpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFNlbmRSZW1vdGVTZHAsIFt7XG5cdFx0a2V5OiAnY3JlYXRlQW5zd2VyU2RwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2NyZWF0ZUFuc3dlclNkcCgpJyk7XG5cblx0XHRcdGlmICghdGhpcy5fdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKSB0aHJvdyBuZXcgRXJyb3IoJ25vIHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzJyk7ZWxzZSBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpIHRocm93IG5ldyBFcnJvcignbm8gdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzJyk7XG5cblx0XHRcdHZhciByZW1vdGVJY2VQYXJhbWV0ZXJzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VQYXJhbWV0ZXJzO1xuXHRcdFx0dmFyIHJlbW90ZUljZUNhbmRpZGF0ZXMgPSB0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZUNhbmRpZGF0ZXM7XG5cdFx0XHR2YXIgcmVtb3RlRHRsc1BhcmFtZXRlcnMgPSB0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzO1xuXHRcdFx0dmFyIHNkcE9iaiA9IHt9O1xuXHRcdFx0dmFyIG1pZHMgPSAobG9jYWxTZHBPYmoubWVkaWEgfHwgW10pLm1hcChmdW5jdGlvbiAobSkge1xuXHRcdFx0XHRyZXR1cm4gbS5taWQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSW5jcmVhc2Ugb3VyIFNEUCB2ZXJzaW9uLlxuXHRcdFx0dGhpcy5fc2RwR2xvYmFsRmllbGRzLnZlcnNpb24rKztcblxuXHRcdFx0c2RwT2JqLnZlcnNpb24gPSAwO1xuXHRcdFx0c2RwT2JqLm9yaWdpbiA9IHtcblx0XHRcdFx0YWRkcmVzczogJzAuMC4wLjAnLFxuXHRcdFx0XHRpcFZlcjogNCxcblx0XHRcdFx0bmV0VHlwZTogJ0lOJyxcblx0XHRcdFx0c2Vzc2lvbklkOiB0aGlzLl9zZHBHbG9iYWxGaWVsZHMuaWQsXG5cdFx0XHRcdHNlc3Npb25WZXJzaW9uOiB0aGlzLl9zZHBHbG9iYWxGaWVsZHMudmVyc2lvbixcblx0XHRcdFx0dXNlcm5hbWU6ICdtZWRpYXNvdXAtY2xpZW50J1xuXHRcdFx0fTtcblx0XHRcdHNkcE9iai5uYW1lID0gJy0nO1xuXHRcdFx0c2RwT2JqLnRpbWluZyA9IHsgc3RhcnQ6IDAsIHN0b3A6IDAgfTtcblx0XHRcdHNkcE9iai5pY2VsaXRlID0gcmVtb3RlSWNlUGFyYW1ldGVycy5pY2VMaXRlID8gJ2ljZS1saXRlJyA6IG51bGw7XG5cdFx0XHRzZHBPYmoubXNpZFNlbWFudGljID0ge1xuXHRcdFx0XHRzZW1hbnRpYzogJ1dNUycsXG5cdFx0XHRcdHRva2VuOiAnKidcblx0XHRcdH07XG5cdFx0XHRzZHBPYmouZ3JvdXBzID0gW3tcblx0XHRcdFx0dHlwZTogJ0JVTkRMRScsXG5cdFx0XHRcdG1pZHM6IG1pZHMuam9pbignICcpXG5cdFx0XHR9XTtcblx0XHRcdHNkcE9iai5tZWRpYSA9IFtdO1xuXG5cdFx0XHQvLyBOT1RFOiBXZSB0YWtlIHRoZSBsYXRlc3QgZmluZ2VycHJpbnQuXG5cdFx0XHR2YXIgbnVtRmluZ2VycHJpbnRzID0gcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzLmxlbmd0aDtcblxuXHRcdFx0c2RwT2JqLmZpbmdlcnByaW50ID0ge1xuXHRcdFx0XHR0eXBlOiByZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0uYWxnb3JpdGhtLFxuXHRcdFx0XHRoYXNoOiByZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0udmFsdWVcblx0XHRcdH07XG5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSAobG9jYWxTZHBPYmoubWVkaWEgfHwgW10pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciBsb2NhbE1lZGlhT2JqID0gX3N0ZXAudmFsdWU7XG5cblx0XHRcdFx0XHR2YXIga2luZCA9IGxvY2FsTWVkaWFPYmoudHlwZTtcblx0XHRcdFx0XHR2YXIgY29kZWNzID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5jb2RlY3M7XG5cdFx0XHRcdFx0dmFyIGhlYWRlckV4dGVuc2lvbnMgPSB0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW2tpbmRdLmhlYWRlckV4dGVuc2lvbnM7XG5cdFx0XHRcdFx0dmFyIHJlbW90ZU1lZGlhT2JqID0ge307XG5cblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai50eXBlID0gbG9jYWxNZWRpYU9iai50eXBlO1xuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnBvcnQgPSA3O1xuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnByb3RvY29sID0gJ1JUUC9TQVZQRic7XG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouY29ubmVjdGlvbiA9IHsgaXA6ICcxMjcuMC4wLjEnLCB2ZXJzaW9uOiA0IH07XG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoubWlkID0gbG9jYWxNZWRpYU9iai5taWQ7XG5cblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5pY2VVZnJhZyA9IHJlbW90ZUljZVBhcmFtZXRlcnMudXNlcm5hbWVGcmFnbWVudDtcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5pY2VQd2QgPSByZW1vdGVJY2VQYXJhbWV0ZXJzLnBhc3N3b3JkO1xuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmNhbmRpZGF0ZXMgPSBbXTtcblxuXHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0XHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuXHRcdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMiA9IHJlbW90ZUljZUNhbmRpZGF0ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGNhbmRpZGF0ZSA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgY2FuZGlkYXRlT2JqID0ge307XG5cblx0XHRcdFx0XHRcdFx0Ly8gbWVkaWFzb3VwIGRvZXMgbm90IHN1cHBvcnQgbm9uIHJ0Y3AtbXV4IHNvIGNhbmRpZGF0ZXMgY29tcG9uZW50IGlzXG5cdFx0XHRcdFx0XHRcdC8vIGFsd2F5cyBSVFAgKDEpLlxuXHRcdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmouY29tcG9uZW50ID0gMTtcblx0XHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLmZvdW5kYXRpb24gPSBjYW5kaWRhdGUuZm91bmRhdGlvbjtcblx0XHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLmlwID0gY2FuZGlkYXRlLmlwO1xuXHRcdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmoucG9ydCA9IGNhbmRpZGF0ZS5wb3J0O1xuXHRcdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmoucHJpb3JpdHkgPSBjYW5kaWRhdGUucHJpb3JpdHk7XG5cdFx0XHRcdFx0XHRcdGNhbmRpZGF0ZU9iai50cmFuc3BvcnQgPSBjYW5kaWRhdGUucHJvdG9jb2w7XG5cdFx0XHRcdFx0XHRcdGNhbmRpZGF0ZU9iai50eXBlID0gY2FuZGlkYXRlLnR5cGU7XG5cdFx0XHRcdFx0XHRcdGlmIChjYW5kaWRhdGUudGNwVHlwZSkgY2FuZGlkYXRlT2JqLnRjcHR5cGUgPSBjYW5kaWRhdGUudGNwVHlwZTtcblxuXHRcdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5jYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlT2JqKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZW5kT2ZDYW5kaWRhdGVzID0gJ2VuZC1vZi1jYW5kaWRhdGVzJztcblxuXHRcdFx0XHRcdC8vIEFubm91bmNlIHN1cHBvcnQgZm9yIElDRSByZW5vbWluYXRpb24uXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXRoYXRjaGVyLWljZS1yZW5vbWluYXRpb25cblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5pY2VPcHRpb25zID0gJ3Jlbm9taW5hdGlvbic7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKHJlbW90ZUR0bHNQYXJhbWV0ZXJzLnJvbGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2NsaWVudCc6XG5cdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNldHVwID0gJ2FjdGl2ZSc7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnc2VydmVyJzpcblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc2V0dXAgPSAncGFzc2l2ZSc7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN3aXRjaCAobG9jYWxNZWRpYU9iai5kaXJlY3Rpb24pIHtcblx0XHRcdFx0XHRcdGNhc2UgJ3NlbmRyZWN2Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ3NlbmRvbmx5Jzpcblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZGlyZWN0aW9uID0gJ3JlY3Zvbmx5Jztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdyZWN2b25seSc6XG5cdFx0XHRcdFx0XHRjYXNlICdpbmFjdGl2ZSc6XG5cdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElmIHZpZGVvLCBiZSByZWFkeSBmb3Igc2ltdWxjYXN0LlxuXHRcdFx0XHRcdGlmIChraW5kID09PSAndmlkZW8nKSByZW1vdGVNZWRpYU9iai54R29vZ2xlRmxhZyA9ICdjb25mZXJlbmNlJztcblxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0cCA9IFtdO1xuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BGYiA9IFtdO1xuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmZtdHAgPSBbXTtcblxuXHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG5cdFx0XHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IGNvZGVjc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgY29kZWMgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHJ0cCA9IHtcblx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRcdFx0XHRjb2RlYzogY29kZWMubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRyYXRlOiBjb2RlYy5jbG9ja1JhdGVcblx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoY29kZWMuY2hhbm5lbHMgPiAxKSBydHAuZW5jb2RpbmcgPSBjb2RlYy5jaGFubmVscztcblxuXHRcdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydHAucHVzaChydHApO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChjb2RlYy5wYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHBhcmFtRm10cCA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uZmlnOiAnJ1xuXHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjUgPSBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IChfc3RlcDUgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIga2V5ID0gX3N0ZXA1LnZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChwYXJhbUZtdHAuY29uZmlnKSBwYXJhbUZtdHAuY29uZmlnICs9ICc7JztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJhbUZtdHAuY29uZmlnICs9IGtleSArICc9JyArIGNvZGVjLnBhcmFtZXRlcnNba2V5XTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjUgPSBlcnI7XG5cdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3I1LnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBhcmFtRm10cC5jb25maWcpIHJlbW90ZU1lZGlhT2JqLmZtdHAucHVzaChwYXJhbUZtdHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yNiA9IGNvZGVjLnJ0Y3BGZWVkYmFja1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZmIgPSBfc3RlcDYudmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcEZiLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IGZiLnR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3VidHlwZTogZmIucGFyYW1ldGVyIHx8ICcnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdF9pdGVyYXRvckVycm9yNiA9IGVycjtcblx0XHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9pdGVyYXRvcjYucmV0dXJuKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjY7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucGF5bG9hZHMgPSBjb2RlY3MubWFwKGZ1bmN0aW9uIChjb2RlYykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuXHRcdFx0XHRcdH0pLmpvaW4oJyAnKTtcblxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmV4dCA9IFtdO1xuXG5cdFx0XHRcdFx0dmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoZXh0KSB7XG5cdFx0XHRcdFx0XHQvLyBEb24ndCBhZGQgYSBoZWFkZXIgZXh0ZW5zaW9uIGlmIG5vdCBwcmVzZW50IGluIHRoZSBvZmZlci5cblx0XHRcdFx0XHRcdHZhciBtYXRjaGVkTG9jYWxFeHQgPSAobG9jYWxNZWRpYU9iai5leHQgfHwgW10pLmZpbmQoZnVuY3Rpb24gKGxvY2FsRXh0KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBsb2NhbEV4dC51cmkgPT09IGV4dC51cmk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaGVkTG9jYWxFeHQpIHJldHVybiAnY29udGludWUnO1xuXG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5leHQucHVzaCh7XG5cdFx0XHRcdFx0XHRcdHVyaTogZXh0LnVyaSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGV4dC5pZFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG5cdFx0XHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuXHRcdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yNCA9IGhlYWRlckV4dGVuc2lvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGV4dCA9IF9zdGVwNC52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgX3JldCA9IF9sb29wKGV4dCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKF9yZXQgPT09ICdjb250aW51ZScpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdF9pdGVyYXRvckVycm9yNCA9IGVycjtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuXHRcdFx0XHRcdFx0XHRcdF9pdGVyYXRvcjQucmV0dXJuKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydGNwTXV4ID0gJ3J0Y3AtbXV4Jztcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydGNwUnNpemUgPSAncnRjcC1yc2l6ZSc7XG5cblx0XHRcdFx0XHQvLyBQdXNoIGl0LlxuXHRcdFx0XHRcdHNkcE9iai5tZWRpYS5wdXNoKHJlbW90ZU1lZGlhT2JqKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzZHAgPSBfc2RwVHJhbnNmb3JtMi5kZWZhdWx0LndyaXRlKHNkcE9iaik7XG5cblx0XHRcdHJldHVybiBzZHA7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFNlbmRSZW1vdGVTZHA7XG59KFJlbW90ZVNkcCk7XG5cbnZhciBSZWN2UmVtb3RlU2RwID0gZnVuY3Rpb24gKF9SZW1vdGVTZHAyKSB7XG5cdF9pbmhlcml0cyhSZWN2UmVtb3RlU2RwLCBfUmVtb3RlU2RwMik7XG5cblx0ZnVuY3Rpb24gUmVjdlJlbW90ZVNkcChydHBQYXJhbWV0ZXJzQnlLaW5kKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY3ZSZW1vdGVTZHApO1xuXG5cdFx0Ly8gSWQgb2YgdGhlIHVuaXF1ZSBNZWRpYVN0cmVhbSBmb3IgYWxsIHRoZSByZW1vdGUgdHJhY2tzLlxuXHRcdHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmVjdlJlbW90ZVNkcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJlY3ZSZW1vdGVTZHApKS5jYWxsKHRoaXMsIHJ0cFBhcmFtZXRlcnNCeUtpbmQpKTtcblxuXHRcdF90aGlzMi5fc3RyZWFtSWQgPSAncmVjdi1zdHJlYW0tJyArIHV0aWxzLnJhbmRvbU51bWJlcigpO1xuXHRcdHJldHVybiBfdGhpczI7XG5cdH1cblxuXHQvKipcbiAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IGtpbmRzIC0gTWVkaWEga2luZHMuXG4gICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjb25zdW1lckluZm9zIC0gQ29uc3VtZXIgaW5mb3JtYXRpb25zLlxuICAqIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhSZWN2UmVtb3RlU2RwLCBbe1xuXHRcdGtleTogJ2NyZWF0ZU9mZmVyU2RwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY3JlYXRlT2ZmZXJTZHAoa2luZHMsIGNvbnN1bWVySW5mb3MpIHtcblx0XHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ2NyZWF0ZU9mZmVyU2RwKCknKTtcblxuXHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKSB0aHJvdyBuZXcgRXJyb3IoJ25vIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycycpO1xuXG5cdFx0XHR2YXIgcmVtb3RlSWNlUGFyYW1ldGVycyA9IHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuaWNlUGFyYW1ldGVycztcblx0XHRcdHZhciByZW1vdGVJY2VDYW5kaWRhdGVzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VDYW5kaWRhdGVzO1xuXHRcdFx0dmFyIHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5kdGxzUGFyYW1ldGVycztcblx0XHRcdHZhciBzZHBPYmogPSB7fTtcblx0XHRcdHZhciBtaWRzID0ga2luZHM7XG5cblx0XHRcdC8vIEluY3JlYXNlIG91ciBTRFAgdmVyc2lvbi5cblx0XHRcdHRoaXMuX3NkcEdsb2JhbEZpZWxkcy52ZXJzaW9uKys7XG5cblx0XHRcdHNkcE9iai52ZXJzaW9uID0gMDtcblx0XHRcdHNkcE9iai5vcmlnaW4gPSB7XG5cdFx0XHRcdGFkZHJlc3M6ICcwLjAuMC4wJyxcblx0XHRcdFx0aXBWZXI6IDQsXG5cdFx0XHRcdG5ldFR5cGU6ICdJTicsXG5cdFx0XHRcdHNlc3Npb25JZDogdGhpcy5fc2RwR2xvYmFsRmllbGRzLmlkLFxuXHRcdFx0XHRzZXNzaW9uVmVyc2lvbjogdGhpcy5fc2RwR2xvYmFsRmllbGRzLnZlcnNpb24sXG5cdFx0XHRcdHVzZXJuYW1lOiAnbWVkaWFzb3VwLWNsaWVudCdcblx0XHRcdH07XG5cdFx0XHRzZHBPYmoubmFtZSA9ICctJztcblx0XHRcdHNkcE9iai50aW1pbmcgPSB7IHN0YXJ0OiAwLCBzdG9wOiAwIH07XG5cdFx0XHRzZHBPYmouaWNlbGl0ZSA9IHJlbW90ZUljZVBhcmFtZXRlcnMuaWNlTGl0ZSA/ICdpY2UtbGl0ZScgOiBudWxsO1xuXHRcdFx0c2RwT2JqLm1zaWRTZW1hbnRpYyA9IHtcblx0XHRcdFx0c2VtYW50aWM6ICdXTVMnLFxuXHRcdFx0XHR0b2tlbjogJyonXG5cdFx0XHR9O1xuXHRcdFx0c2RwT2JqLmdyb3VwcyA9IFt7XG5cdFx0XHRcdHR5cGU6ICdCVU5ETEUnLFxuXHRcdFx0XHRtaWRzOiBtaWRzLmpvaW4oJyAnKVxuXHRcdFx0fV07XG5cdFx0XHRzZHBPYmoubWVkaWEgPSBbXTtcblxuXHRcdFx0Ly8gTk9URTogV2UgdGFrZSB0aGUgbGF0ZXN0IGZpbmdlcnByaW50LlxuXHRcdFx0dmFyIG51bUZpbmdlcnByaW50cyA9IHJlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50cy5sZW5ndGg7XG5cblx0XHRcdHNkcE9iai5maW5nZXJwcmludCA9IHtcblx0XHRcdFx0dHlwZTogcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzW251bUZpbmdlcnByaW50cyAtIDFdLmFsZ29yaXRobSxcblx0XHRcdFx0aGFzaDogcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzW251bUZpbmdlcnByaW50cyAtIDFdLnZhbHVlXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKGtpbmQpIHtcblx0XHRcdFx0dmFyIGNvZGVjcyA9IF90aGlzMy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5jb2RlY3M7XG5cdFx0XHRcdHZhciBoZWFkZXJFeHRlbnNpb25zID0gX3RoaXMzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW2tpbmRdLmhlYWRlckV4dGVuc2lvbnM7XG5cdFx0XHRcdHZhciByZW1vdGVNZWRpYU9iaiA9IHt9O1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnR5cGUgPSBraW5kO1xuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5wb3J0ID0gNztcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucHJvdG9jb2wgPSAnUlRQL1NBVlBGJztcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmouY29ubmVjdGlvbiA9IHsgaXA6ICcxMjcuMC4wLjEnLCB2ZXJzaW9uOiA0IH07XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLm1pZCA9IGtpbmQ7XG5cblx0XHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlVWZyYWcgPSByZW1vdGVJY2VQYXJhbWV0ZXJzLnVzZXJuYW1lRnJhZ21lbnQ7XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmljZVB3ZCA9IHJlbW90ZUljZVBhcmFtZXRlcnMucGFzc3dvcmQ7XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmNhbmRpZGF0ZXMgPSBbXTtcblxuXHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlO1xuXHRcdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I4ID0gZmFsc2U7XG5cdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjggPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3I4ID0gcmVtb3RlSWNlQ2FuZGlkYXRlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwODsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IChfc3RlcDggPSBfaXRlcmF0b3I4Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGNhbmRpZGF0ZSA9IF9zdGVwOC52YWx1ZTtcblxuXHRcdFx0XHRcdFx0dmFyIGNhbmRpZGF0ZU9iaiA9IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBtZWRpYXNvdXAgZG9lcyBub3Qgc3VwcG9ydCBub24gcnRjcC1tdXggc28gY2FuZGlkYXRlcyBjb21wb25lbnQgaXNcblx0XHRcdFx0XHRcdC8vIGFsd2F5cyBSVFAgKDEpLlxuXHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLmNvbXBvbmVudCA9IDE7XG5cdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmouZm91bmRhdGlvbiA9IGNhbmRpZGF0ZS5mb3VuZGF0aW9uO1xuXHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLmlwID0gY2FuZGlkYXRlLmlwO1xuXHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLnBvcnQgPSBjYW5kaWRhdGUucG9ydDtcblx0XHRcdFx0XHRcdGNhbmRpZGF0ZU9iai5wcmlvcml0eSA9IGNhbmRpZGF0ZS5wcmlvcml0eTtcblx0XHRcdFx0XHRcdGNhbmRpZGF0ZU9iai50cmFuc3BvcnQgPSBjYW5kaWRhdGUucHJvdG9jb2w7XG5cdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmoudHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuXHRcdFx0XHRcdFx0aWYgKGNhbmRpZGF0ZS50Y3BUeXBlKSBjYW5kaWRhdGVPYmoudGNwdHlwZSA9IGNhbmRpZGF0ZS50Y3BUeXBlO1xuXG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5jYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlT2JqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yOCA9IHRydWU7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3I4ID0gZXJyO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ICYmIF9pdGVyYXRvcjgucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdF9pdGVyYXRvcjgucmV0dXJuKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjgpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I4O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmVuZE9mQ2FuZGlkYXRlcyA9ICdlbmQtb2YtY2FuZGlkYXRlcyc7XG5cblx0XHRcdFx0Ly8gQW5ub3VuY2Ugc3VwcG9ydCBmb3IgSUNFIHJlbm9taW5hdGlvbi5cblx0XHRcdFx0Ly8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXRoYXRjaGVyLWljZS1yZW5vbWluYXRpb25cblx0XHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlT3B0aW9ucyA9ICdyZW5vbWluYXRpb24nO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNldHVwID0gJ2FjdHBhc3MnO1xuXG5cdFx0XHRcdGlmIChjb25zdW1lckluZm9zLnNvbWUoZnVuY3Rpb24gKGluZm8pIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5mby5raW5kID09PSBraW5kO1xuXHRcdFx0XHR9KSkgcmVtb3RlTWVkaWFPYmouZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztlbHNlIHJlbW90ZU1lZGlhT2JqLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG5cblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRwID0gW107XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BGYiA9IFtdO1xuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5mbXRwID0gW107XG5cblx0XHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZTtcblx0XHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yOSA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I5ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yOSA9IGNvZGVjc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IChfc3RlcDkgPSBfaXRlcmF0b3I5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGNvZGVjID0gX3N0ZXA5LnZhbHVlO1xuXG5cdFx0XHRcdFx0XHR2YXIgcnRwID0ge1xuXHRcdFx0XHRcdFx0XHRwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRcdFx0Y29kZWM6IGNvZGVjLm5hbWUsXG5cdFx0XHRcdFx0XHRcdHJhdGU6IGNvZGVjLmNsb2NrUmF0ZVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKGNvZGVjLmNoYW5uZWxzID4gMSkgcnRwLmVuY29kaW5nID0gY29kZWMuY2hhbm5lbHM7XG5cblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0cC5wdXNoKHJ0cCk7XG5cblx0XHRcdFx0XHRcdGlmIChjb2RlYy5wYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwYXJhbUZtdHAgPSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0Y29uZmlnOiAnJ1xuXHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IxMiA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjEyID0gT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDEyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiA9IChfc3RlcDEyID0gX2l0ZXJhdG9yMTIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEyID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGtleSA9IF9zdGVwMTIudmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChwYXJhbUZtdHAuY29uZmlnKSBwYXJhbUZtdHAuY29uZmlnICs9ICc7JztcblxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyYW1GbXRwLmNvbmZpZyArPSBrZXkgKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW2tleV07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjEyID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjEyID0gZXJyO1xuXHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiAmJiBfaXRlcmF0b3IxMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yMTIucmV0dXJuKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjEyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMTI7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKHBhcmFtRm10cC5jb25maWcpIHJlbW90ZU1lZGlhT2JqLmZtdHAucHVzaChwYXJhbUZtdHApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoY29kZWMucnRjcEZlZWRiYWNrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IxMyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjEzID0gY29kZWMucnRjcEZlZWRiYWNrW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgPSAoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBmYiA9IF9zdGVwMTMudmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BGYi5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IGZiLnR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN1YnR5cGU6IGZiLnBhcmFtZXRlciB8fCAnJ1xuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjEzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjEzID0gZXJyO1xuXHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyAmJiBfaXRlcmF0b3IxMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yMTMucmV0dXJuKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjEzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMTM7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjkgPSB0cnVlO1xuXHRcdFx0XHRcdF9pdGVyYXRvckVycm9yOSA9IGVycjtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSAmJiBfaXRlcmF0b3I5LnJldHVybikge1xuXHRcdFx0XHRcdFx0XHRfaXRlcmF0b3I5LnJldHVybigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I5KSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yOTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5wYXlsb2FkcyA9IGNvZGVjcy5tYXAoZnVuY3Rpb24gKGNvZGVjKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuXHRcdFx0XHR9KS5qb2luKCcgJyk7XG5cblx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZXh0ID0gW107XG5cblx0XHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWU7XG5cdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjEwID0gZmFsc2U7XG5cdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjEwID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMTAgPSBoZWFkZXJFeHRlbnNpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSAoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWUpIHtcblx0XHRcdFx0XHRcdHZhciBleHQgPSBfc3RlcDEwLnZhbHVlO1xuXG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5leHQucHVzaCh7XG5cdFx0XHRcdFx0XHRcdHVyaTogZXh0LnVyaSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGV4dC5pZFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjEwID0gdHJ1ZTtcblx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjEwID0gZXJyO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCAmJiBfaXRlcmF0b3IxMC5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yMTAucmV0dXJuKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjEwKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMTA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcE11eCA9ICdydGNwLW11eCc7XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BSc2l6ZSA9ICdydGNwLXJzaXplJztcblxuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zc3JjcyA9IFtdO1xuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zc3JjR3JvdXBzID0gW107XG5cblx0XHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWU7XG5cdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjExID0gZmFsc2U7XG5cdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjExID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMTEgPSBjb25zdW1lckluZm9zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSAoX3N0ZXAxMSA9IF9pdGVyYXRvcjExLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWUpIHtcblx0XHRcdFx0XHRcdHZhciBpbmZvID0gX3N0ZXAxMS52YWx1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKGluZm8ua2luZCAhPT0ga2luZCkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRpZDogaW5mby5zc3JjLFxuXHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGU6ICdtc2lkJyxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IF90aGlzMy5fc3RyZWFtSWQgKyAnICcgKyBpbmZvLnRyYWNrSWRcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zc3Jjcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aWQ6IGluZm8uc3NyYyxcblx0XHRcdFx0XHRcdFx0YXR0cmlidXRlOiAnbXNsYWJlbCcsXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBfdGhpczMuX3N0cmVhbUlkXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MucHVzaCh7XG5cdFx0XHRcdFx0XHRcdGlkOiBpbmZvLnNzcmMsXG5cdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZTogJ2xhYmVsJyxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGluZm8udHJhY2tJZFxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRpZDogaW5mby5zc3JjLFxuXHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGU6ICdjbmFtZScsXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBpbmZvLmNuYW1lXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aWYgKGluZm8ucnR4U3NyYykge1xuXHRcdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zc3Jjcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRpZDogaW5mby5ydHhTc3JjLFxuXHRcdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZTogJ21zaWQnLFxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBfdGhpczMuX3N0cmVhbUlkICsgJyAnICsgaW5mby50cmFja0lkXG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdGlkOiBpbmZvLnJ0eFNzcmMsXG5cdFx0XHRcdFx0XHRcdFx0YXR0cmlidXRlOiAnbXNsYWJlbCcsXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU6IF90aGlzMy5fc3RyZWFtSWRcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0aWQ6IGluZm8ucnR4U3NyYyxcblx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGU6ICdsYWJlbCcsXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU6IGluZm8udHJhY2tJZFxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zc3Jjcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRpZDogaW5mby5ydHhTc3JjLFxuXHRcdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZTogJ2NuYW1lJyxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogaW5mby5jbmFtZVxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NvY2lhdGUgb3JpZ2luYWwgYW5kIHJldHJhbnNtaXNzaW9uIFNTUkMuXG5cdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNHcm91cHMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0c2VtYW50aWNzOiAnRklEJyxcblx0XHRcdFx0XHRcdFx0XHRzc3JjczogaW5mby5zc3JjICsgJyAnICsgaW5mby5ydHhTc3JjXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFB1c2ggaXQuXG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMTEgPSB0cnVlO1xuXHRcdFx0XHRcdF9pdGVyYXRvckVycm9yMTEgPSBlcnI7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExICYmIF9pdGVyYXRvcjExLnJldHVybikge1xuXHRcdFx0XHRcdFx0XHRfaXRlcmF0b3IxMS5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMTEpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IxMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZHBPYmoubWVkaWEucHVzaChyZW1vdGVNZWRpYU9iaik7XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yNyA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yNyA9IGtpbmRzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7XG5cdFx0XHRcdFx0dmFyIGtpbmQgPSBfc3RlcDcudmFsdWU7XG5cblx0XHRcdFx0XHRfbG9vcDIoa2luZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuXHRcdFx0XHRfaXRlcmF0b3JFcnJvcjcgPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdF9pdGVyYXRvcjcucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjcpIHtcblx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yNztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNkcCA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQud3JpdGUoc2RwT2JqKTtcblxuXHRcdFx0cmV0dXJuIHNkcDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gUmVjdlJlbW90ZVNkcDtcbn0oUmVtb3RlU2RwKTtcblxudmFyIFJlbW90ZVBsYW5CU2RwID0gZnVuY3Rpb24gUmVtb3RlUGxhbkJTZHAoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kKSB7XG5cdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1vdGVQbGFuQlNkcCk7XG5cblx0bG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIHJ0cFBhcmFtZXRlcnNCeUtpbmQ6JW9dJywgZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kKTtcblxuXHRzd2l0Y2ggKGRpcmVjdGlvbikge1xuXHRcdGNhc2UgJ3NlbmQnOlxuXHRcdFx0cmV0dXJuIG5ldyBTZW5kUmVtb3RlU2RwKHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXHRcdGNhc2UgJ3JlY3YnOlxuXHRcdFx0cmV0dXJuIG5ldyBSZWN2UmVtb3RlU2RwKHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZW1vdGVQbGFuQlNkcDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc2RwVHJhbnNmb3JtID0gcmVxdWlyZSgnc2RwLXRyYW5zZm9ybScpO1xuXG52YXIgX3NkcFRyYW5zZm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZHBUcmFuc2Zvcm0pO1xuXG52YXIgX0xvZ2dlciA9IHJlcXVpcmUoJy4uLy4uL0xvZ2dlcicpO1xuXG52YXIgX0xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Mb2dnZXIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgbG9nZ2VyID0gbmV3IF9Mb2dnZXIyLmRlZmF1bHQoJ1JlbW90ZVVuaWZpZWRQbGFuU2RwJyk7XG5cbnZhciBSZW1vdGVTZHAgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIFJlbW90ZVNkcChydHBQYXJhbWV0ZXJzQnlLaW5kKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbW90ZVNkcCk7XG5cblx0XHQvLyBHZW5lcmljIHNlbmRpbmcgUlRQIHBhcmFtZXRlcnMgZm9yIGF1ZGlvIGFuZCB2aWRlby5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmQgPSBydHBQYXJhbWV0ZXJzQnlLaW5kO1xuXG5cdFx0Ly8gVHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMsIGluY2x1ZGluZyBEVExTIHBhcmFtZXRlcmVzLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0dGhpcy5fdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0gbnVsbDtcblxuXHRcdC8vIFRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycywgaW5jbHVkaW5nIElDRSBwYXJhbWV0ZXJzLCBJQ0UgY2FuZGlkYXRlc1xuXHRcdC8vIGFuZCBEVExTIHBhcmFtZXRlcmVzLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0dGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyA9IG51bGw7XG5cblx0XHQvLyBTRFAgZ2xvYmFsIGZpZWxkcy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3NkcEdsb2JhbEZpZWxkcyA9IHtcblx0XHRcdGlkOiB1dGlscy5yYW5kb21OdW1iZXIoKSxcblx0XHRcdHZlcnNpb246IDBcblx0XHR9O1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFJlbW90ZVNkcCwgW3tcblx0XHRrZXk6ICdzZXRUcmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRUcmFuc3BvcnRMb2NhbFBhcmFtZXRlcnModHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3NldFRyYW5zcG9ydExvY2FsUGFyYW1ldGVycygpIFt0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnM6JW9dJywgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0gdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3NldFRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpIHtcblx0XHRcdGxvZ2dlci5kZWJ1Zygnc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycygpIFt0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzOiVvXScsIHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHR0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzID0gdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICd1cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycyhyZW1vdGVJY2VQYXJhbWV0ZXJzKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3VwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMoKSBbcmVtb3RlSWNlUGFyYW1ldGVyczolb10nLCByZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VQYXJhbWV0ZXJzID0gcmVtb3RlSWNlUGFyYW1ldGVycztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gUmVtb3RlU2RwO1xufSgpO1xuXG52YXIgU2VuZFJlbW90ZVNkcCA9IGZ1bmN0aW9uIChfUmVtb3RlU2RwKSB7XG5cdF9pbmhlcml0cyhTZW5kUmVtb3RlU2RwLCBfUmVtb3RlU2RwKTtcblxuXHRmdW5jdGlvbiBTZW5kUmVtb3RlU2RwKHJ0cFBhcmFtZXRlcnNCeUtpbmQpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VuZFJlbW90ZVNkcCk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNlbmRSZW1vdGVTZHAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTZW5kUmVtb3RlU2RwKSkuY2FsbCh0aGlzLCBydHBQYXJhbWV0ZXJzQnlLaW5kKSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU2VuZFJlbW90ZVNkcCwgW3tcblx0XHRrZXk6ICdjcmVhdGVBbnN3ZXJTZHAnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnY3JlYXRlQW5zd2VyU2RwKCknKTtcblxuXHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpIHRocm93IG5ldyBFcnJvcignbm8gdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMnKTtlbHNlIGlmICghdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgdGhyb3cgbmV3IEVycm9yKCdubyB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMnKTtcblxuXHRcdFx0dmFyIHJlbW90ZUljZVBhcmFtZXRlcnMgPSB0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZVBhcmFtZXRlcnM7XG5cdFx0XHR2YXIgcmVtb3RlSWNlQ2FuZGlkYXRlcyA9IHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuaWNlQ2FuZGlkYXRlcztcblx0XHRcdHZhciByZW1vdGVEdGxzUGFyYW1ldGVycyA9IHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuZHRsc1BhcmFtZXRlcnM7XG5cdFx0XHR2YXIgc2RwT2JqID0ge307XG5cdFx0XHR2YXIgbWlkcyA9IChsb2NhbFNkcE9iai5tZWRpYSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG5cdFx0XHRcdHJldHVybiBtLm1pZDtcblx0XHRcdH0pLm1hcChmdW5jdGlvbiAobSkge1xuXHRcdFx0XHRyZXR1cm4gbS5taWQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSW5jcmVhc2Ugb3VyIFNEUCB2ZXJzaW9uLlxuXHRcdFx0dGhpcy5fc2RwR2xvYmFsRmllbGRzLnZlcnNpb24rKztcblxuXHRcdFx0c2RwT2JqLnZlcnNpb24gPSAwO1xuXHRcdFx0c2RwT2JqLm9yaWdpbiA9IHtcblx0XHRcdFx0YWRkcmVzczogJzAuMC4wLjAnLFxuXHRcdFx0XHRpcFZlcjogNCxcblx0XHRcdFx0bmV0VHlwZTogJ0lOJyxcblx0XHRcdFx0c2Vzc2lvbklkOiB0aGlzLl9zZHBHbG9iYWxGaWVsZHMuaWQsXG5cdFx0XHRcdHNlc3Npb25WZXJzaW9uOiB0aGlzLl9zZHBHbG9iYWxGaWVsZHMudmVyc2lvbixcblx0XHRcdFx0dXNlcm5hbWU6ICdtZWRpYXNvdXAtY2xpZW50J1xuXHRcdFx0fTtcblx0XHRcdHNkcE9iai5uYW1lID0gJy0nO1xuXHRcdFx0c2RwT2JqLnRpbWluZyA9IHsgc3RhcnQ6IDAsIHN0b3A6IDAgfTtcblx0XHRcdHNkcE9iai5pY2VsaXRlID0gcmVtb3RlSWNlUGFyYW1ldGVycy5pY2VMaXRlID8gJ2ljZS1saXRlJyA6IG51bGw7XG5cdFx0XHRzZHBPYmoubXNpZFNlbWFudGljID0ge1xuXHRcdFx0XHRzZW1hbnRpYzogJ1dNUycsXG5cdFx0XHRcdHRva2VuOiAnKidcblx0XHRcdH07XG5cblx0XHRcdGlmIChtaWRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0c2RwT2JqLmdyb3VwcyA9IFt7XG5cdFx0XHRcdFx0dHlwZTogJ0JVTkRMRScsXG5cdFx0XHRcdFx0bWlkczogbWlkcy5qb2luKCcgJylcblx0XHRcdFx0fV07XG5cdFx0XHR9XG5cblx0XHRcdHNkcE9iai5tZWRpYSA9IFtdO1xuXG5cdFx0XHQvLyBOT1RFOiBXZSB0YWtlIHRoZSBsYXRlc3QgZmluZ2VycHJpbnQuXG5cdFx0XHR2YXIgbnVtRmluZ2VycHJpbnRzID0gcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzLmxlbmd0aDtcblxuXHRcdFx0c2RwT2JqLmZpbmdlcnByaW50ID0ge1xuXHRcdFx0XHR0eXBlOiByZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0uYWxnb3JpdGhtLFxuXHRcdFx0XHRoYXNoOiByZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0udmFsdWVcblx0XHRcdH07XG5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSAobG9jYWxTZHBPYmoubWVkaWEgfHwgW10pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciBsb2NhbE1lZGlhT2JqID0gX3N0ZXAudmFsdWU7XG5cblx0XHRcdFx0XHR2YXIgY2xvc2VkID0gbG9jYWxNZWRpYU9iai5kaXJlY3Rpb24gPT09ICdpbmFjdGl2ZSc7XG5cdFx0XHRcdFx0dmFyIGtpbmQgPSBsb2NhbE1lZGlhT2JqLnR5cGU7XG5cdFx0XHRcdFx0dmFyIGNvZGVjcyA9IHRoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmRba2luZF0uY29kZWNzO1xuXHRcdFx0XHRcdHZhciBoZWFkZXJFeHRlbnNpb25zID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5oZWFkZXJFeHRlbnNpb25zO1xuXHRcdFx0XHRcdHZhciByZW1vdGVNZWRpYU9iaiA9IHt9O1xuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoudHlwZSA9IGxvY2FsTWVkaWFPYmoudHlwZTtcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5wb3J0ID0gNztcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5wcm90b2NvbCA9ICdSVFAvU0FWUEYnO1xuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmNvbm5lY3Rpb24gPSB7IGlwOiAnMTI3LjAuMC4xJywgdmVyc2lvbjogNCB9O1xuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLm1pZCA9IGxvY2FsTWVkaWFPYmoubWlkO1xuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlVWZyYWcgPSByZW1vdGVJY2VQYXJhbWV0ZXJzLnVzZXJuYW1lRnJhZ21lbnQ7XG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlUHdkID0gcmVtb3RlSWNlUGFyYW1ldGVycy5wYXNzd29yZDtcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5jYW5kaWRhdGVzID0gW107XG5cblx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcblx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjIgPSByZW1vdGVJY2VDYW5kaWRhdGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjYW5kaWRhdGUgPSBfc3RlcDIudmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGNhbmRpZGF0ZU9iaiA9IHt9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIG1lZGlhc291cCBkb2VzIG5vdCBzdXBwb3J0IG5vbiBydGNwLW11eCBzbyBjYW5kaWRhdGVzIGNvbXBvbmVudCBpc1xuXHRcdFx0XHRcdFx0XHQvLyBhbHdheXMgUlRQICgxKS5cblx0XHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLmNvbXBvbmVudCA9IDE7XG5cdFx0XHRcdFx0XHRcdGNhbmRpZGF0ZU9iai5mb3VuZGF0aW9uID0gY2FuZGlkYXRlLmZvdW5kYXRpb247XG5cdFx0XHRcdFx0XHRcdGNhbmRpZGF0ZU9iai5pcCA9IGNhbmRpZGF0ZS5pcDtcblx0XHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLnBvcnQgPSBjYW5kaWRhdGUucG9ydDtcblx0XHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLnByaW9yaXR5ID0gY2FuZGlkYXRlLnByaW9yaXR5O1xuXHRcdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmoudHJhbnNwb3J0ID0gY2FuZGlkYXRlLnByb3RvY29sO1xuXHRcdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmoudHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuXHRcdFx0XHRcdFx0XHRpZiAoY2FuZGlkYXRlLnRjcFR5cGUpIGNhbmRpZGF0ZU9iai50Y3B0eXBlID0gY2FuZGlkYXRlLnRjcFR5cGU7XG5cblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouY2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZU9iaik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmVuZE9mQ2FuZGlkYXRlcyA9ICdlbmQtb2YtY2FuZGlkYXRlcyc7XG5cblx0XHRcdFx0XHQvLyBBbm5vdW5jZSBzdXBwb3J0IGZvciBJQ0UgcmVub21pbmF0aW9uLlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC10aGF0Y2hlci1pY2UtcmVub21pbmF0aW9uXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlT3B0aW9ucyA9ICdyZW5vbWluYXRpb24nO1xuXG5cdFx0XHRcdFx0c3dpdGNoIChyZW1vdGVEdGxzUGFyYW1ldGVycy5yb2xlKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdjbGllbnQnOlxuXHRcdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zZXR1cCA9ICdhY3RpdmUnO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3NlcnZlcic6XG5cdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNldHVwID0gJ3Bhc3NpdmUnO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzd2l0Y2ggKGxvY2FsTWVkaWFPYmouZGlyZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdzZW5kcmVjdic6XG5cdFx0XHRcdFx0XHRjYXNlICdzZW5kb25seSc6XG5cdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmRpcmVjdGlvbiA9ICdyZWN2b25seSc7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAncmVjdm9ubHknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnaW5hY3RpdmUnOlxuXHRcdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydHAgPSBbXTtcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydGNwRmIgPSBbXTtcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5mbXRwID0gW107XG5cblx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuXHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcblx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjMgPSBjb2RlY3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGNvZGVjID0gX3N0ZXAzLnZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBydHAgPSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0Y29kZWM6IGNvZGVjLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0cmF0ZTogY29kZWMuY2xvY2tSYXRlXG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0aWYgKGNvZGVjLmNoYW5uZWxzID4gMSkgcnRwLmVuY29kaW5nID0gY29kZWMuY2hhbm5lbHM7XG5cblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRwLnB1c2gocnRwKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoY29kZWMucGFyYW1ldGVycykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBwYXJhbUZtdHAgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbmZpZzogJydcblx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3I2ID0gT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGtleSA9IF9zdGVwNi52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAocGFyYW1GbXRwLmNvbmZpZykgcGFyYW1GbXRwLmNvbmZpZyArPSAnOyc7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyYW1GbXRwLmNvbmZpZyArPSBrZXkgKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW2tleV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3I2ID0gZXJyO1xuXHRcdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yNi5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yNjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlmIChwYXJhbUZtdHAuY29uZmlnKSByZW1vdGVNZWRpYU9iai5mbXRwLnB1c2gocGFyYW1GbXRwKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChjb2RlYy5ydGNwRmVlZGJhY2spIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I3ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjcgPSBjb2RlYy5ydGNwRmVlZGJhY2tbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDc7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSAoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGZiID0gX3N0ZXA3LnZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BGYi5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBmYi50eXBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN1YnR5cGU6IGZiLnBhcmFtZXRlciB8fCAnJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yNyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjcgPSBlcnI7XG5cdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3I3LnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I3O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnBheWxvYWRzID0gY29kZWNzLm1hcChmdW5jdGlvbiAoY29kZWMpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjb2RlYy5wYXlsb2FkVHlwZTtcblx0XHRcdFx0XHR9KS5qb2luKCcgJyk7XG5cblx0XHRcdFx0XHQvLyBOT1RFOiBGaXJlZm94IGRvZXMgbm90IGxpa2UgYT1leHRtYXAgbGluZXMgaWYgYT1pbmFjdGl2ZS5cblx0XHRcdFx0XHRpZiAoIWNsb3NlZCkge1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZXh0ID0gW107XG5cblx0XHRcdFx0XHRcdHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGV4dCkge1xuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCBhZGQgYSBoZWFkZXIgZXh0ZW5zaW9uIGlmIG5vdCBwcmVzZW50IGluIHRoZSBvZmZlci5cblx0XHRcdFx0XHRcdFx0dmFyIG1hdGNoZWRMb2NhbEV4dCA9IChsb2NhbE1lZGlhT2JqLmV4dCB8fCBbXSkuZmluZChmdW5jdGlvbiAobG9jYWxFeHQpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbG9jYWxFeHQudXJpID09PSBleHQudXJpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIW1hdGNoZWRMb2NhbEV4dCkgcmV0dXJuICdjb250aW51ZSc7XG5cblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZXh0LnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdHVyaTogZXh0LnVyaSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogZXh0LmlkXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjQgPSBoZWFkZXJFeHRlbnNpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGV4dCA9IF9zdGVwNC52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBfcmV0ID0gX2xvb3AoZXh0KTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdF9pdGVyYXRvckVycm9yNCA9IGVycjtcblx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuXHRcdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yNC5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFNpbXVsY2FzdC5cblx0XHRcdFx0XHRpZiAobG9jYWxNZWRpYU9iai5zaW11bGNhc3RfMDMpIHtcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2Vcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNpbXVsY2FzdF8wMyA9IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGxvY2FsTWVkaWFPYmouc2ltdWxjYXN0XzAzLnZhbHVlLnJlcGxhY2UoL3NlbmQvZywgJ3JlY3YnKVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucmlkcyA9IFtdO1xuXG5cdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yNSA9IChsb2NhbE1lZGlhT2JqLnJpZHMgfHwgW10pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJpZCA9IF9zdGVwNS52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChyaWQuZGlyZWN0aW9uICE9PSAnc2VuZCcpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucmlkcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdGlkOiByaWQuaWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246ICdyZWN2J1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3I1ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuXHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3I1LnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcE11eCA9ICdydGNwLW11eCc7XG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcFJzaXplID0gJ3J0Y3AtcnNpemUnO1xuXG5cdFx0XHRcdFx0Ly8gUHVzaCBpdC5cblx0XHRcdFx0XHRzZHBPYmoubWVkaWEucHVzaChyZW1vdGVNZWRpYU9iaik7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2RwID0gX3NkcFRyYW5zZm9ybTIuZGVmYXVsdC53cml0ZShzZHBPYmopO1xuXG5cdFx0XHRyZXR1cm4gc2RwO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBTZW5kUmVtb3RlU2RwO1xufShSZW1vdGVTZHApO1xuXG52YXIgUmVjdlJlbW90ZVNkcCA9IGZ1bmN0aW9uIChfUmVtb3RlU2RwMikge1xuXHRfaW5oZXJpdHMoUmVjdlJlbW90ZVNkcCwgX1JlbW90ZVNkcDIpO1xuXG5cdGZ1bmN0aW9uIFJlY3ZSZW1vdGVTZHAocnRwUGFyYW1ldGVyc0J5S2luZCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWN2UmVtb3RlU2RwKTtcblxuXHRcdC8vIElkIG9mIHRoZSB1bmlxdWUgTWVkaWFTdHJlYW0gZm9yIGFsbCB0aGUgcmVtb3RlIHRyYWNrcy5cblx0XHR2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJlY3ZSZW1vdGVTZHAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSZWN2UmVtb3RlU2RwKSkuY2FsbCh0aGlzLCBydHBQYXJhbWV0ZXJzQnlLaW5kKSk7XG5cblx0XHRfdGhpczIuX3N0cmVhbUlkID0gJ3JlY3Ytc3RyZWFtLScgKyB1dGlscy5yYW5kb21OdW1iZXIoKTtcblx0XHRyZXR1cm4gX3RoaXMyO1xuXHR9XG5cblx0LyoqXG4gICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjb25zdW1lckluZm9zIC0gQ29uc3VtZXIgaW5mb3JtYXRpb25zLlxuICAqIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhSZWN2UmVtb3RlU2RwLCBbe1xuXHRcdGtleTogJ2NyZWF0ZU9mZmVyU2RwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY3JlYXRlT2ZmZXJTZHAoY29uc3VtZXJJbmZvcykge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdjcmVhdGVPZmZlclNkcCgpJyk7XG5cblx0XHRcdGlmICghdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgdGhyb3cgbmV3IEVycm9yKCdubyB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMnKTtcblxuXHRcdFx0dmFyIHJlbW90ZUljZVBhcmFtZXRlcnMgPSB0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZVBhcmFtZXRlcnM7XG5cdFx0XHR2YXIgcmVtb3RlSWNlQ2FuZGlkYXRlcyA9IHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuaWNlQ2FuZGlkYXRlcztcblx0XHRcdHZhciByZW1vdGVEdGxzUGFyYW1ldGVycyA9IHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuZHRsc1BhcmFtZXRlcnM7XG5cdFx0XHR2YXIgc2RwT2JqID0ge307XG5cdFx0XHR2YXIgbWlkcyA9IGNvbnN1bWVySW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChpbmZvKSB7XG5cdFx0XHRcdHJldHVybiAhaW5mby5jbG9zZWQ7XG5cdFx0XHR9KS5tYXAoZnVuY3Rpb24gKGluZm8pIHtcblx0XHRcdFx0cmV0dXJuIGluZm8ubWlkO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEluY3JlYXNlIG91ciBTRFAgdmVyc2lvbi5cblx0XHRcdHRoaXMuX3NkcEdsb2JhbEZpZWxkcy52ZXJzaW9uKys7XG5cblx0XHRcdHNkcE9iai52ZXJzaW9uID0gMDtcblx0XHRcdHNkcE9iai5vcmlnaW4gPSB7XG5cdFx0XHRcdGFkZHJlc3M6ICcwLjAuMC4wJyxcblx0XHRcdFx0aXBWZXI6IDQsXG5cdFx0XHRcdG5ldFR5cGU6ICdJTicsXG5cdFx0XHRcdHNlc3Npb25JZDogdGhpcy5fc2RwR2xvYmFsRmllbGRzLmlkLFxuXHRcdFx0XHRzZXNzaW9uVmVyc2lvbjogdGhpcy5fc2RwR2xvYmFsRmllbGRzLnZlcnNpb24sXG5cdFx0XHRcdHVzZXJuYW1lOiAnbWVkaWFzb3VwLWNsaWVudCdcblx0XHRcdH07XG5cdFx0XHRzZHBPYmoubmFtZSA9ICctJztcblx0XHRcdHNkcE9iai50aW1pbmcgPSB7IHN0YXJ0OiAwLCBzdG9wOiAwIH07XG5cdFx0XHRzZHBPYmouaWNlbGl0ZSA9IHJlbW90ZUljZVBhcmFtZXRlcnMuaWNlTGl0ZSA/ICdpY2UtbGl0ZScgOiBudWxsO1xuXHRcdFx0c2RwT2JqLm1zaWRTZW1hbnRpYyA9IHtcblx0XHRcdFx0c2VtYW50aWM6ICdXTVMnLFxuXHRcdFx0XHR0b2tlbjogJyonXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAobWlkcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHNkcE9iai5ncm91cHMgPSBbe1xuXHRcdFx0XHRcdHR5cGU6ICdCVU5ETEUnLFxuXHRcdFx0XHRcdG1pZHM6IG1pZHMuam9pbignICcpXG5cdFx0XHRcdH1dO1xuXHRcdFx0fVxuXG5cdFx0XHRzZHBPYmoubWVkaWEgPSBbXTtcblxuXHRcdFx0Ly8gTk9URTogV2UgdGFrZSB0aGUgbGF0ZXN0IGZpbmdlcnByaW50LlxuXHRcdFx0dmFyIG51bUZpbmdlcnByaW50cyA9IHJlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50cy5sZW5ndGg7XG5cblx0XHRcdHNkcE9iai5maW5nZXJwcmludCA9IHtcblx0XHRcdFx0dHlwZTogcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzW251bUZpbmdlcnByaW50cyAtIDFdLmFsZ29yaXRobSxcblx0XHRcdFx0aGFzaDogcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzW251bUZpbmdlcnByaW50cyAtIDFdLnZhbHVlXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yOCA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yOCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yOCA9IGNvbnN1bWVySW5mb3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDg7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSAoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWUpIHtcblx0XHRcdFx0XHR2YXIgaW5mbyA9IF9zdGVwOC52YWx1ZTtcblxuXHRcdFx0XHRcdHZhciBjbG9zZWQgPSBpbmZvLmNsb3NlZDtcblx0XHRcdFx0XHR2YXIga2luZCA9IGluZm8ua2luZDtcblx0XHRcdFx0XHR2YXIgY29kZWNzID0gdm9pZCAwO1xuXHRcdFx0XHRcdHZhciBoZWFkZXJFeHRlbnNpb25zID0gdm9pZCAwO1xuXG5cdFx0XHRcdFx0aWYgKGluZm8ua2luZCAhPT0gJ2FwcGxpY2F0aW9uJykge1xuXHRcdFx0XHRcdFx0Y29kZWNzID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5jb2RlY3M7XG5cdFx0XHRcdFx0XHRoZWFkZXJFeHRlbnNpb25zID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5oZWFkZXJFeHRlbnNpb25zO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdGVNZWRpYU9iaiA9IHt9O1xuXG5cdFx0XHRcdFx0aWYgKGluZm8ua2luZCAhPT0gJ2FwcGxpY2F0aW9uJykge1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoudHlwZSA9IGtpbmQ7XG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5wb3J0ID0gNztcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnByb3RvY29sID0gJ1JUUC9TQVZQRic7XG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5jb25uZWN0aW9uID0geyBpcDogJzEyNy4wLjAuMScsIHZlcnNpb246IDQgfTtcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLm1pZCA9IGluZm8ubWlkO1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoubXNpZCA9IHRoaXMuX3N0cmVhbUlkICsgJyAnICsgaW5mby50cmFja0lkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai50eXBlID0ga2luZDtcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnBvcnQgPSA5O1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucHJvdG9jb2wgPSAnRFRMUy9TQ1RQJztcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmNvbm5lY3Rpb24gPSB7IGlwOiAnMTI3LjAuMC4xJywgdmVyc2lvbjogNCB9O1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoubWlkID0gaW5mby5taWQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlVWZyYWcgPSByZW1vdGVJY2VQYXJhbWV0ZXJzLnVzZXJuYW1lRnJhZ21lbnQ7XG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlUHdkID0gcmVtb3RlSWNlUGFyYW1ldGVycy5wYXNzd29yZDtcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5jYW5kaWRhdGVzID0gW107XG5cblx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSB0cnVlO1xuXHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjkgPSBmYWxzZTtcblx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I5ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjkgPSByZW1vdGVJY2VDYW5kaWRhdGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA5OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gKF9zdGVwOSA9IF9pdGVyYXRvcjkubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjYW5kaWRhdGUgPSBfc3RlcDkudmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGNhbmRpZGF0ZU9iaiA9IHt9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIG1lZGlhc291cCBkb2VzIG5vdCBzdXBwb3J0IG5vbiBydGNwLW11eCBzbyBjYW5kaWRhdGVzIGNvbXBvbmVudCBpc1xuXHRcdFx0XHRcdFx0XHQvLyBhbHdheXMgUlRQICgxKS5cblx0XHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLmNvbXBvbmVudCA9IDE7XG5cdFx0XHRcdFx0XHRcdGNhbmRpZGF0ZU9iai5mb3VuZGF0aW9uID0gY2FuZGlkYXRlLmZvdW5kYXRpb247XG5cdFx0XHRcdFx0XHRcdGNhbmRpZGF0ZU9iai5pcCA9IGNhbmRpZGF0ZS5pcDtcblx0XHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLnBvcnQgPSBjYW5kaWRhdGUucG9ydDtcblx0XHRcdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLnByaW9yaXR5ID0gY2FuZGlkYXRlLnByaW9yaXR5O1xuXHRcdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmoudHJhbnNwb3J0ID0gY2FuZGlkYXRlLnByb3RvY29sO1xuXHRcdFx0XHRcdFx0XHRjYW5kaWRhdGVPYmoudHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuXHRcdFx0XHRcdFx0XHRpZiAoY2FuZGlkYXRlLnRjcFR5cGUpIGNhbmRpZGF0ZU9iai50Y3B0eXBlID0gY2FuZGlkYXRlLnRjcFR5cGU7XG5cblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouY2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZU9iaik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3I5ID0gZXJyO1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ICYmIF9pdGVyYXRvcjkucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yOS5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yOSkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yOTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmVuZE9mQ2FuZGlkYXRlcyA9ICdlbmQtb2YtY2FuZGlkYXRlcyc7XG5cblx0XHRcdFx0XHQvLyBBbm5vdW5jZSBzdXBwb3J0IGZvciBJQ0UgcmVub21pbmF0aW9uLlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC10aGF0Y2hlci1pY2UtcmVub21pbmF0aW9uXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlT3B0aW9ucyA9ICdyZW5vbWluYXRpb24nO1xuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc2V0dXAgPSAnYWN0cGFzcyc7XG5cblx0XHRcdFx0XHRpZiAoaW5mby5raW5kICE9PSAnYXBwbGljYXRpb24nKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWNsb3NlZCkgcmVtb3RlTWVkaWFPYmouZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztlbHNlIHJlbW90ZU1lZGlhT2JqLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG5cblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0cCA9IFtdO1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcEZiID0gW107XG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5mbXRwID0gW107XG5cblx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMTAgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JFcnJvcjEwID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IxMCA9IGNvZGVjc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNvZGVjID0gX3N0ZXAxMC52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBydHAgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvZGVjOiBjb2RlYy5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmF0ZTogY29kZWMuY2xvY2tSYXRlXG5cdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChjb2RlYy5jaGFubmVscyA+IDEpIHJ0cC5lbmNvZGluZyA9IGNvZGVjLmNoYW5uZWxzO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRwLnB1c2gocnRwKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChjb2RlYy5wYXJhbWV0ZXJzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcGFyYW1GbXRwID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uZmlnOiAnJ1xuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIF9pdGVyYXRvckVycm9yMTIgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjEyID0gT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDEyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiA9IChfc3RlcDEyID0gX2l0ZXJhdG9yMTIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEyID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBrZXkgPSBfc3RlcDEyLnZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBhcmFtRm10cC5jb25maWcpIHBhcmFtRm10cC5jb25maWcgKz0gJzsnO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyYW1GbXRwLmNvbmZpZyArPSBrZXkgKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW2tleV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjEyID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IxMiA9IGVycjtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgJiYgX2l0ZXJhdG9yMTIucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3IxMi5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMTIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMTI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChwYXJhbUZtdHAuY29uZmlnKSByZW1vdGVNZWRpYU9iai5mbXRwLnB1c2gocGFyYW1GbXRwKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoY29kZWMucnRjcEZlZWRiYWNrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjEzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IxMyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMTMgPSBjb2RlYy5ydGNwRmVlZGJhY2tbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDEzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IChfc3RlcDEzID0gX2l0ZXJhdG9yMTMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEzID0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBmYiA9IF9zdGVwMTMudmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydGNwRmIucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IGZiLnR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdWJ0eXBlOiBmYi5wYXJhbWV0ZXIgfHwgJydcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMTMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3JFcnJvcjEzID0gZXJyO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyAmJiBfaXRlcmF0b3IxMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9pdGVyYXRvcjEzLnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IxMztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjEwID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IxMCA9IGVycjtcblx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgJiYgX2l0ZXJhdG9yMTAucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfaXRlcmF0b3IxMC5yZXR1cm4oKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMTApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMTA7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnBheWxvYWRzID0gY29kZWNzLm1hcChmdW5jdGlvbiAoY29kZWMpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuXHRcdFx0XHRcdFx0fSkuam9pbignICcpO1xuXG5cdFx0XHRcdFx0XHQvLyBOT1RFOiBGaXJlZm94IGRvZXMgbm90IGxpa2UgYT1leHRtYXAgbGluZXMgaWYgYT1pbmFjdGl2ZS5cblx0XHRcdFx0XHRcdGlmICghY2xvc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmV4dCA9IFtdO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IxMSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjExID0gaGVhZGVyRXh0ZW5zaW9uc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTE7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZXh0ID0gX3N0ZXAxMS52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZXh0LnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR1cmk6IGV4dC51cmksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBleHQuaWRcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IxMSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IxMSA9IGVycjtcblx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgJiYgX2l0ZXJhdG9yMTEucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9pdGVyYXRvcjExLnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjExO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydGNwTXV4ID0gJ3J0Y3AtbXV4Jztcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BSc2l6ZSA9ICdydGNwLXJzaXplJztcblxuXHRcdFx0XHRcdFx0aWYgKCFjbG9zZWQpIHtcblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MgPSBbXTtcblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY0dyb3VwcyA9IFtdO1xuXG5cdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdGlkOiBpbmZvLnNzcmMsXG5cdFx0XHRcdFx0XHRcdFx0YXR0cmlidXRlOiAnY25hbWUnLFxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBpbmZvLmNuYW1lXG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbmZvLnJ0eFNzcmMpIHtcblx0XHRcdFx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zc3Jjcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdGlkOiBpbmZvLnJ0eFNzcmMsXG5cdFx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGU6ICdjbmFtZScsXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogaW5mby5jbmFtZVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQXNzb2NpYXRlIG9yaWdpbmFsIGFuZCByZXRyYW5zbWlzc2lvbiBTU1JDLlxuXHRcdFx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNHcm91cHMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZW1hbnRpY3M6ICdGSUQnLFxuXHRcdFx0XHRcdFx0XHRcdFx0c3NyY3M6IGluZm8uc3NyYyArICcgJyArIGluZm8ucnR4U3NyY1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnBheWxvYWRzID0gNTAwMDtcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNjdHBtYXAgPSB7XG5cdFx0XHRcdFx0XHRcdGFwcDogJ3dlYnJ0Yy1kYXRhY2hhbm5lbCcsXG5cdFx0XHRcdFx0XHRcdG1heE1lc3NhZ2VTaXplOiAyNTYsXG5cdFx0XHRcdFx0XHRcdHNjdHBtYXBOdW1iZXI6IDUwMDBcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHVzaCBpdC5cblx0XHRcdFx0XHRzZHBPYmoubWVkaWEucHVzaChyZW1vdGVNZWRpYU9iaik7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjggPSB0cnVlO1xuXHRcdFx0XHRfaXRlcmF0b3JFcnJvcjggPSBlcnI7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggJiYgX2l0ZXJhdG9yOC5yZXR1cm4pIHtcblx0XHRcdFx0XHRcdF9pdGVyYXRvcjgucmV0dXJuKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjgpIHtcblx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yODtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNkcCA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQud3JpdGUoc2RwT2JqKTtcblxuXHRcdFx0cmV0dXJuIHNkcDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gUmVjdlJlbW90ZVNkcDtcbn0oUmVtb3RlU2RwKTtcblxudmFyIFJlbW90ZVVuaWZpZWRQbGFuU2RwID0gZnVuY3Rpb24gUmVtb3RlVW5pZmllZFBsYW5TZHAoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kKSB7XG5cdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1vdGVVbmlmaWVkUGxhblNkcCk7XG5cblx0bG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIHJ0cFBhcmFtZXRlcnNCeUtpbmQ6JW9dJywgZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kKTtcblxuXHRzd2l0Y2ggKGRpcmVjdGlvbikge1xuXHRcdGNhc2UgJ3NlbmQnOlxuXHRcdFx0cmV0dXJuIG5ldyBTZW5kUmVtb3RlU2RwKHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXHRcdGNhc2UgJ3JlY3YnOlxuXHRcdFx0cmV0dXJuIG5ldyBSZWN2UmVtb3RlU2RwKHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZW1vdGVVbmlmaWVkUGxhblNkcDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMgPSBleHRyYWN0UnRwQ2FwYWJpbGl0aWVzO1xuZXhwb3J0cy5leHRyYWN0RHRsc1BhcmFtZXRlcnMgPSBleHRyYWN0RHRsc1BhcmFtZXRlcnM7XG5cbnZhciBfc2RwVHJhbnNmb3JtID0gcmVxdWlyZSgnc2RwLXRyYW5zZm9ybScpO1xuXG52YXIgX3NkcFRyYW5zZm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZHBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEV4dHJhY3QgUlRQIGNhcGFiaWxpdGllcyBmcm9tIGEgU0RQLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZHBPYmogLSBTRFAgT2JqZWN0IGdlbmVyYXRlZCBieSBzZHAtdHJhbnNmb3JtLlxuICogQHJldHVybiB7UlRDUnRwQ2FwYWJpbGl0aWVzfVxuICovXG5mdW5jdGlvbiBleHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHNkcE9iaikge1xuXHQvLyBNYXAgb2YgUnRwQ29kZWNQYXJhbWV0ZXJzIGluZGV4ZWQgYnkgcGF5bG9hZCB0eXBlLlxuXHR2YXIgY29kZWNzTWFwID0gbmV3IE1hcCgpO1xuXG5cdC8vIEFycmF5IG9mIFJ0cEhlYWRlckV4dGVuc2lvbnMuXG5cdHZhciBoZWFkZXJFeHRlbnNpb25zID0gW107XG5cblx0Ly8gV2hldGhlciBhIG09YXVkaW8vdmlkZW8gc2VjdGlvbiBoYXMgYmVlbiBhbHJlYWR5IGZvdW5kLlxuXHR2YXIgZ290QXVkaW8gPSBmYWxzZTtcblx0dmFyIGdvdFZpZGVvID0gZmFsc2U7XG5cblx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gc2RwT2JqLm1lZGlhW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0dmFyIG0gPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0dmFyIGtpbmQgPSBtLnR5cGU7XG5cblx0XHRcdHN3aXRjaCAoa2luZCkge1xuXHRcdFx0XHRjYXNlICdhdWRpbyc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKGdvdEF1ZGlvKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0Z290QXVkaW8gPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICd2aWRlbyc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKGdvdFZpZGVvKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0Z290VmlkZW8gPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IGNvZGVjcy5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gbS5ydHBbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0XHR2YXIgcnRwID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdFx0dmFyIGNvZGVjID0ge1xuXHRcdFx0XHRcdFx0bmFtZTogcnRwLmNvZGVjLFxuXHRcdFx0XHRcdFx0bWltZVR5cGU6IGtpbmQgKyAnLycgKyBydHAuY29kZWMsXG5cdFx0XHRcdFx0XHRraW5kOiBraW5kLFxuXHRcdFx0XHRcdFx0Y2xvY2tSYXRlOiBydHAucmF0ZSxcblx0XHRcdFx0XHRcdHByZWZlcnJlZFBheWxvYWRUeXBlOiBydHAucGF5bG9hZCxcblx0XHRcdFx0XHRcdGNoYW5uZWxzOiBydHAuZW5jb2RpbmcsXG5cdFx0XHRcdFx0XHRydGNwRmVlZGJhY2s6IFtdLFxuXHRcdFx0XHRcdFx0cGFyYW1ldGVyczoge31cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKGNvZGVjLmtpbmQgIT09ICdhdWRpbycpIGRlbGV0ZSBjb2RlYy5jaGFubmVscztlbHNlIGlmICghY29kZWMuY2hhbm5lbHMpIGNvZGVjLmNoYW5uZWxzID0gMTtcblxuXHRcdFx0XHRcdGNvZGVjc01hcC5zZXQoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUsIGNvZGVjKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBjb2RlYyBwYXJhbWV0ZXJzLlxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yMiA9IGVycjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IChtLmZtdHAgfHwgW10pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG5cdFx0XHRcdFx0dmFyIGZtdHAgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0XHR2YXIgcGFyYW1ldGVycyA9IF9zZHBUcmFuc2Zvcm0yLmRlZmF1bHQucGFyc2VGbXRwQ29uZmlnKGZtdHAuY29uZmlnKTtcblx0XHRcdFx0XHR2YXIgY29kZWMgPSBjb2RlY3NNYXAuZ2V0KGZtdHAucGF5bG9hZCk7XG5cblx0XHRcdFx0XHRpZiAoIWNvZGVjKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGNvZGVjLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IFJUQ1AgZmVlZGJhY2sgZm9yIGVhY2ggY29kZWMuXG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcblx0XHRcdFx0X2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG5cdFx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3I0ID0gKG0ucnRjcEZiIHx8IFtdKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuXHRcdFx0XHRcdHZhciBmYiA9IF9zdGVwNC52YWx1ZTtcblxuXHRcdFx0XHRcdHZhciBjb2RlYyA9IGNvZGVjc01hcC5nZXQoZmIucGF5bG9hZCk7XG5cblx0XHRcdFx0XHRpZiAoIWNvZGVjKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdHZhciBmZWVkYmFjayA9IHtcblx0XHRcdFx0XHRcdHR5cGU6IGZiLnR5cGUsXG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXI6IGZiLnN1YnR5cGVcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKCFmZWVkYmFjay5wYXJhbWV0ZXIpIGRlbGV0ZSBmZWVkYmFjay5wYXJhbWV0ZXI7XG5cblx0XHRcdFx0XHRjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmZWVkYmFjayk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgUlRQIGhlYWRlciBleHRlbnNpb25zLlxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yNCA9IGVycjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuXHRcdFx0XHRcdFx0X2l0ZXJhdG9yNC5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuXHRcdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yNSA9IChtLmV4dCB8fCBbXSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcblx0XHRcdFx0XHR2YXIgZXh0ID0gX3N0ZXA1LnZhbHVlO1xuXG5cdFx0XHRcdFx0dmFyIGhlYWRlckV4dGVuc2lvbiA9IHtcblx0XHRcdFx0XHRcdGtpbmQ6IGtpbmQsXG5cdFx0XHRcdFx0XHR1cmk6IGV4dC51cmksXG5cdFx0XHRcdFx0XHRwcmVmZXJyZWRJZDogZXh0LnZhbHVlXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGhlYWRlckV4dGVuc2lvbnMucHVzaChoZWFkZXJFeHRlbnNpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0X2RpZEl0ZXJhdG9yRXJyb3I1ID0gdHJ1ZTtcblx0XHRcdFx0X2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRfaXRlcmF0b3I1LnJldHVybigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvci5yZXR1cm4oKTtcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBydHBDYXBhYmlsaXRpZXMgPSB7XG5cdFx0Y29kZWNzOiBBcnJheS5mcm9tKGNvZGVjc01hcC52YWx1ZXMoKSksXG5cdFx0aGVhZGVyRXh0ZW5zaW9uczogaGVhZGVyRXh0ZW5zaW9ucyxcblx0XHRmZWNNZWNoYW5pc21zOiBbXSAvLyBUT0RPXG5cdH07XG5cblx0cmV0dXJuIHJ0cENhcGFiaWxpdGllcztcbn1cblxuLyoqXG4gKiBFeHRyYWN0IERUTFMgcGFyYW1ldGVycyBmcm9tIGEgU0RQLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZHBPYmogLSBTRFAgT2JqZWN0IGdlbmVyYXRlZCBieSBzZHAtdHJhbnNmb3JtLlxuICogQHJldHVybiB7UlRDRHRsc1BhcmFtZXRlcnN9XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3REdGxzUGFyYW1ldGVycyhzZHBPYmopIHtcblx0dmFyIG1lZGlhID0gZ2V0Rmlyc3RBY3RpdmVNZWRpYVNlY3Rpb24oc2RwT2JqKTtcblx0dmFyIGZpbmdlcnByaW50ID0gbWVkaWEuZmluZ2VycHJpbnQgfHwgc2RwT2JqLmZpbmdlcnByaW50O1xuXHR2YXIgcm9sZSA9IHZvaWQgMDtcblxuXHRzd2l0Y2ggKG1lZGlhLnNldHVwKSB7XG5cdFx0Y2FzZSAnYWN0aXZlJzpcblx0XHRcdHJvbGUgPSAnY2xpZW50Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3Bhc3NpdmUnOlxuXHRcdFx0cm9sZSA9ICdzZXJ2ZXInO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnYWN0cGFzcyc6XG5cdFx0XHRyb2xlID0gJ2F1dG8nO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHR2YXIgZHRsc1BhcmFtZXRlcnMgPSB7XG5cdFx0cm9sZTogcm9sZSxcblx0XHRmaW5nZXJwcmludHM6IFt7XG5cdFx0XHRhbGdvcml0aG06IGZpbmdlcnByaW50LnR5cGUsXG5cdFx0XHR2YWx1ZTogZmluZ2VycHJpbnQuaGFzaFxuXHRcdH1dXG5cdH07XG5cblx0cmV0dXJuIGR0bHNQYXJhbWV0ZXJzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgYWNpdmUgbWVkaWEgc2VjdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNkcE9iaiAtIFNEUCBPYmplY3QgZ2VuZXJhdGVkIGJ5IHNkcC10cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFNEUCBtZWRpYSBzZWN0aW9uIGFzIHBhcnNlZCBieSBzZHAtdHJhbnNmb3JtLlxuICovXG5mdW5jdGlvbiBnZXRGaXJzdEFjdGl2ZU1lZGlhU2VjdGlvbihzZHBPYmopIHtcblx0cmV0dXJuIChzZHBPYmoubWVkaWEgfHwgW10pLmZpbmQoZnVuY3Rpb24gKG0pIHtcblx0XHRyZXR1cm4gbS5pY2VVZnJhZyAmJiBtLnBvcnQgIT09IDA7XG5cdH0pO1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG5leHBvcnRzLmZpbGxSdHBQYXJhbWV0ZXJzRm9yVHJhY2sgPSBmaWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrO1xuZXhwb3J0cy5hZGRTaW11bGNhc3RGb3JUcmFjayA9IGFkZFNpbXVsY2FzdEZvclRyYWNrO1xuLyoqXG4gKiBGaWxsIHRoZSBnaXZlbiBSVFAgcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIHRyYWNrLlxuICpcbiAqIEBwYXJhbSB7UlRDUnRwUGFyYW1ldGVyc30gcnRwUGFyYW1ldGVycyAtICBSVFAgcGFyYW1ldGVycyB0byBiZSBmaWxsZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gc2RwT2JqIC0gTG9jYWwgU0RQIE9iamVjdCBnZW5lcmF0ZWQgYnkgc2RwLXRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqL1xuZnVuY3Rpb24gZmlsbFJ0cFBhcmFtZXRlcnNGb3JUcmFjayhydHBQYXJhbWV0ZXJzLCBzZHBPYmosIHRyYWNrKSB7XG5cdHZhciBraW5kID0gdHJhY2sua2luZDtcblx0dmFyIHJ0Y3AgPSB7XG5cdFx0Y25hbWU6IG51bGwsXG5cdFx0cmVkdWNlZFNpemU6IHRydWUsXG5cdFx0bXV4OiB0cnVlXG5cdH07XG5cblx0dmFyIG1TZWN0aW9uID0gKHNkcE9iai5tZWRpYSB8fCBbXSkuZmluZChmdW5jdGlvbiAobSkge1xuXHRcdHJldHVybiBtLnR5cGUgPT09IGtpbmQ7XG5cdH0pO1xuXG5cdGlmICghbVNlY3Rpb24pIHRocm93IG5ldyBFcnJvcignbT0nICsga2luZCArICcgc2VjdGlvbiBub3QgZm91bmQnKTtcblxuXHQvLyBGaXJzdCBtZWRpYSBTU1JDIChvciB0aGUgb25seSBvbmUpLlxuXHR2YXIgZmlyc3RTc3JjID0gdm9pZCAwO1xuXG5cdC8vIEdldCBhbGwgdGhlIFNTUkNzLlxuXG5cdHZhciBzc3JjcyA9IG5ldyBTZXQoKTtcblxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSAobVNlY3Rpb24uc3NyY3MgfHwgW10pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuXHRcdFx0dmFyIGxpbmUgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0aWYgKGxpbmUuYXR0cmlidXRlICE9PSAnbXNpZCcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgdHJhY2tJZCA9IGxpbmUudmFsdWUuc3BsaXQoJyAnKVsxXTtcblxuXHRcdFx0aWYgKHRyYWNrSWQgPT09IHRyYWNrLmlkKSB7XG5cdFx0XHRcdHZhciBfc3NyYzIgPSBsaW5lLmlkO1xuXG5cdFx0XHRcdHNzcmNzLmFkZChfc3NyYzIpO1xuXG5cdFx0XHRcdGlmICghZmlyc3RTc3JjKSBmaXJzdFNzcmMgPSBfc3NyYzI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvci5yZXR1cm4oKTtcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChzc3Jjcy5zaXplID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2E9c3NyYyBsaW5lIG5vdCBmb3VuZCBmb3IgbG9jYWwgdHJhY2sgW3RyYWNrLmlkOicgKyB0cmFjay5pZCArICddJyk7XG5cblx0Ly8gR2V0IG1lZGlhIGFuZCBSVFggU1NSQ3MuXG5cblx0dmFyIHNzcmNUb1J0eFNzcmMgPSBuZXcgTWFwKCk7XG5cblx0Ly8gRmlyc3QgYXNzdW1lIFJUWCBpcyB1c2VkLlxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gKG1TZWN0aW9uLnNzcmNHcm91cHMgfHwgW10pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG5cdFx0XHR2YXIgX2xpbmUgPSBfc3RlcDIudmFsdWU7XG5cblx0XHRcdGlmIChfbGluZS5zZW1hbnRpY3MgIT09ICdGSUQnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIF9saW5lJHNzcmNzJHNwbGl0ID0gX2xpbmUuc3NyY3Muc3BsaXQoL1xccysvKSxcblx0XHRcdCAgICBfbGluZSRzc3JjcyRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfbGluZSRzc3JjcyRzcGxpdCwgMiksXG5cdFx0XHQgICAgc3NyYyA9IF9saW5lJHNzcmNzJHNwbGl0MlswXSxcblx0XHRcdCAgICBydHhTc3JjID0gX2xpbmUkc3NyY3Mkc3BsaXQyWzFdO1xuXG5cdFx0XHRzc3JjID0gTnVtYmVyKHNzcmMpO1xuXHRcdFx0cnR4U3NyYyA9IE51bWJlcihydHhTc3JjKTtcblxuXHRcdFx0aWYgKHNzcmNzLmhhcyhzc3JjKSkge1xuXHRcdFx0XHQvLyBSZW1vdmUgYm90aCB0aGUgU1NSQyBhbmQgUlRYIFNTUkMgZnJvbSB0aGUgU2V0IHNvIGxhdGVyIHdlIGtub3cgdGhhdCB0aGV5XG5cdFx0XHRcdC8vIGFyZSBhbHJlYWR5IGhhbmRsZWQuXG5cdFx0XHRcdHNzcmNzLmRlbGV0ZShzc3JjKTtcblx0XHRcdFx0c3NyY3MuZGVsZXRlKHJ0eFNzcmMpO1xuXG5cdFx0XHRcdC8vIEFkZCB0byB0aGUgbWFwLlxuXHRcdFx0XHRzc3JjVG9SdHhTc3JjLnNldChzc3JjLCBydHhTc3JjKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgU2V0IG9mIFNTUkNzIGlzIG5vdCBlbXB0eSBpdCBtZWFucyB0aGF0IFJUWCBpcyBub3QgYmVpbmcgdXNlZCwgc28gdGFrZVxuXHRcdC8vIG1lZGlhIFNTUkNzIGZyb20gdGhlcmUuXG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvcjIucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvcjMgPSBzc3Jjc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuXHRcdFx0dmFyIHNzcmMgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgbWFwLlxuXHRcdFx0c3NyY1RvUnR4U3NyYy5zZXQoc3NyYywgbnVsbCk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IFJUQ1AgaW5mby5cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIHNzcmNDbmFtZUxpbmUgPSBtU2VjdGlvbi5zc3Jjcy5maW5kKGZ1bmN0aW9uIChsaW5lKSB7XG5cdFx0cmV0dXJuIGxpbmUuYXR0cmlidXRlID09PSAnY25hbWUnICYmIGxpbmUuaWQgPT09IGZpcnN0U3NyYztcblx0fSk7XG5cblx0aWYgKHNzcmNDbmFtZUxpbmUpIHJ0Y3AuY25hbWUgPSBzc3JjQ25hbWVMaW5lLnZhbHVlO1xuXG5cdC8vIEZpbGwgUlRQIHBhcmFtZXRlcnMuXG5cblx0cnRwUGFyYW1ldGVycy5ydGNwID0gcnRjcDtcblx0cnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBbXTtcblxuXHR2YXIgc2ltdWxjYXN0ID0gc3NyY1RvUnR4U3NyYy5zaXplID4gMTtcblx0dmFyIHNpbXVsY2FzdFByb2ZpbGVzID0gWydsb3cnLCAnbWVkaXVtJywgJ2hpZ2gnXTtcblxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3I0ID0gc3NyY1RvUnR4U3NyY1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuXHRcdFx0dmFyIF9yZWYgPSBfc3RlcDQudmFsdWU7XG5cblx0XHRcdHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG5cdFx0XHR2YXIgX3NzcmMgPSBfcmVmMlswXTtcblx0XHRcdHZhciBydHhTc3JjID0gX3JlZjJbMV07XG5cblx0XHRcdHZhciBlbmNvZGluZyA9IHsgc3NyYzogX3NzcmMgfTtcblxuXHRcdFx0aWYgKHJ0eFNzcmMpIGVuY29kaW5nLnJ0eCA9IHsgc3NyYzogcnR4U3NyYyB9O1xuXG5cdFx0XHRpZiAoc2ltdWxjYXN0KSBlbmNvZGluZy5wcm9maWxlID0gc2ltdWxjYXN0UHJvZmlsZXMuc2hpZnQoKTtcblxuXHRcdFx0cnRwUGFyYW1ldGVycy5lbmNvZGluZ3MucHVzaChlbmNvZGluZyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yNCA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3I0LnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yNDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHNpbXVsY2FzdCBpbnRvIHRoZSBnaXZlbiBTRFAgZm9yIHRoZSBnaXZlbiB0cmFjay5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2RwT2JqIC0gTG9jYWwgU0RQIE9iamVjdCBnZW5lcmF0ZWQgYnkgc2RwLXRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqL1xuZnVuY3Rpb24gYWRkU2ltdWxjYXN0Rm9yVHJhY2soc2RwT2JqLCB0cmFjaykge1xuXHR2YXIga2luZCA9IHRyYWNrLmtpbmQ7XG5cblx0dmFyIG1TZWN0aW9uID0gKHNkcE9iai5tZWRpYSB8fCBbXSkuZmluZChmdW5jdGlvbiAobSkge1xuXHRcdHJldHVybiBtLnR5cGUgPT09IGtpbmQ7XG5cdH0pO1xuXG5cdGlmICghbVNlY3Rpb24pIHRocm93IG5ldyBFcnJvcignbT0nICsga2luZCArICcgc2VjdGlvbiBub3QgZm91bmQnKTtcblxuXHR2YXIgc3NyYyA9IHZvaWQgMDtcblx0dmFyIHJ0eFNzcmMgPSB2b2lkIDA7XG5cdHZhciBtc2lkID0gdm9pZCAwO1xuXG5cdC8vIEdldCB0aGUgU1NSQy5cblxuXHR2YXIgc3NyY01zaWRMaW5lID0gKG1TZWN0aW9uLnNzcmNzIHx8IFtdKS5maW5kKGZ1bmN0aW9uIChsaW5lKSB7XG5cdFx0aWYgKGxpbmUuYXR0cmlidXRlICE9PSAnbXNpZCcpIHJldHVybiBmYWxzZTtcblxuXHRcdHZhciB0cmFja0lkID0gbGluZS52YWx1ZS5zcGxpdCgnICcpWzFdO1xuXG5cdFx0aWYgKHRyYWNrSWQgPT09IHRyYWNrLmlkKSB7XG5cdFx0XHRzc3JjID0gbGluZS5pZDtcblx0XHRcdG1zaWQgPSBsaW5lLnZhbHVlLnNwbGl0KCcgJylbMF07XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKCFzc3JjTXNpZExpbmUpIHRocm93IG5ldyBFcnJvcignYT1zc3JjIGxpbmUgbm90IGZvdW5kIGZvciBsb2NhbCB0cmFjayBbdHJhY2suaWQ6JyArIHRyYWNrLmlkICsgJ10nKTtcblxuXHQvLyBHZXQgdGhlIFNTUkMgZm9yIFJUWC5cblxuXHQobVNlY3Rpb24uc3NyY0dyb3VwcyB8fCBbXSkuc29tZShmdW5jdGlvbiAobGluZSkge1xuXHRcdGlmIChsaW5lLnNlbWFudGljcyAhPT0gJ0ZJRCcpIHJldHVybjtcblxuXHRcdHZhciBzc3JjcyA9IGxpbmUuc3NyY3Muc3BsaXQoL1xccysvKTtcblxuXHRcdGlmIChOdW1iZXIoc3NyY3NbMF0pID09PSBzc3JjKSB7XG5cdFx0XHRydHhTc3JjID0gTnVtYmVyKHNzcmNzWzFdKTtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9KTtcblxuXHR2YXIgc3NyY0NuYW1lTGluZSA9IG1TZWN0aW9uLnNzcmNzLmZpbmQoZnVuY3Rpb24gKGxpbmUpIHtcblx0XHRyZXR1cm4gbGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScgJiYgbGluZS5pZCA9PT0gc3NyYztcblx0fSk7XG5cblx0aWYgKCFzc3JjQ25hbWVMaW5lKSB0aHJvdyBuZXcgRXJyb3IoJ0NOQU1FIGxpbmUgbm90IGZvdW5kIGZvciBsb2NhbCB0cmFjayBbdHJhY2suaWQ6JyArIHRyYWNrLmlkICsgJ10nKTtcblxuXHR2YXIgY25hbWUgPSBzc3JjQ25hbWVMaW5lLnZhbHVlO1xuXHR2YXIgc3NyYzIgPSBzc3JjICsgMTtcblx0dmFyIHNzcmMzID0gc3NyYyArIDI7XG5cblx0bVNlY3Rpb24uc3NyY0dyb3VwcyA9IG1TZWN0aW9uLnNzcmNHcm91cHMgfHwgW107XG5cblx0bVNlY3Rpb24uc3NyY0dyb3Vwcy5wdXNoKHtcblx0XHRzZW1hbnRpY3M6ICdTSU0nLFxuXHRcdHNzcmNzOiBzc3JjICsgJyAnICsgc3NyYzIgKyAnICcgKyBzc3JjM1xuXHR9KTtcblxuXHRtU2VjdGlvbi5zc3Jjcy5wdXNoKHtcblx0XHRpZDogc3NyYzIsXG5cdFx0YXR0cmlidXRlOiAnY25hbWUnLFxuXHRcdHZhbHVlOiBjbmFtZVxuXHR9KTtcblxuXHRtU2VjdGlvbi5zc3Jjcy5wdXNoKHtcblx0XHRpZDogc3NyYzIsXG5cdFx0YXR0cmlidXRlOiAnbXNpZCcsXG5cdFx0dmFsdWU6IG1zaWQgKyAnICcgKyB0cmFjay5pZFxuXHR9KTtcblxuXHRtU2VjdGlvbi5zc3Jjcy5wdXNoKHtcblx0XHRpZDogc3NyYzMsXG5cdFx0YXR0cmlidXRlOiAnY25hbWUnLFxuXHRcdHZhbHVlOiBjbmFtZVxuXHR9KTtcblxuXHRtU2VjdGlvbi5zc3Jjcy5wdXNoKHtcblx0XHRpZDogc3NyYzMsXG5cdFx0YXR0cmlidXRlOiAnbXNpZCcsXG5cdFx0dmFsdWU6IG1zaWQgKyAnICcgKyB0cmFjay5pZFxuXHR9KTtcblxuXHRpZiAocnR4U3NyYykge1xuXHRcdHZhciBydHhTc3JjMiA9IHJ0eFNzcmMgKyAxO1xuXHRcdHZhciBydHhTc3JjMyA9IHJ0eFNzcmMgKyAyO1xuXG5cdFx0bVNlY3Rpb24uc3NyY0dyb3Vwcy5wdXNoKHtcblx0XHRcdHNlbWFudGljczogJ0ZJRCcsXG5cdFx0XHRzc3Jjczogc3NyYzIgKyAnICcgKyBydHhTc3JjMlxuXHRcdH0pO1xuXG5cdFx0bVNlY3Rpb24uc3NyY3MucHVzaCh7XG5cdFx0XHRpZDogcnR4U3NyYzIsXG5cdFx0XHRhdHRyaWJ1dGU6ICdjbmFtZScsXG5cdFx0XHR2YWx1ZTogY25hbWVcblx0XHR9KTtcblxuXHRcdG1TZWN0aW9uLnNzcmNzLnB1c2goe1xuXHRcdFx0aWQ6IHJ0eFNzcmMyLFxuXHRcdFx0YXR0cmlidXRlOiAnbXNpZCcsXG5cdFx0XHR2YWx1ZTogbXNpZCArICcgJyArIHRyYWNrLmlkXG5cdFx0fSk7XG5cblx0XHRtU2VjdGlvbi5zc3JjR3JvdXBzLnB1c2goe1xuXHRcdFx0c2VtYW50aWNzOiAnRklEJyxcblx0XHRcdHNzcmNzOiBzc3JjMyArICcgJyArIHJ0eFNzcmMzXG5cdFx0fSk7XG5cblx0XHRtU2VjdGlvbi5zc3Jjcy5wdXNoKHtcblx0XHRcdGlkOiBydHhTc3JjMyxcblx0XHRcdGF0dHJpYnV0ZTogJ2NuYW1lJyxcblx0XHRcdHZhbHVlOiBjbmFtZVxuXHRcdH0pO1xuXG5cdFx0bVNlY3Rpb24uc3NyY3MucHVzaCh7XG5cdFx0XHRpZDogcnR4U3NyYzMsXG5cdFx0XHRhdHRyaWJ1dGU6ICdtc2lkJyxcblx0XHRcdHZhbHVlOiBtc2lkICsgJyAnICsgdHJhY2suaWRcblx0XHR9KTtcblx0fVxufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmlsbFJ0cFBhcmFtZXRlcnNGb3JUcmFjayA9IGZpbGxSdHBQYXJhbWV0ZXJzRm9yVHJhY2s7XG4vKipcbiAqIEZpbGwgdGhlIGdpdmVuIFJUUCBwYXJhbWV0ZXJzIGZvciB0aGUgZ2l2ZW4gdHJhY2suXG4gKlxuICogQHBhcmFtIHtSVENSdHBQYXJhbWV0ZXJzfSBydHBQYXJhbWV0ZXJzIC0gIFJUUCBwYXJhbWV0ZXJzIHRvIGJlIGZpbGxlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZHBPYmogLSBMb2NhbCBTRFAgT2JqZWN0IGdlbmVyYXRlZCBieSBzZHAtdHJhbnNmb3JtLlxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICovXG5mdW5jdGlvbiBmaWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKHJ0cFBhcmFtZXRlcnMsIHNkcE9iaiwgdHJhY2spIHtcblx0dmFyIGtpbmQgPSB0cmFjay5raW5kO1xuXHR2YXIgcnRjcCA9IHtcblx0XHRjbmFtZTogbnVsbCxcblx0XHRyZWR1Y2VkU2l6ZTogdHJ1ZSxcblx0XHRtdXg6IHRydWVcblx0fTtcblxuXHR2YXIgbVNlY3Rpb24gPSAoc2RwT2JqLm1lZGlhIHx8IFtdKS5maW5kKGZ1bmN0aW9uIChtKSB7XG5cdFx0aWYgKG0udHlwZSAhPT0ga2luZCkgcmV0dXJuO1xuXG5cdFx0dmFyIG1zaWRMaW5lID0gbS5tc2lkO1xuXG5cdFx0aWYgKCFtc2lkTGluZSkgcmV0dXJuO1xuXG5cdFx0dmFyIHRyYWNrSWQgPSBtc2lkTGluZS5zcGxpdCgnICcpWzFdO1xuXG5cdFx0aWYgKHRyYWNrSWQgPT09IHRyYWNrLmlkKSByZXR1cm4gdHJ1ZTtcblx0fSk7XG5cblx0aWYgKCFtU2VjdGlvbikgdGhyb3cgbmV3IEVycm9yKCdtPScgKyBraW5kICsgJyBzZWN0aW9uIG5vdCBmb3VuZCcpO1xuXG5cdC8vIEdldCB0aGUgU1NSQyBhbmQgQ05BTUUuXG5cblx0dmFyIHNzcmNDbmFtZUxpbmUgPSAobVNlY3Rpb24uc3NyY3MgfHwgW10pLmZpbmQoZnVuY3Rpb24gKGxpbmUpIHtcblx0XHRyZXR1cm4gbGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZSc7XG5cdH0pO1xuXG5cdHZhciBzc3JjID0gdm9pZCAwO1xuXG5cdGlmIChzc3JjQ25hbWVMaW5lKSB7XG5cdFx0c3NyYyA9IHNzcmNDbmFtZUxpbmUuaWQ7XG5cdFx0cnRjcC5jbmFtZSA9IHNzcmNDbmFtZUxpbmUudmFsdWU7XG5cdH1cblxuXHQvLyBHZXQgYT1yaWQgbGluZXMuXG5cblx0Ly8gQXJyYXkgb2YgT2JqZWN0cyB3aXRoIHJpZCBhbmQgcHJvZmlsZSBrZXlzLlxuXHR2YXIgc2ltdWxjYXN0U3RyZWFtcyA9IFtdO1xuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0dmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvciA9IChtU2VjdGlvbi5yaWRzIHx8IFtdKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdHZhciByaWQgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0aWYgKHJpZC5kaXJlY3Rpb24gIT09ICdzZW5kJykgY29udGludWU7XG5cblx0XHRcdGlmICgvXmxvdy8udGVzdChyaWQuaWQpKSBzaW11bGNhc3RTdHJlYW1zLnB1c2goeyByaWQ6IHJpZC5pZCwgcHJvZmlsZTogJ2xvdycgfSk7ZWxzZSBpZiAoL15tZWRpdW0vLnRlc3QocmlkLmlkKSkgc2ltdWxjYXN0U3RyZWFtcy5wdXNoKHsgcmlkOiByaWQuaWQsIHByb2ZpbGU6ICdtZWRpdW0nIH0pO1xuXHRcdFx0aWYgKC9eaGlnaC8udGVzdChyaWQuaWQpKSBzaW11bGNhc3RTdHJlYW1zLnB1c2goeyByaWQ6IHJpZC5pZCwgcHJvZmlsZTogJ2hpZ2gnIH0pO1xuXHRcdH1cblxuXHRcdC8vIEZpbGwgUlRQIHBhcmFtZXRlcnMuXG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvciA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cnRwUGFyYW1ldGVycy5ydGNwID0gcnRjcDtcblx0cnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBbXTtcblxuXHRpZiAoc2ltdWxjYXN0U3RyZWFtcy5sZW5ndGggPT09IDApIHtcblx0XHR2YXIgZW5jb2RpbmcgPSB7IHNzcmM6IHNzcmMgfTtcblxuXHRcdHJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMiA9IHNpbXVsY2FzdFN0cmVhbXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0dmFyIHNpbXVsY2FzdFN0cmVhbSA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0XHR2YXIgX2VuY29kaW5nID0ge1xuXHRcdFx0XHRcdGVuY29kaW5nSWQ6IHNpbXVsY2FzdFN0cmVhbS5yaWQsXG5cdFx0XHRcdFx0cHJvZmlsZTogc2ltdWxjYXN0U3RyZWFtLnByb2ZpbGVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRydHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5wdXNoKF9lbmNvZGluZyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUm9vbSA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuaXNEZXZpY2VTdXBwb3J0ZWQgPSBpc0RldmljZVN1cHBvcnRlZDtcbmV4cG9ydHMuZ2V0RGV2aWNlSW5mbyA9IGdldERldmljZUluZm87XG5leHBvcnRzLmNoZWNrQ2FwYWJpbGl0aWVzRm9yUm9vbSA9IGNoZWNrQ2FwYWJpbGl0aWVzRm9yUm9vbTtcblxudmFyIF9vcnRjID0gcmVxdWlyZSgnLi9vcnRjJyk7XG5cbnZhciBvcnRjID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX29ydGMpO1xuXG52YXIgX0RldmljZSA9IHJlcXVpcmUoJy4vRGV2aWNlJyk7XG5cbnZhciBfRGV2aWNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RldmljZSk7XG5cbnZhciBfUm9vbSA9IHJlcXVpcmUoJy4vUm9vbScpO1xuXG52YXIgX1Jvb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm9vbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxuICogV2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIG9yIGRldmljZSBpcyBzdXBwb3J0ZWQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAZXhhbXBsZVxuICogaXNEZXZpY2VTdXBwb3J0ZWQoKVxuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc0RldmljZVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIF9EZXZpY2UyLmRlZmF1bHQuaXNTdXBwb3J0ZWQoKTtcbn1cblxuLyoqXG4gKiBHZXQgaW5mb3JtYXRpb24gcmVnYXJkaW5nIHRoZSBjdXJyZW50IGJyb3dzZXIgb3IgZGV2aWNlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gLSBPYmplY3Qgd2l0aCBgbmFtZWAgKFN0cmluZykgYW5kIHZlcnNpb24ge1N0cmluZ30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGdldERldmljZUluZm8oKVxuICogLy8gPT4geyBmbGFnOiAnY2hyb21lJywgbmFtZTogJ0Nocm9tZScsIHZlcnNpb246ICc1OS4wJywgYm93c2VyOiB7fSB9XG4gKi9cbmZ1bmN0aW9uIGdldERldmljZUluZm8oKSB7XG4gIHJldHVybiB7XG4gICAgZmxhZzogX0RldmljZTIuZGVmYXVsdC5mbGFnLFxuICAgIG5hbWU6IF9EZXZpY2UyLmRlZmF1bHQubmFtZSxcbiAgICB2ZXJzaW9uOiBfRGV2aWNlMi5kZWZhdWx0LnZlcnNpb24sXG4gICAgYm93c2VyOiBfRGV2aWNlMi5kZWZhdWx0LmJvd3NlclxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyBkZXZpY2UvYnJvd3NlciBjYW4gc2VuZC9yZWNlaXZlIGF1ZGlvL3ZpZGVvIGluIGEgcm9vbVxuICogd2hvc2UgUlRQIGNhcGFiaWxpdGllcyBhcmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFJvb20gUlRQIGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byBhbiBPYmplY3Qgd2l0aCAnYXVkaW8nIGFuZCAndmlkZW8nIEJvb2xlYW5zLlxuICovXG5mdW5jdGlvbiBjaGVja0NhcGFiaWxpdGllc0ZvclJvb20ocm9vbVJ0cENhcGFiaWxpdGllcykge1xuICBpZiAoIV9EZXZpY2UyLmRlZmF1bHQuaXNTdXBwb3J0ZWQoKSkgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY3VycmVudCBicm93c2VyL2RldmljZSBub3Qgc3VwcG9ydGVkJykpO1xuXG4gIHJldHVybiBfRGV2aWNlMi5kZWZhdWx0LkhhbmRsZXIuZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkudGhlbihmdW5jdGlvbiAobmF0aXZlUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgdmFyIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gb3J0Yy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyhuYXRpdmVSdHBDYXBhYmlsaXRpZXMsIHJvb21SdHBDYXBhYmlsaXRpZXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvOiBvcnRjLmNhblNlbmQoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgdmlkZW86IG9ydGMuY2FuU2VuZCgndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGhlIFJvb20gY2xhc3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJvb20gPSBuZXcgUm9vbSgpO2BcbiAqL1xuZXhwb3J0cy5Sb29tID0gX1Jvb20yLmRlZmF1bHQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IGdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzO1xuZXhwb3J0cy5nZXRSdHBDYXBhYmlsaXRpZXMgPSBnZXRSdHBDYXBhYmlsaXRpZXM7XG5leHBvcnRzLmdldFVuc3VwcG9ydGVkQ29kZWNzID0gZ2V0VW5zdXBwb3J0ZWRDb2RlY3M7XG5leHBvcnRzLmNhblNlbmQgPSBjYW5TZW5kO1xuZXhwb3J0cy5jYW5SZWNlaXZlID0gY2FuUmVjZWl2ZTtcbmV4cG9ydHMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMgPSBnZXRTZW5kaW5nUnRwUGFyYW1ldGVycztcbmV4cG9ydHMuZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMgPSBnZXRSZWNlaXZpbmdGdWxsUnRwUGFyYW1ldGVycztcbi8qKlxuICogR2VuZXJhdGUgZXh0ZW5kZWQgUlRQIGNhcGFiaWxpdGllcyBmb3Igc2VuZGluZyBhbmQgcmVjZWl2aW5nLlxuICpcbiAqIEBwYXJhbSB7UlRDUnRwQ2FwYWJpbGl0aWVzfSBsb2NhbENhcHMgLSBMb2NhbCBjYXBhYmlsaXRpZXMuXG4gKiBAcGFyYW0ge1JUQ1J0cENhcGFiaWxpdGllc30gcmVtb3RlQ2FwcyAtIFJlbW90ZSBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHJldHVybiB7UlRDRXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXN9XG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKGxvY2FsQ2FwcywgcmVtb3RlQ2Fwcykge1xuXHR2YXIgZXh0ZW5kZWRDYXBzID0ge1xuXHRcdGNvZGVjczogW10sXG5cdFx0aGVhZGVyRXh0ZW5zaW9uczogW10sXG5cdFx0ZmVjTWVjaGFuaXNtczogW11cblx0fTtcblxuXHQvLyBNYXRjaCBtZWRpYSBjb2RlY3MgYW5kIGtlZXAgdGhlIG9yZGVyIHByZWZlcnJlZCBieSByZW1vdGVDYXBzLlxuXG5cdHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHJlbW90ZUNvZGVjKSB7XG5cdFx0Ly8gVE9ETzogSWdub3JlIHBzZXVkby1jb2RlY3MgYW5kIGZlYXR1cmUgY29kZWNzLlxuXHRcdGlmIChyZW1vdGVDb2RlYy5uYW1lID09PSAncnR4JykgcmV0dXJuICdjb250aW51ZSc7XG5cblx0XHR2YXIgbWF0Y2hpbmdMb2NhbENvZGVjID0gKGxvY2FsQ2Fwcy5jb2RlY3MgfHwgW10pLmZpbmQoZnVuY3Rpb24gKGxvY2FsQ29kZWMpIHtcblx0XHRcdHJldHVybiBtYXRjaENhcENvZGVjcyhsb2NhbENvZGVjLCByZW1vdGVDb2RlYyk7XG5cdFx0fSk7XG5cblx0XHRpZiAobWF0Y2hpbmdMb2NhbENvZGVjKSB7XG5cdFx0XHR2YXIgZXh0ZW5kZWRDb2RlYyA9IHtcblx0XHRcdFx0bmFtZTogcmVtb3RlQ29kZWMubmFtZSxcblx0XHRcdFx0bWltZVR5cGU6IHJlbW90ZUNvZGVjLm1pbWVUeXBlLFxuXHRcdFx0XHRraW5kOiByZW1vdGVDb2RlYy5raW5kLFxuXHRcdFx0XHRjbG9ja1JhdGU6IHJlbW90ZUNvZGVjLmNsb2NrUmF0ZSxcblx0XHRcdFx0c2VuZFBheWxvYWRUeXBlOiBtYXRjaGluZ0xvY2FsQ29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUsXG5cdFx0XHRcdHNlbmRSdHhQYXlsb2FkVHlwZTogbnVsbCxcblx0XHRcdFx0cmVjdlBheWxvYWRUeXBlOiByZW1vdGVDb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSxcblx0XHRcdFx0cmVjdlJ0eFBheWxvYWRUeXBlOiBudWxsLFxuXHRcdFx0XHRjaGFubmVsczogcmVtb3RlQ29kZWMuY2hhbm5lbHMsXG5cdFx0XHRcdHJ0Y3BGZWVkYmFjazogcmVkdWNlUnRjcEZlZWRiYWNrKG1hdGNoaW5nTG9jYWxDb2RlYywgcmVtb3RlQ29kZWMpLFxuXHRcdFx0XHRwYXJhbWV0ZXJzOiByZW1vdGVDb2RlYy5wYXJhbWV0ZXJzXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIWV4dGVuZGVkQ29kZWMuY2hhbm5lbHMpIGRlbGV0ZSBleHRlbmRlZENvZGVjLmNoYW5uZWxzO1xuXG5cdFx0XHRleHRlbmRlZENhcHMuY29kZWNzLnB1c2goZXh0ZW5kZWRDb2RlYyk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0dmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvciA9IChyZW1vdGVDYXBzLmNvZGVjcyB8fCBbXSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHR2YXIgcmVtb3RlQ29kZWMgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0dmFyIF9yZXQgPSBfbG9vcChyZW1vdGVDb2RlYyk7XG5cblx0XHRcdGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBNYXRjaCBSVFggY29kZWNzLlxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvci5yZXR1cm4oKTtcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoZXh0ZW5kZWRDb2RlYykge1xuXHRcdHZhciBtYXRjaGluZ0xvY2FsUnR4Q29kZWMgPSAobG9jYWxDYXBzLmNvZGVjcyB8fCBbXSkuZmluZChmdW5jdGlvbiAobG9jYWxDb2RlYykge1xuXHRcdFx0cmV0dXJuIGxvY2FsQ29kZWMubmFtZSA9PT0gJ3J0eCcgJiYgbG9jYWxDb2RlYy5wYXJhbWV0ZXJzLmFwdCA9PT0gZXh0ZW5kZWRDb2RlYy5zZW5kUGF5bG9hZFR5cGU7XG5cdFx0fSk7XG5cblx0XHR2YXIgbWF0Y2hpbmdSZW1vdGVSdHhDb2RlYyA9IChyZW1vdGVDYXBzLmNvZGVjcyB8fCBbXSkuZmluZChmdW5jdGlvbiAocmVtb3RlQ29kZWMpIHtcblx0XHRcdHJldHVybiByZW1vdGVDb2RlYy5uYW1lID09PSAncnR4JyAmJiByZW1vdGVDb2RlYy5wYXJhbWV0ZXJzLmFwdCA9PT0gZXh0ZW5kZWRDb2RlYy5yZWN2UGF5bG9hZFR5cGU7XG5cdFx0fSk7XG5cblx0XHRpZiAobWF0Y2hpbmdMb2NhbFJ0eENvZGVjICYmIG1hdGNoaW5nUmVtb3RlUnR4Q29kZWMpIHtcblx0XHRcdGV4dGVuZGVkQ29kZWMuc2VuZFJ0eFBheWxvYWRUeXBlID0gbWF0Y2hpbmdMb2NhbFJ0eENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuXHRcdFx0ZXh0ZW5kZWRDb2RlYy5yZWN2UnR4UGF5bG9hZFR5cGUgPSBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gKGV4dGVuZGVkQ2Fwcy5jb2RlY3MgfHwgW10pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG5cdFx0XHR2YXIgZXh0ZW5kZWRDb2RlYyA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0X2xvb3AyKGV4dGVuZGVkQ29kZWMpO1xuXHRcdH1cblxuXHRcdC8vIE1hdGNoIGhlYWRlciBleHRlbnNpb25zLlxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yMiA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKHJlbW90ZUV4dCkge1xuXHRcdHZhciBtYXRjaGluZ0xvY2FsRXh0ID0gKGxvY2FsQ2Fwcy5oZWFkZXJFeHRlbnNpb25zIHx8IFtdKS5maW5kKGZ1bmN0aW9uIChsb2NhbEV4dCkge1xuXHRcdFx0cmV0dXJuIG1hdGNoQ2FwSGVhZGVyRXh0ZW5zaW9ucyhsb2NhbEV4dCwgcmVtb3RlRXh0KTtcblx0XHR9KTtcblxuXHRcdGlmIChtYXRjaGluZ0xvY2FsRXh0KSB7XG5cdFx0XHR2YXIgZXh0ZW5kZWRFeHQgPSB7XG5cdFx0XHRcdGtpbmQ6IHJlbW90ZUV4dC5raW5kLFxuXHRcdFx0XHR1cmk6IHJlbW90ZUV4dC51cmksXG5cdFx0XHRcdHNlbmRJZDogbWF0Y2hpbmdMb2NhbEV4dC5wcmVmZXJyZWRJZCxcblx0XHRcdFx0cmVjdklkOiByZW1vdGVFeHQucHJlZmVycmVkSWRcblx0XHRcdH07XG5cblx0XHRcdGV4dGVuZGVkQ2Fwcy5oZWFkZXJFeHRlbnNpb25zLnB1c2goZXh0ZW5kZWRFeHQpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IzID0gKHJlbW90ZUNhcHMuaGVhZGVyRXh0ZW5zaW9ucyB8fCBbXSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdHZhciByZW1vdGVFeHQgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdF9sb29wMyhyZW1vdGVFeHQpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdH1cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGV4dGVuZGVkQ2Fwcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgY2FwYWJpbGl0aWVzIGZvciByZWNlaXZpbmcgbWVkaWEgYmFzZWQgb24gdGhlIGdpdmVuIGV4dGVuZGVkXG4gKiBSVFAgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBwYXJhbSB7UlRDRXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXN9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzXG4gKlxuICogQHJldHVybiB7UlRDUnRwQ2FwYWJpbGl0aWVzfVxuICovXG5mdW5jdGlvbiBnZXRSdHBDYXBhYmlsaXRpZXMoZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcblx0dmFyIGNhcHMgPSB7XG5cdFx0Y29kZWNzOiBbXSxcblx0XHRoZWFkZXJFeHRlbnNpb25zOiBbXSxcblx0XHRmZWNNZWNoYW5pc21zOiBbXVxuXHR9O1xuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvcjQgPSBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5jb2RlY3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcblx0XHRcdHZhciBjYXBDb2RlYyA9IF9zdGVwNC52YWx1ZTtcblxuXHRcdFx0dmFyIGNvZGVjID0ge1xuXHRcdFx0XHRuYW1lOiBjYXBDb2RlYy5uYW1lLFxuXHRcdFx0XHRtaW1lVHlwZTogY2FwQ29kZWMubWltZVR5cGUsXG5cdFx0XHRcdGtpbmQ6IGNhcENvZGVjLmtpbmQsXG5cdFx0XHRcdGNsb2NrUmF0ZTogY2FwQ29kZWMuY2xvY2tSYXRlLFxuXHRcdFx0XHRwcmVmZXJyZWRQYXlsb2FkVHlwZTogY2FwQ29kZWMucmVjdlBheWxvYWRUeXBlLFxuXHRcdFx0XHRjaGFubmVsczogY2FwQ29kZWMuY2hhbm5lbHMsXG5cdFx0XHRcdHJ0Y3BGZWVkYmFjazogY2FwQ29kZWMucnRjcEZlZWRiYWNrLFxuXHRcdFx0XHRwYXJhbWV0ZXJzOiBjYXBDb2RlYy5wYXJhbWV0ZXJzXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIWNvZGVjLmNoYW5uZWxzKSBkZWxldGUgY29kZWMuY2hhbm5lbHM7XG5cblx0XHRcdGNhcHMuY29kZWNzLnB1c2goY29kZWMpO1xuXG5cdFx0XHQvLyBBZGQgUlRYIGNvZGVjLlxuXHRcdFx0aWYgKGNhcENvZGVjLnJlY3ZSdHhQYXlsb2FkVHlwZSkge1xuXHRcdFx0XHR2YXIgcnR4Q2FwQ29kZWMgPSB7XG5cdFx0XHRcdFx0bmFtZTogJ3J0eCcsXG5cdFx0XHRcdFx0bWltZVR5cGU6IGNhcENvZGVjLmtpbmQgKyAnL3J0eCcsXG5cdFx0XHRcdFx0a2luZDogY2FwQ29kZWMua2luZCxcblx0XHRcdFx0XHRjbG9ja1JhdGU6IGNhcENvZGVjLmNsb2NrUmF0ZSxcblx0XHRcdFx0XHRwcmVmZXJyZWRQYXlsb2FkVHlwZTogY2FwQ29kZWMucmVjdlJ0eFBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnM6IHtcblx0XHRcdFx0XHRcdGFwdDogY2FwQ29kZWMucmVjdlBheWxvYWRUeXBlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNhcHMuY29kZWNzLnB1c2gocnR4Q2FwQ29kZWMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUT0RPOiBJbiB0aGUgZnV0dXJlLCB3ZSBuZWVkIHRvIGFkZCBGRUMsIENOLCBldGMsIGNvZGVjcy5cblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvcjQucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvcjUgPSBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG5cdFx0XHR2YXIgY2FwRXh0ID0gX3N0ZXA1LnZhbHVlO1xuXG5cdFx0XHR2YXIgZXh0ID0ge1xuXHRcdFx0XHRraW5kOiBjYXBFeHQua2luZCxcblx0XHRcdFx0dXJpOiBjYXBFeHQudXJpLFxuXHRcdFx0XHRwcmVmZXJyZWRJZDogY2FwRXh0LnJlY3ZJZFxuXHRcdFx0fTtcblxuXHRcdFx0Y2Fwcy5oZWFkZXJFeHRlbnNpb25zLnB1c2goZXh0KTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvcjUucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGNhcHMuZmVjTWVjaGFuaXNtcyA9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmZlY01lY2hhbmlzbXM7XG5cblx0cmV0dXJuIGNhcHM7XG59XG5cbi8qKlxuICogR2V0IHVuc3VwcG9ydGVkIHJlbW90ZSBjb2RlY3MuXG4gKlxuICogQHBhcmFtIHtSVENSdHBDYXBhYmlsaXRpZXN9IHJlbW90ZUNhcHMgLSBSZW1vdGUgY2FwYWJpbGl0aWVzLlxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBtYW5kYXRvcnlDb2RlY1BheWxvYWRUeXBlcyAtIExpc3Qgb2YgY29kZWMgUFQgdmFsdWVzLlxuICogQHBhcmFtIHtSVENFeHRlbmRlZFJ0cENhcGFiaWxpdGllc30gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXNcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBnZXRVbnN1cHBvcnRlZENvZGVjcyhyZW1vdGVDYXBzLCBtYW5kYXRvcnlDb2RlY1BheWxvYWRUeXBlcywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcblx0Ly8gSWYgbm90IGdpdmVuIGp1c3QgaWdub3JlLlxuXHRpZiAoIUFycmF5LmlzQXJyYXkobWFuZGF0b3J5Q29kZWNQYXlsb2FkVHlwZXMpKSByZXR1cm4gW107XG5cblx0dmFyIHVuc3VwcG9ydGVkQ29kZWNzID0gW107XG5cdHZhciByZW1vdGVDb2RlY3MgPSByZW1vdGVDYXBzLmNvZGVjcztcblx0dmFyIHN1cHBvcnRlZENvZGVjcyA9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcztcblxuXHR2YXIgX2xvb3A0ID0gZnVuY3Rpb24gX2xvb3A0KHB0KSB7XG5cdFx0aWYgKCFzdXBwb3J0ZWRDb2RlY3Muc29tZShmdW5jdGlvbiAoY29kZWMpIHtcblx0XHRcdHJldHVybiBjb2RlYy5yZWN2UGF5bG9hZFR5cGUgPT09IHB0O1xuXHRcdH0pKSB7XG5cdFx0XHR2YXIgdW5zdXBwb3J0ZWRDb2RlYyA9IHJlbW90ZUNvZGVjcy5maW5kKGZ1bmN0aW9uIChjb2RlYykge1xuXHRcdFx0XHRyZXR1cm4gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgPT09IHB0O1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghdW5zdXBwb3J0ZWRDb2RlYykgdGhyb3cgbmV3IEVycm9yKCdtYW5kYXRvcnkgY29kZWMgUFQgJyArIHB0ICsgJyBub3QgZm91bmQgaW4gcmVtb3RlIGNvZGVjcycpO1xuXG5cdFx0XHR1bnN1cHBvcnRlZENvZGVjcy5wdXNoKHVuc3VwcG9ydGVkQ29kZWMpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3I2ID0gbWFuZGF0b3J5Q29kZWNQYXlsb2FkVHlwZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHtcblx0XHRcdHZhciBwdCA9IF9zdGVwNi52YWx1ZTtcblxuXHRcdFx0X2xvb3A0KHB0KTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3I2ID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvcjYucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB1bnN1cHBvcnRlZENvZGVjcztcbn1cblxuLyoqXG4gKiBXaGV0aGVyIG1lZGlhIGNhbiBiZSBzZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBSVFAgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBraW5kXG4gKiBAcGFyYW0ge1JUQ0V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzfSBleHRlbmRlZFJ0cENhcGFiaWxpdGllc1xuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNhblNlbmQoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcblx0cmV0dXJuIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcy5zb21lKGZ1bmN0aW9uIChjb2RlYykge1xuXHRcdHJldHVybiBjb2RlYy5raW5kID09PSBraW5kO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiBSVFAgcGFyYW1ldGVycyBjYW4gYmUgcmVjZWl2ZWQgd2l0aCB0aGUgZ2l2ZW4gUlRQXG4gKiBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHBhcmFtIHtSVENSdHBQYXJhbWV0ZXJzfSBydHBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1JUQ0V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzfSBleHRlbmRlZFJ0cENhcGFiaWxpdGllc1xuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNhblJlY2VpdmUocnRwUGFyYW1ldGVycywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcblx0aWYgKHJ0cFBhcmFtZXRlcnMuY29kZWNzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG5cdHZhciBmaXJzdE1lZGlhQ29kZWMgPSBydHBQYXJhbWV0ZXJzLmNvZGVjc1swXTtcblxuXHRyZXR1cm4gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzLnNvbWUoZnVuY3Rpb24gKGNvZGVjKSB7XG5cdFx0cmV0dXJuIGNvZGVjLnJlY3ZQYXlsb2FkVHlwZSA9PT0gZmlyc3RNZWRpYUNvZGVjLnBheWxvYWRUeXBlO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgcGFyYW1ldGVycyBvZiB0aGUgZ2l2ZW4ga2luZCBmb3Igc2VuZGluZyBtZWRpYS5cbiAqIEp1c3QgdGhlIGZpcnN0IG1lZGlhIGNvZGVjIHBlciBraW5kIGlzIGNvbnNpZGVyZWQuXG4gKiBOT1RFOiBtdXhJZCwgZW5jb2RpbmdzIGFuZCBydGNwIGZpZWxkcyBhcmUgbGVmdCBlbXB0eS5cbiAqXG4gKiBAcGFyYW0ge2tpbmR9IGtpbmRcbiAqIEBwYXJhbSB7UlRDRXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXN9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzXG4gKlxuICogQHJldHVybiB7UlRDUnRwUGFyYW1ldGVyc31cbiAqL1xuZnVuY3Rpb24gZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRtdXhJZDogbnVsbCxcblx0XHRjb2RlY3M6IFtdLFxuXHRcdGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuXHRcdGVuY29kaW5nczogW10sXG5cdFx0cnRjcDoge31cblx0fTtcblxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gZmFsc2U7XG5cdHZhciBfaXRlcmF0b3JFcnJvcjcgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3I3ID0gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7XG5cdFx0XHR2YXIgY2FwQ29kZWMgPSBfc3RlcDcudmFsdWU7XG5cblx0XHRcdGlmIChjYXBDb2RlYy5raW5kICE9PSBraW5kKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGNvZGVjID0ge1xuXHRcdFx0XHRuYW1lOiBjYXBDb2RlYy5uYW1lLFxuXHRcdFx0XHRtaW1lVHlwZTogY2FwQ29kZWMubWltZVR5cGUsXG5cdFx0XHRcdGNsb2NrUmF0ZTogY2FwQ29kZWMuY2xvY2tSYXRlLFxuXHRcdFx0XHRwYXlsb2FkVHlwZTogY2FwQ29kZWMuc2VuZFBheWxvYWRUeXBlLFxuXHRcdFx0XHRjaGFubmVsczogY2FwQ29kZWMuY2hhbm5lbHMsXG5cdFx0XHRcdHJ0Y3BGZWVkYmFjazogY2FwQ29kZWMucnRjcEZlZWRiYWNrLFxuXHRcdFx0XHRwYXJhbWV0ZXJzOiBjYXBDb2RlYy5wYXJhbWV0ZXJzXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIWNvZGVjLmNoYW5uZWxzKSBkZWxldGUgY29kZWMuY2hhbm5lbHM7XG5cblx0XHRcdHBhcmFtcy5jb2RlY3MucHVzaChjb2RlYyk7XG5cblx0XHRcdC8vIEFkZCBSVFggY29kZWMuXG5cdFx0XHRpZiAoY2FwQ29kZWMuc2VuZFJ0eFBheWxvYWRUeXBlKSB7XG5cdFx0XHRcdHZhciBydHhDb2RlYyA9IHtcblx0XHRcdFx0XHRuYW1lOiAncnR4Jyxcblx0XHRcdFx0XHRtaW1lVHlwZTogY2FwQ29kZWMua2luZCArICcvcnR4Jyxcblx0XHRcdFx0XHRjbG9ja1JhdGU6IGNhcENvZGVjLmNsb2NrUmF0ZSxcblx0XHRcdFx0XHRwYXlsb2FkVHlwZTogY2FwQ29kZWMuc2VuZFJ0eFBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnM6IHtcblx0XHRcdFx0XHRcdGFwdDogY2FwQ29kZWMuc2VuZFBheWxvYWRUeXBlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHBhcmFtcy5jb2RlY3MucHVzaChydHhDb2RlYyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5PVEU6IFdlIGFzc3VtZSBhIHNpbmdsZSBtZWRpYSBjb2RlYyBwbHVzIGFuIG9wdGlvbmFsIFJUWCBjb2RlYyBmb3Igbm93LlxuXHRcdFx0Ly8gVE9ETzogSW4gdGhlIGZ1dHVyZSwgd2UgbmVlZCB0byBhZGQgRkVDLCBDTiwgZXRjLCBjb2RlY3MuXG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yNyA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3I3ID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ICYmIF9pdGVyYXRvcjcucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvcjcucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjcpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I3O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvcjggPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yOCA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvcjggPSBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA4OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gKF9zdGVwOCA9IF9pdGVyYXRvcjgubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlKSB7XG5cdFx0XHR2YXIgY2FwRXh0ID0gX3N0ZXA4LnZhbHVlO1xuXG5cdFx0XHRpZiAoY2FwRXh0LmtpbmQgJiYgY2FwRXh0LmtpbmQgIT09IGtpbmQpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgZXh0ID0ge1xuXHRcdFx0XHR1cmk6IGNhcEV4dC51cmksXG5cdFx0XHRcdGlkOiBjYXBFeHQuc2VuZElkXG5cdFx0XHR9O1xuXG5cdFx0XHRwYXJhbXMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvcjggPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yOCA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCAmJiBfaXRlcmF0b3I4LnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3I4LnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3I4KSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yODtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGFyYW1zO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIFJUUCBwYXJhbWV0ZXJzIG9mIHRoZSBnaXZlbiBraW5kIGZvciByZWNlaXZpbmcgbWVkaWEuXG4gKiBBbGwgdGhlIG1lZGlhIGNvZGVjcyBwZXIga2luZCBhcmUgY29uc2lkZXJlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGdlbmVyYXRpbmdcbiAqIGEgU0RQIHJlbW90ZSBvZmZlci5cbiAqIE5PVEU6IG11eElkLCBlbmNvZGluZ3MgYW5kIHJ0Y3AgZmllbGRzIGFyZSBsZWZ0IGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBraW5kXG4gKiBAcGFyYW0ge1JUQ0V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzfSBleHRlbmRlZFJ0cENhcGFiaWxpdGllc1xuICpcbiAqIEByZXR1cm4ge1JUQ1J0cFBhcmFtZXRlcnN9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY2VpdmluZ0Z1bGxSdHBQYXJhbWV0ZXJzKGtpbmQsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0bXV4SWQ6IG51bGwsXG5cdFx0Y29kZWNzOiBbXSxcblx0XHRoZWFkZXJFeHRlbnNpb25zOiBbXSxcblx0XHRlbmNvZGluZ3M6IFtdLFxuXHRcdHJ0Y3A6IHt9XG5cdH07XG5cblx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZTtcblx0dmFyIF9kaWRJdGVyYXRvckVycm9yOSA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3I5ID0gdW5kZWZpbmVkO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgX2l0ZXJhdG9yOSA9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IChfc3RlcDkgPSBfaXRlcmF0b3I5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZSkge1xuXHRcdFx0dmFyIGNhcENvZGVjID0gX3N0ZXA5LnZhbHVlO1xuXG5cdFx0XHRpZiAoY2FwQ29kZWMua2luZCAhPT0ga2luZCkgY29udGludWU7XG5cblx0XHRcdHZhciBjb2RlYyA9IHtcblx0XHRcdFx0bmFtZTogY2FwQ29kZWMubmFtZSxcblx0XHRcdFx0bWltZVR5cGU6IGNhcENvZGVjLm1pbWVUeXBlLFxuXHRcdFx0XHRjbG9ja1JhdGU6IGNhcENvZGVjLmNsb2NrUmF0ZSxcblx0XHRcdFx0cGF5bG9hZFR5cGU6IGNhcENvZGVjLnJlY3ZQYXlsb2FkVHlwZSxcblx0XHRcdFx0Y2hhbm5lbHM6IGNhcENvZGVjLmNoYW5uZWxzLFxuXHRcdFx0XHRydGNwRmVlZGJhY2s6IGNhcENvZGVjLnJ0Y3BGZWVkYmFjayxcblx0XHRcdFx0cGFyYW1ldGVyczogY2FwQ29kZWMucGFyYW1ldGVyc1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCFjb2RlYy5jaGFubmVscykgZGVsZXRlIGNvZGVjLmNoYW5uZWxzO1xuXG5cdFx0XHRwYXJhbXMuY29kZWNzLnB1c2goY29kZWMpO1xuXG5cdFx0XHQvLyBBZGQgUlRYIGNvZGVjLlxuXHRcdFx0aWYgKGNhcENvZGVjLnJlY3ZSdHhQYXlsb2FkVHlwZSkge1xuXHRcdFx0XHR2YXIgcnR4Q29kZWMgPSB7XG5cdFx0XHRcdFx0bmFtZTogJ3J0eCcsXG5cdFx0XHRcdFx0bWltZVR5cGU6IGNhcENvZGVjLmtpbmQgKyAnL3J0eCcsXG5cdFx0XHRcdFx0Y2xvY2tSYXRlOiBjYXBDb2RlYy5jbG9ja1JhdGUsXG5cdFx0XHRcdFx0cGF5bG9hZFR5cGU6IGNhcENvZGVjLnJlY3ZSdHhQYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzOiB7XG5cdFx0XHRcdFx0XHRhcHQ6IGNhcENvZGVjLnJlY3ZQYXlsb2FkVHlwZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRwYXJhbXMuY29kZWNzLnB1c2gocnR4Q29kZWMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUT0RPOiBJbiB0aGUgZnV0dXJlLCB3ZSBuZWVkIHRvIGFkZCBGRUMsIENOLCBldGMsIGNvZGVjcy5cblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yOSA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3I5ID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ICYmIF9pdGVyYXRvcjkucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvcjkucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjkpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I5O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMCA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IxMCA9IHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIF9pdGVyYXRvcjEwID0gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9uc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlKSB7XG5cdFx0XHR2YXIgY2FwRXh0ID0gX3N0ZXAxMC52YWx1ZTtcblxuXHRcdFx0aWYgKGNhcEV4dC5raW5kICYmIGNhcEV4dC5raW5kICE9PSBraW5kKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGV4dCA9IHtcblx0XHRcdFx0dXJpOiBjYXBFeHQudXJpLFxuXHRcdFx0XHRpZDogY2FwRXh0LnJlY3ZJZFxuXHRcdFx0fTtcblxuXHRcdFx0cGFyYW1zLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IxMCA9IHRydWU7XG5cdFx0X2l0ZXJhdG9yRXJyb3IxMCA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgJiYgX2l0ZXJhdG9yMTAucmV0dXJuKSB7XG5cdFx0XHRcdF9pdGVyYXRvcjEwLnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMCkge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjEwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQ2FwQ29kZWNzKGFDb2RlYywgYkNvZGVjKSB7XG5cdHZhciBhTWltZVR5cGUgPSBhQ29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcblx0dmFyIGJNaW1lVHlwZSA9IGJDb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuXG5cdGlmIChhTWltZVR5cGUgIT09IGJNaW1lVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG5cdGlmIChhQ29kZWMuY2xvY2tSYXRlICE9PSBiQ29kZWMuY2xvY2tSYXRlKSByZXR1cm4gZmFsc2U7XG5cblx0aWYgKGFDb2RlYy5jaGFubmVscyAhPT0gYkNvZGVjLmNoYW5uZWxzKSByZXR1cm4gZmFsc2U7XG5cblx0Ly8gTWF0Y2ggSDI2NCBwYXJhbWV0ZXJzLlxuXHRpZiAoYU1pbWVUeXBlID09PSAndmlkZW8vaDI2NCcpIHtcblx0XHR2YXIgYVBhY2tldGl6YXRpb25Nb2RlID0gKGFDb2RlYy5wYXJhbWV0ZXJzIHx8IHt9KVsncGFja2V0aXphdGlvbi1tb2RlJ10gfHwgMDtcblx0XHR2YXIgYlBhY2tldGl6YXRpb25Nb2RlID0gKGJDb2RlYy5wYXJhbWV0ZXJzIHx8IHt9KVsncGFja2V0aXphdGlvbi1tb2RlJ10gfHwgMDtcblxuXHRcdGlmIChhUGFja2V0aXphdGlvbk1vZGUgIT09IGJQYWNrZXRpemF0aW9uTW9kZSkgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQ2FwSGVhZGVyRXh0ZW5zaW9ucyhhRXh0LCBiRXh0KSB7XG5cdGlmIChhRXh0LmtpbmQgJiYgYkV4dC5raW5kICYmIGFFeHQua2luZCAhPT0gYkV4dC5raW5kKSByZXR1cm4gZmFsc2U7XG5cblx0aWYgKGFFeHQudXJpICE9PSBiRXh0LnVyaSkgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VSdGNwRmVlZGJhY2soY29kZWNBLCBjb2RlY0IpIHtcblx0dmFyIHJlZHVjZWRSdGNwRmVlZGJhY2sgPSBbXTtcblxuXHR2YXIgX2xvb3A1ID0gZnVuY3Rpb24gX2xvb3A1KGFGYikge1xuXHRcdHZhciBtYXRjaGluZ0JGYiA9IChjb2RlY0IucnRjcEZlZWRiYWNrIHx8IFtdKS5maW5kKGZ1bmN0aW9uIChiRmIpIHtcblx0XHRcdHJldHVybiBiRmIudHlwZSA9PT0gYUZiLnR5cGUgJiYgYkZiLnBhcmFtZXRlciA9PT0gYUZiLnBhcmFtZXRlcjtcblx0XHR9KTtcblxuXHRcdGlmIChtYXRjaGluZ0JGYikgcmVkdWNlZFJ0Y3BGZWVkYmFjay5wdXNoKG1hdGNoaW5nQkZiKTtcblx0fTtcblxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gdHJ1ZTtcblx0dmFyIF9kaWRJdGVyYXRvckVycm9yMTEgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yMTEgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IxMSA9IChjb2RlY0EucnRjcEZlZWRiYWNrIHx8IFtdKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTE7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSB0cnVlKSB7XG5cdFx0XHR2YXIgYUZiID0gX3N0ZXAxMS52YWx1ZTtcblxuXHRcdFx0X2xvb3A1KGFGYik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRfZGlkSXRlcmF0b3JFcnJvcjExID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvcjExID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSAmJiBfaXRlcmF0b3IxMS5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yMTEucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcjExKSB7XG5cdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlZHVjZWRSdGNwRmVlZGJhY2s7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yYW5kb21OdW1iZXIgPSByYW5kb21OdW1iZXI7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5cbnZhciBfcmFuZG9tTnVtYmVyID0gcmVxdWlyZSgncmFuZG9tLW51bWJlcicpO1xuXG52YXIgX3JhbmRvbU51bWJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYW5kb21OdW1iZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcmFuZG9tTnVtYmVyR2VuZXJhdG9yID0gX3JhbmRvbU51bWJlcjIuZGVmYXVsdC5nZW5lcmF0b3Ioe1xuICBtaW46IDEwMDAwMDAwLFxuICBtYXg6IDk5OTk5OTk5LFxuICBpbnRlZ2VyOiB0cnVlXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcG9zaXRpdmUgbnVtYmVyIGJldHdlZW4gMTAwMDAwMDAgYW5kIDk5OTk5OTk5LlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gcmFuZG9tTnVtYmVyKCkge1xuICByZXR1cm4gcmFuZG9tTnVtYmVyR2VuZXJhdG9yKCk7XG59XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBnaXZlbiBPYmplY3QvQXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICpcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheX1cbiAqL1xuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufSIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLFxuICAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsXG4gICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJyxcbiAgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLFxuICAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsXG4gICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJyxcbiAgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLFxuICAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsXG4gICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJyxcbiAgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLFxuICAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIHZhciBwcmV2VGltZTtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG4iLCIvKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG4iLCJ2b2lkIGZ1bmN0aW9uKHJvb3Qpe1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRzKG9wdGlvbnMpe1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBtaW4gPSBvcHRpb25zLm1pblxuICAgIHZhciBtYXggPSBvcHRpb25zLm1heFxuICAgIHZhciBpbnRlZ2VyID0gb3B0aW9ucy5pbnRlZ2VyIHx8IGZhbHNlXG4gICAgaWYgKCBtaW4gPT0gbnVsbCAmJiBtYXggPT0gbnVsbCApIHtcbiAgICAgIG1pbiA9IDBcbiAgICAgIG1heCA9IDFcbiAgICB9IGVsc2UgaWYgKCBtaW4gPT0gbnVsbCApIHtcbiAgICAgIG1pbiA9IG1heCAtIDFcbiAgICB9IGVsc2UgaWYgKCBtYXggPT0gbnVsbCApIHtcbiAgICAgIG1heCA9IG1pbiArIDFcbiAgICB9XG4gICAgaWYgKCBtYXggPCBtaW4gKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3B0aW9ucywgbWF4IG11c3QgYmUgPj0gbWluJylcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiAgICAgbWluXG4gICAgLCBtYXg6ICAgICBtYXhcbiAgICAsIGludGVnZXI6IGludGVnZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYW5kb20ob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMpXG4gICAgaWYgKCBvcHRpb25zLm1heCA9PT0gb3B0aW9ucy5taW4gKSByZXR1cm4gb3B0aW9ucy5taW5cbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAob3B0aW9ucy5tYXggLSBvcHRpb25zLm1pbiArIE51bWJlcighIW9wdGlvbnMuaW50ZWdlcikpICsgb3B0aW9ucy5taW5cbiAgICByZXR1cm4gb3B0aW9ucy5pbnRlZ2VyID8gTWF0aC5mbG9vcihyKSA6IHJcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRvcihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucylcbiAgICByZXR1cm4gZnVuY3Rpb24obWluLCBtYXgsIGludGVnZXIpe1xuICAgICAgb3B0aW9ucy5taW4gICAgID0gbWluICE9IG51bGwgPyBtaW4gOiBvcHRpb25zLm1pblxuICAgICAgb3B0aW9ucy5tYXggICAgID0gbWF4ICE9IG51bGwgPyBtYXggOiBvcHRpb25zLm1heFxuICAgICAgb3B0aW9ucy5pbnRlZ2VyID0gaW50ZWdlciAhPSBudWxsID8gaW50ZWdlciA6IG9wdGlvbnMuaW50ZWdlclxuICAgICAgcmV0dXJuIHJhbmRvbShvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gIHJhbmRvbVxuICBtb2R1bGUuZXhwb3J0cy5nZW5lcmF0b3IgPSBnZW5lcmF0b3JcbiAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0c1xufSh0aGlzKVxuIiwidmFyIGdyYW1tYXIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdjogW3tcbiAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgcmVnOiAvXihcXGQqKSQvXG4gIH1dLFxuICBvOiBbeyAvL289LSAyMDUxOCAwIElOIElQNCAyMDMuMC4xMTMuMVxuICAgIC8vIE5COiBzZXNzaW9uSWQgd2lsbCBiZSBhIFN0cmluZyBpbiBtb3N0IGNhc2VzIGJlY2F1c2UgaXQgaXMgaHVnZVxuICAgIG5hbWU6ICdvcmlnaW4nLFxuICAgIHJlZzogL14oXFxTKikgKFxcZCopIChcXGQqKSAoXFxTKikgSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3VzZXJuYW1lJywgJ3Nlc3Npb25JZCcsICdzZXNzaW9uVmVyc2lvbicsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICBmb3JtYXQ6ICclcyAlcyAlZCAlcyBJUCVkICVzJ1xuICB9XSxcbiAgLy8gZGVmYXVsdCBwYXJzaW5nIG9mIHRoZXNlIG9ubHkgKHRob3VnaCBzb21lIG9mIHRoZXNlIGZlZWwgb3V0ZGF0ZWQpXG4gIHM6IFt7IG5hbWU6ICduYW1lJyB9XSxcbiAgaTogW3sgbmFtZTogJ2Rlc2NyaXB0aW9uJyB9XSxcbiAgdTogW3sgbmFtZTogJ3VyaScgfV0sXG4gIGU6IFt7IG5hbWU6ICdlbWFpbCcgfV0sXG4gIHA6IFt7IG5hbWU6ICdwaG9uZScgfV0sXG4gIHo6IFt7IG5hbWU6ICd0aW1lem9uZXMnIH1dLCAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWN0dWFsbHkgYmUgcGFyc2VkIHByb3Blcmx5Li5cbiAgcjogW3sgbmFtZTogJ3JlcGVhdHMnIH1dLCAgIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhbHNvIGJlIHBhcnNlZCBwcm9wZXJseVxuICAvL2s6IFt7fV0sIC8vIG91dGRhdGVkIHRoaW5nIGlnbm9yZWRcbiAgdDogW3sgLy90PTAgMFxuICAgIG5hbWU6ICd0aW1pbmcnLFxuICAgIHJlZzogL14oXFxkKikgKFxcZCopLyxcbiAgICBuYW1lczogWydzdGFydCcsICdzdG9wJ10sXG4gICAgZm9ybWF0OiAnJWQgJWQnXG4gIH1dLFxuICBjOiBbeyAvL2M9SU4gSVA0IDEwLjQ3LjE5Ny4yNlxuICAgIG5hbWU6ICdjb25uZWN0aW9uJyxcbiAgICByZWc6IC9eSU4gSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3ZlcnNpb24nLCAnaXAnXSxcbiAgICBmb3JtYXQ6ICdJTiBJUCVkICVzJ1xuICB9XSxcbiAgYjogW3sgLy9iPUFTOjQwMDBcbiAgICBwdXNoOiAnYmFuZHdpZHRoJyxcbiAgICByZWc6IC9eKFRJQVN8QVN8Q1R8UlJ8UlMpOihcXGQqKS8sXG4gICAgbmFtZXM6IFsndHlwZScsICdsaW1pdCddLFxuICAgIGZvcm1hdDogJyVzOiVzJ1xuICB9XSxcbiAgbTogW3sgLy9tPXZpZGVvIDUxNzQ0IFJUUC9BVlAgMTI2IDk3IDk4IDM0IDMxXG4gICAgLy8gTkI6IHNwZWNpYWwgLSBwdXNoZXMgdG8gc2Vzc2lvblxuICAgIC8vIFRPRE86IHJ0cC9mbXRwIHNob3VsZCBiZSBmaWx0ZXJlZCBieSB0aGUgcGF5bG9hZHMgZm91bmQgaGVyZT9cbiAgICByZWc6IC9eKFxcdyopIChcXGQqKSAoW1xcd1xcL10qKSg/OiAoLiopKT8vLFxuICAgIG5hbWVzOiBbJ3R5cGUnLCAncG9ydCcsICdwcm90b2NvbCcsICdwYXlsb2FkcyddLFxuICAgIGZvcm1hdDogJyVzICVkICVzICVzJ1xuICB9XSxcbiAgYTogW1xuICAgIHsgLy9hPXJ0cG1hcDoxMTAgb3B1cy80ODAwMC8yXG4gICAgICBwdXNoOiAncnRwJyxcbiAgICAgIHJlZzogL15ydHBtYXA6KFxcZCopIChbXFx3XFwtXFwuXSopKD86XFxzKlxcLyhcXGQqKSg/OlxccypcXC8oXFxTKikpPyk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29kZWMnLCAncmF0ZScsICdlbmNvZGluZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uZW5jb2RpbmcpID9cbiAgICAgICAgICAncnRwbWFwOiVkICVzLyVzLyVzJzpcbiAgICAgICAgICBvLnJhdGUgP1xuICAgICAgICAgICdydHBtYXA6JWQgJXMvJXMnOlxuICAgICAgICAgICdydHBtYXA6JWQgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyAvL2E9Zm10cDoxMDggcHJvZmlsZS1sZXZlbC1pZD0yNDtvYmplY3Q9MjM7Yml0cmF0ZT02NDAwMFxuICAgICAgLy9hPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxuICAgICAgcHVzaDogJ2ZtdHAnLFxuICAgICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogJ2ZtdHA6JWQgJXMnXG4gICAgfSxcbiAgICB7IC8vYT1jb250cm9sOnN0cmVhbWlkPTBcbiAgICAgIG5hbWU6ICdjb250cm9sJyxcbiAgICAgIHJlZzogL15jb250cm9sOiguKikvLFxuICAgICAgZm9ybWF0OiAnY29udHJvbDolcydcbiAgICB9LFxuICAgIHsgLy9hPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcbiAgICAgIG5hbWU6ICdydGNwJyxcbiAgICAgIHJlZzogL15ydGNwOihcXGQqKSg/OiAoXFxTKikgSVAoXFxkKSAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uYWRkcmVzcyAhPSBudWxsKSA/XG4gICAgICAgICAgJ3J0Y3A6JWQgJXMgSVAlZCAlcyc6XG4gICAgICAgICAgJ3J0Y3A6JWQnO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyAvL2E9cnRjcC1mYjo5OCB0cnItaW50IDEwMFxuICAgICAgcHVzaDogJ3J0Y3BGYlRyckludCcsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIHRyci1pbnQgKFxcZCopLyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3J0Y3AtZmI6JWQgdHJyLWludCAlZCdcbiAgICB9LFxuICAgIHsgLy9hPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gICAgICBwdXNoOiAncnRjcEZiJyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgKFtcXHctX10qKSg/OiAoW1xcdy1fXSopKT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd0eXBlJywgJ3N1YnR5cGUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnN1YnR5cGUgIT0gbnVsbCkgP1xuICAgICAgICAgICdydGNwLWZiOiVzICVzICVzJzpcbiAgICAgICAgICAncnRjcC1mYjolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IC8vYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgICAvL2E9ZXh0bWFwOjEvcmVjdm9ubHkgVVJJLWdwcy1zdHJpbmdcbiAgICAgIHB1c2g6ICdleHQnLFxuICAgICAgcmVnOiAvXmV4dG1hcDooXFxkKykoPzpcXC8oXFx3KykpPyAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ3VyaScsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdleHRtYXA6JWQnICsgKG8uZGlyZWN0aW9uID8gJy8lcycgOiAnJXYnKSArICcgJXMnICsgKG8uY29uZmlnID8gJyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IC8vYT1jcnlwdG86MSBBRVNfQ01fMTI4X0hNQUNfU0hBMV84MCBpbmxpbmU6UFMxdVFDVmVlQ0ZDYW5WbWNqa3BQeXdqTldoY1lEMG1YWHR4YVZCUnwyXjIwfDE6MzJcbiAgICAgIHB1c2g6ICdjcnlwdG8nLFxuICAgICAgcmVnOiAvXmNyeXB0bzooXFxkKikgKFtcXHdfXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdzdWl0ZScsICdjb25maWcnLCAnc2Vzc2lvbkNvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uc2Vzc2lvbkNvbmZpZyAhPSBudWxsKSA/XG4gICAgICAgICAgJ2NyeXB0bzolZCAlcyAlcyAlcyc6XG4gICAgICAgICAgJ2NyeXB0bzolZCAlcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IC8vYT1zZXR1cDphY3RwYXNzXG4gICAgICBuYW1lOiAnc2V0dXAnLFxuICAgICAgcmVnOiAvXnNldHVwOihcXHcqKS8sXG4gICAgICBmb3JtYXQ6ICdzZXR1cDolcydcbiAgICB9LFxuICAgIHsgLy9hPW1pZDoxXG4gICAgICBuYW1lOiAnbWlkJyxcbiAgICAgIHJlZzogL15taWQ6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ21pZDolcydcbiAgICB9LFxuICAgIHsgLy9hPW1zaWQ6MGM4YjA2NGQtZDgwNy00M2I0LWI0MzQtZjkyYTg4OWQ4NTg3IDk4MTc4Njg1LWQ0MDktNDZlMC04ZTE2LTdlZjBkYjBkYjY0YVxuICAgICAgbmFtZTogJ21zaWQnLFxuICAgICAgcmVnOiAvXm1zaWQ6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdtc2lkOiVzJ1xuICAgIH0sXG4gICAgeyAvL2E9cHRpbWU6MjBcbiAgICAgIG5hbWU6ICdwdGltZScsXG4gICAgICByZWc6IC9ecHRpbWU6KFxcZCopLyxcbiAgICAgIGZvcm1hdDogJ3B0aW1lOiVkJ1xuICAgIH0sXG4gICAgeyAvL2E9bWF4cHRpbWU6NjBcbiAgICAgIG5hbWU6ICdtYXhwdGltZScsXG4gICAgICByZWc6IC9ebWF4cHRpbWU6KFxcZCopLyxcbiAgICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xuICAgIH0sXG4gICAgeyAvL2E9c2VuZHJlY3ZcbiAgICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxuICAgICAgcmVnOiAvXihzZW5kcmVjdnxyZWN2b25seXxzZW5kb25seXxpbmFjdGl2ZSkvXG4gICAgfSxcbiAgICB7IC8vYT1pY2UtbGl0ZVxuICAgICAgbmFtZTogJ2ljZWxpdGUnLFxuICAgICAgcmVnOiAvXihpY2UtbGl0ZSkvXG4gICAgfSxcbiAgICB7IC8vYT1pY2UtdWZyYWc6RjdnSVxuICAgICAgbmFtZTogJ2ljZVVmcmFnJyxcbiAgICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS11ZnJhZzolcydcbiAgICB9LFxuICAgIHsgLy9hPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xuICAgICAgbmFtZTogJ2ljZVB3ZCcsXG4gICAgICByZWc6IC9eaWNlLXB3ZDooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcbiAgICB9LFxuICAgIHsgLy9hPWZpbmdlcnByaW50OlNIQS0xIDAwOjExOjIyOjMzOjQ0OjU1OjY2Ojc3Ojg4Ojk5OkFBOkJCOkNDOkREOkVFOkZGOjAwOjExOjIyOjMzXG4gICAgICBuYW1lOiAnZmluZ2VycHJpbnQnLFxuICAgICAgcmVnOiAvXmZpbmdlcnByaW50OihcXFMqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdoYXNoJ10sXG4gICAgICBmb3JtYXQ6ICdmaW5nZXJwcmludDolcyAlcydcbiAgICB9LFxuICAgIHsgLy9hPWNhbmRpZGF0ZTowIDEgVURQIDIxMTM2NjczMjcgMjAzLjAuMTEzLjEgNTQ0MDAgdHlwIGhvc3RcbiAgICAgIC8vYT1jYW5kaWRhdGU6MTE2Mjg3NTA4MSAxIHVkcCAyMTEzOTM3MTUxIDE5Mi4xNjguMzQuNzUgNjAwMTcgdHlwIGhvc3QgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHVkcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vYT1jYW5kaWRhdGU6MjI5ODE1NjIwIDEgdGNwIDE1MTgyODA0NDcgMTkyLjE2OC4xNTAuMTkgNjAwMTcgdHlwIGhvc3QgdGNwdHlwZSBhY3RpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHRjcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgdGNwdHlwZSBwYXNzaXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICBwdXNoOidjYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL15jYW5kaWRhdGU6KFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgdHlwIChcXFMqKSg/OiByYWRkciAoXFxTKikgcnBvcnQgKFxcZCopKT8oPzogdGNwdHlwZSAoXFxTKikpPyg/OiBnZW5lcmF0aW9uIChcXGQqKSk/KD86IG5ldHdvcmstaWQgKFxcZCopKT8oPzogbmV0d29yay1jb3N0IChcXGQqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2ZvdW5kYXRpb24nLCAnY29tcG9uZW50JywgJ3RyYW5zcG9ydCcsICdwcmlvcml0eScsICdpcCcsICdwb3J0JywgJ3R5cGUnLCAncmFkZHInLCAncnBvcnQnLCAndGNwdHlwZScsICdnZW5lcmF0aW9uJywgJ25ldHdvcmstaWQnLCAnbmV0d29yay1jb3N0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnY2FuZGlkYXRlOiVzICVkICVzICVkICVzICVkIHR5cCAlcyc7XG5cbiAgICAgICAgc3RyICs9IChvLnJhZGRyICE9IG51bGwpID8gJyByYWRkciAlcyBycG9ydCAlZCcgOiAnJXYldic7XG5cbiAgICAgICAgLy8gTkI6IGNhbmRpZGF0ZSBoYXMgdGhyZWUgb3B0aW9uYWwgY2h1bmtzLCBzbyAldm9pZCBtaWRkbGVzIG9uZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgICAgc3RyICs9IChvLnRjcHR5cGUgIT0gbnVsbCkgPyAnIHRjcHR5cGUgJXMnIDogJyV2JztcblxuICAgICAgICBpZiAoby5nZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyBnZW5lcmF0aW9uICVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSAob1snbmV0d29yay1pZCddICE9IG51bGwpID8gJyBuZXR3b3JrLWlkICVkJyA6ICcldic7XG4gICAgICAgIHN0ciArPSAob1snbmV0d29yay1jb3N0J10gIT0gbnVsbCkgPyAnIG5ldHdvcmstY29zdCAlZCcgOiAnJXYnO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyAvL2E9ZW5kLW9mLWNhbmRpZGF0ZXMgKGtlZXAgYWZ0ZXIgdGhlIGNhbmRpZGF0ZXMgbGluZSBmb3IgcmVhZGFiaWxpdHkpXG4gICAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL14oZW5kLW9mLWNhbmRpZGF0ZXMpL1xuICAgIH0sXG4gICAgeyAvL2E9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxuICAgICAgbmFtZTogJ3JlbW90ZUNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXnJlbW90ZS1jYW5kaWRhdGVzOiguKikvLFxuICAgICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXG4gICAgfSxcbiAgICB7IC8vYT1pY2Utb3B0aW9uczpnb29nbGUtaWNlXG4gICAgICBuYW1lOiAnaWNlT3B0aW9ucycsXG4gICAgICByZWc6IC9eaWNlLW9wdGlvbnM6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS1vcHRpb25zOiVzJ1xuICAgIH0sXG4gICAgeyAvL2E9c3NyYzoyNTY2MTA3NTY5IGNuYW1lOnQ5WVU4TTFVeFRGOFkxQTFcbiAgICAgIHB1c2g6ICdzc3JjcycsXG4gICAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnYXR0cmlidXRlJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XG4gICAgICAgIGlmIChvLmF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgJXMnO1xuICAgICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSAnOiVzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgLy9hPXNzcmMtZ3JvdXA6RkVDIDEgMlxuICAgICAgLy9hPXNzcmMtZ3JvdXA6RkVDLUZSIDMwMDQzNjQxOTUgMTA4MDc3MjI0MVxuICAgICAgcHVzaDogJ3NzcmNHcm91cHMnLFxuICAgICAgLy8gdG9rZW4tY2hhciA9ICV4MjEgLyAleDIzLTI3IC8gJXgyQS0yQiAvICV4MkQtMkUgLyAleDMwLTM5IC8gJXg0MS01QSAvICV4NUUtN0VcbiAgICAgIHJlZzogL15zc3JjLWdyb3VwOihbXFx4MjFcXHgyM1xceDI0XFx4MjVcXHgyNlxceDI3XFx4MkFcXHgyQlxceDJEXFx4MkVcXHddKikgKC4qKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpY3MnLCAnc3NyY3MnXSxcbiAgICAgIGZvcm1hdDogJ3NzcmMtZ3JvdXA6JXMgJXMnXG4gICAgfSxcbiAgICB7IC8vYT1tc2lkLXNlbWFudGljOiBXTVMgSnZsYW01WDNTWDFPUDZwbjIweldvZ3ZhS0p6NUhqZjlPbmxWXG4gICAgICBuYW1lOiAnbXNpZFNlbWFudGljJyxcbiAgICAgIHJlZzogL15tc2lkLXNlbWFudGljOlxccz8oXFx3KikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljJywgJ3Rva2VuJ10sXG4gICAgICBmb3JtYXQ6ICdtc2lkLXNlbWFudGljOiAlcyAlcycgLy8gc3BhY2UgYWZ0ZXIgJzonIGlzIG5vdCBhY2NpZGVudGFsXG4gICAgfSxcbiAgICB7IC8vYT1ncm91cDpCVU5ETEUgYXVkaW8gdmlkZW9cbiAgICAgIHB1c2g6ICdncm91cHMnLFxuICAgICAgcmVnOiAvXmdyb3VwOihcXHcqKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnbWlkcyddLFxuICAgICAgZm9ybWF0OiAnZ3JvdXA6JXMgJXMnXG4gICAgfSxcbiAgICB7IC8vYT1ydGNwLW11eFxuICAgICAgbmFtZTogJ3J0Y3BNdXgnLFxuICAgICAgcmVnOiAvXihydGNwLW11eCkvXG4gICAgfSxcbiAgICB7IC8vYT1ydGNwLXJzaXplXG4gICAgICBuYW1lOiAncnRjcFJzaXplJyxcbiAgICAgIHJlZzogL14ocnRjcC1yc2l6ZSkvXG4gICAgfSxcbiAgICB7IC8vYT1zY3RwbWFwOjUwMDAgd2VicnRjLWRhdGFjaGFubmVsIDEwMjRcbiAgICAgIG5hbWU6ICdzY3RwbWFwJyxcbiAgICAgIHJlZzogL15zY3RwbWFwOihbXFx3X1xcL10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnc2N0cG1hcE51bWJlcicsICdhcHAnLCAnbWF4TWVzc2FnZVNpemUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLm1heE1lc3NhZ2VTaXplICE9IG51bGwpID9cbiAgICAgICAgICAnc2N0cG1hcDolcyAlcyAlcycgOlxuICAgICAgICAgICdzY3RwbWFwOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgLy9hPXgtZ29vZ2xlLWZsYWc6Y29uZmVyZW5jZVxuICAgICAgbmFtZTogJ3hHb29nbGVGbGFnJyxcbiAgICAgIHJlZzogL154LWdvb2dsZS1mbGFnOihbXlxcc10qKS8sXG4gICAgICBmb3JtYXQ6ICd4LWdvb2dsZS1mbGFnOiVzJ1xuICAgIH0sXG4gICAgeyAvL2E9cmlkOjEgc2VuZCBtYXgtd2lkdGg9MTI4MDttYXgtaGVpZ2h0PTcyMDttYXgtZnBzPTMwO2RlcGVuZD0wXG4gICAgICBwdXNoOiAncmlkcycsXG4gICAgICByZWc6IC9ecmlkOihbXFxkXFx3XSspIChcXHcrKSg/OiAoW1xcU3wgXSopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnZGlyZWN0aW9uJywgJ3BhcmFtcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8ucGFyYW1zKSA/ICdyaWQ6JXMgJXMgJXMnIDogJ3JpZDolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IC8vYT1pbWFnZWF0dHI6OTcgc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXSByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgIC8vYT1pbWFnZWF0dHI6KiBzZW5kIFt4PTgwMCx5PTY0MF0gcmVjdiAqXG4gICAgICAvL2E9aW1hZ2VhdHRyOjEwMCByZWN2IFt4PTMyMCx5PTI0MF1cbiAgICAgIHB1c2g6ICdpbWFnZWF0dHJzJyxcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAgICAgLy9hPWltYWdlYXR0cjo5N1xuICAgICAgICAnXmltYWdlYXR0cjooXFxcXGQrfFxcXFwqKScgK1xuICAgICAgICAvL3NlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF1cbiAgICAgICAgJ1tcXFxcc1xcXFx0XSsoc2VuZHxyZWN2KVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopJyArXG4gICAgICAgIC8vcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgICAgICcoPzpbXFxcXHNcXFxcdF0rKHJlY3Z8c2VuZClbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKSk/J1xuICAgICAgKSxcbiAgICAgIG5hbWVzOiBbJ3B0JywgJ2RpcjEnLCAnYXR0cnMxJywgJ2RpcjInLCAnYXR0cnMyJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnaW1hZ2VhdHRyOiVzICVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgLy9hPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxuICAgICAgLy9hPXNpbXVsY2FzdDpyZWN2IDE7NCw1IHNlbmQgNjs3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0JyxcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAgICAgLy9hPXNpbXVsY2FzdDpcbiAgICAgICAgJ15zaW11bGNhc3Q6JyArXG4gICAgICAgIC8vc2VuZCAxLDIsMzt+NCx+NVxuICAgICAgICAnKHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKyknICtcbiAgICAgICAgLy9zcGFjZSArIHJlY3YgNjt+Nyx+OFxuICAgICAgICAnKD86XFxcXHM/KHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKykpPycgK1xuICAgICAgICAvL2VuZFxuICAgICAgICAnJCdcbiAgICAgICksXG4gICAgICBuYW1lczogWydkaXIxJywgJ2xpc3QxJywgJ2RpcjInLCAnbGlzdDInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdzaW11bGNhc3Q6JXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyAvL09sZCBzaW11bGNhc3QgZHJhZnQgMDMgKGltcGxlbWVudGVkIGJ5IEZpcmVmb3gpXG4gICAgICAvLyAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcbiAgICAgIC8vYT1zaW11bGNhc3Q6IHJlY3YgcHQ9OTc7OTggc2VuZCBwdD05N1xuICAgICAgLy9hPXNpbXVsY2FzdDogc2VuZCByaWQ9NTs2OzcgcGF1c2VkPTYsN1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdF8wMycsXG4gICAgICByZWc6IC9ec2ltdWxjYXN0OltcXHNcXHRdKyhbXFxTK1xcc1xcdF0rKSQvLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3NpbXVsY2FzdDogJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvL2E9ZnJhbWVyYXRlOjI1XG4gICAgICAvL2E9ZnJhbWVyYXRlOjI5Ljk3XG4gICAgICBuYW1lOiAnZnJhbWVyYXRlJyxcbiAgICAgIHJlZzogL15mcmFtZXJhdGU6KFxcZCsoPzokfFxcLlxcZCspKS8sXG4gICAgICBmb3JtYXQ6ICdmcmFtZXJhdGU6JXMnXG4gICAgfSxcbiAgICB7IC8vIGFueSBhPSB0aGF0IHdlIGRvbid0IHVuZGVyc3RhbmQgaXMga2VwdHMgdmVyYmF0aW0gb24gbWVkaWEuaW52YWxpZFxuICAgICAgcHVzaDogJ2ludmFsaWQnLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXVxuICAgIH1cbiAgXVxufTtcblxuLy8gc2V0IHNlbnNpYmxlIGRlZmF1bHRzIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ3JhbW1hciB3aXRoIGJvcmluZyBkZXRhaWxzXG5PYmplY3Qua2V5cyhncmFtbWFyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIG9ianMgPSBncmFtbWFyW2tleV07XG4gIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFvYmoucmVnKSB7XG4gICAgICBvYmoucmVnID0gLyguKikvO1xuICAgIH1cbiAgICBpZiAoIW9iai5mb3JtYXQpIHtcbiAgICAgIG9iai5mb3JtYXQgPSAnJXMnO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsInZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xudmFyIHdyaXRlciA9IHJlcXVpcmUoJy4vd3JpdGVyJyk7XG5cbmV4cG9ydHMud3JpdGUgPSB3cml0ZXI7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VyLnBhcnNlO1xuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBwYXJzZXIucGFyc2VGbXRwQ29uZmlnO1xuZXhwb3J0cy5wYXJzZVBhcmFtcyA9IHBhcnNlci5wYXJzZVBhcmFtcztcbmV4cG9ydHMucGFyc2VQYXlsb2FkcyA9IHBhcnNlci5wYXJzZVBheWxvYWRzO1xuZXhwb3J0cy5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBwYXJzZXIucGFyc2VSZW1vdGVDYW5kaWRhdGVzO1xuZXhwb3J0cy5wYXJzZUltYWdlQXR0cmlidXRlcyA9IHBhcnNlci5wYXJzZUltYWdlQXR0cmlidXRlcztcbmV4cG9ydHMucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gcGFyc2VyLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdDtcbiIsInZhciB0b0ludElmSW50ID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIFN0cmluZyhOdW1iZXIodikpID09PSB2ID8gTnVtYmVyKHYpIDogdjtcbn07XG5cbnZhciBhdHRhY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG1hdGNoLCBsb2NhdGlvbiwgbmFtZXMsIHJhd05hbWUpIHtcbiAgaWYgKHJhd05hbWUgJiYgIW5hbWVzKSB7XG4gICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgfVxuICBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAobWF0Y2hbaSsxXSAhPSBudWxsKSB7XG4gICAgICAgIGxvY2F0aW9uW25hbWVzW2ldXSA9IHRvSW50SWZJbnQobWF0Y2hbaSsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGFyc2VSZWcgPSBmdW5jdGlvbiAob2JqLCBsb2NhdGlvbiwgY29udGVudCkge1xuICB2YXIgbmVlZHNCbGFuayA9IG9iai5uYW1lICYmIG9iai5uYW1lcztcbiAgaWYgKG9iai5wdXNoICYmICFsb2NhdGlvbltvYmoucHVzaF0pIHtcbiAgICBsb2NhdGlvbltvYmoucHVzaF0gPSBbXTtcbiAgfVxuICBlbHNlIGlmIChuZWVkc0JsYW5rICYmICFsb2NhdGlvbltvYmoubmFtZV0pIHtcbiAgICBsb2NhdGlvbltvYmoubmFtZV0gPSB7fTtcbiAgfVxuICB2YXIga2V5TG9jYXRpb24gPSBvYmoucHVzaCA/XG4gICAge30gOiAgLy8gYmxhbmsgb2JqZWN0IHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gIGF0dGFjaFByb3BlcnRpZXMoY29udGVudC5tYXRjaChvYmoucmVnKSwga2V5TG9jYXRpb24sIG9iai5uYW1lcywgb2JqLm5hbWUpO1xuXG4gIGlmIChvYmoucHVzaCkge1xuICAgIGxvY2F0aW9uW29iai5wdXNoXS5wdXNoKGtleUxvY2F0aW9uKTtcbiAgfVxufTtcblxudmFyIGdyYW1tYXIgPSByZXF1aXJlKCcuL2dyYW1tYXInKTtcbnZhciB2YWxpZExpbmUgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihbYS16XSk9KC4qKS8pO1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNkcCkge1xuICB2YXIgc2Vzc2lvbiA9IHt9XG4gICAgLCBtZWRpYSA9IFtdXG4gICAgLCBsb2NhdGlvbiA9IHNlc3Npb247IC8vIHBvaW50cyBhdCB3aGVyZSBwcm9wZXJ0aWVzIGdvIHVuZGVyIChvbmUgb2YgdGhlIGFib3ZlKVxuXG4gIC8vIHBhcnNlIGxpbmVzIHdlIHVuZGVyc3RhbmRcbiAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgIHZhciB0eXBlID0gbFswXTtcbiAgICB2YXIgY29udGVudCA9IGwuc2xpY2UoMik7XG4gICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgbWVkaWEucHVzaCh7cnRwOiBbXSwgZm10cDogW119KTtcbiAgICAgIGxvY2F0aW9uID0gbWVkaWFbbWVkaWEubGVuZ3RoLTFdOyAvLyBwb2ludCBhdCBsYXRlc3QgbWVkaWEgbGluZVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgKGdyYW1tYXJbdHlwZV0gfHwgW10pLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICB2YXIgb2JqID0gZ3JhbW1hclt0eXBlXVtqXTtcbiAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVnKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXG4gIHJldHVybiBzZXNzaW9uO1xufTtcblxudmFyIHBhcmFtUmVkdWNlciA9IGZ1bmN0aW9uIChhY2MsIGV4cHIpIHtcbiAgdmFyIHMgPSBleHByLnNwbGl0KC89KC4rKS8sIDIpO1xuICBpZiAocy5sZW5ndGggPT09IDIpIHtcbiAgICBhY2Nbc1swXV0gPSB0b0ludElmSW50KHNbMV0pO1xuICB9XG4gIHJldHVybiBhY2M7XG59O1xuXG5leHBvcnRzLnBhcnNlUGFyYW1zID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC9cXDtcXHM/LykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xufTtcblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLjBcbmV4cG9ydHMucGFyc2VGbXRwQ29uZmlnID0gZXhwb3J0cy5wYXJzZVBhcmFtcztcblxuZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKE51bWJlcik7XG59O1xuXG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcgJykubWFwKHRvSW50SWZJbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgIGNvbXBvbmVudDogcGFydHNbaV0sXG4gICAgICBpcDogcGFydHNbaSArIDFdLFxuICAgICAgcG9ydDogcGFydHNbaSArIDJdXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uc3Vic3RyaW5nKDEsIGl0ZW0ubGVuZ3RoLTEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICByZXR1cm4gc3RyZWFtLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgIHZhciBzY2lkLCBwYXVzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XG4gICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcbiAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NpZDogc2NpZCxcbiAgICAgICAgcGF1c2VkOiBwYXVzZWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsInZhciBncmFtbWFyID0gcmVxdWlyZSgnLi9ncmFtbWFyJyk7XG5cbi8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkdiVdL2c7XG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgIH1cbiAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICBpICs9IDE7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgY2FzZSAnJSUnOlxuICAgICAgcmV0dXJuICclJztcbiAgICBjYXNlICclcyc6XG4gICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG4gICAgY2FzZSAnJWQnOlxuICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgIGNhc2UgJyV2JzpcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0pO1xuICAvLyBOQjogd2UgZGlzY2FyZCBleGNlc3MgYXJndW1lbnRzIC0gdGhleSBhcmUgdHlwaWNhbGx5IHVuZGVmaW5lZCBmcm9tIG1ha2VMaW5lXG59O1xuXG52YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xuICB2YXIgc3RyID0gb2JqLmZvcm1hdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID9cbiAgICAob2JqLmZvcm1hdChvYmoucHVzaCA/IGxvY2F0aW9uIDogbG9jYXRpb25bb2JqLm5hbWVdKSkgOlxuICAgIG9iai5mb3JtYXQ7XG5cbiAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XG4gIGlmIChvYmoubmFtZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XG4gICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufTtcblxuLy8gUkZDIHNwZWNpZmllZCBvcmRlclxuLy8gVE9ETzogZXh0ZW5kIHRoaXMgd2l0aCBhbGwgdGhlIHJlc3RcbnZhciBkZWZhdWx0T3V0ZXJPcmRlciA9IFtcbiAgJ3YnLCAnbycsICdzJywgJ2knLFxuICAndScsICdlJywgJ3AnLCAnYycsXG4gICdiJywgJ3QnLCAncicsICd6JywgJ2EnXG5dO1xudmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxuICBpZiAoc2Vzc2lvbi52ZXJzaW9uID09IG51bGwpIHtcbiAgICBzZXNzaW9uLnZlcnNpb24gPSAwOyAvLyAndj0wJyBtdXN0IGJlIHRoZXJlIChvbmx5IGRlZmluZWQgdmVyc2lvbiBhdG0pXG4gIH1cbiAgaWYgKHNlc3Npb24ubmFtZSA9PSBudWxsKSB7XG4gICAgc2Vzc2lvbi5uYW1lID0gJyAnOyAvLyAncz0gJyBtdXN0IGJlIHRoZXJlIGlmIG5vIG1lYW5pbmdmdWwgbmFtZSBzZXRcbiAgfVxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgaWYgKG1MaW5lLnBheWxvYWRzID09IG51bGwpIHtcbiAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcbiAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gIHZhciBzZHAgPSBbXTtcblxuICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXG4gIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgIHNlc3Npb25bb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcbiAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgIHNkcC5wdXNoKG1ha2VMaW5lKCdtJywgZ3JhbW1hci5tWzBdLCBtTGluZSkpO1xuXG4gICAgaW5uZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIG1MaW5lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZHAuam9pbignXFxyXFxuJykgKyAnXFxyXFxuJztcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcbiAgfVxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIElFNisgaGFzT3duUHJvcGVydHlcbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgX3BhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBfcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBnZW5lcmF0ZSBgc29ja2V0LmlkYCBmb3IgdGhlIGdpdmVuIGBuc3BgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5zcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIChuc3ApIHtcbiAgcmV0dXJuIChuc3AgPT09ICcvJyA/ICcnIDogKG5zcCArICcjJykpICsgdGhpcy5lbmdpbmUuaWQ7XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZm4sIG9wdHMpIHtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuZW1pdEFsbCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlKCkgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24gKG5zcCwgb3B0cykge1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZyAoKSB7XG4gICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbiAoZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcblxuICB2YXIgc3Vic0xlbmd0aCA9IHRoaXMuc3Vicy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpO1xuICAgIHN1Yi5kZXN0cm95KCk7XG4gIH1cblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ29uY2xvc2UnKTtcblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uIChvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAoaW8sIG5zcCwgb3B0cykge1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgfVxuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogcGFyc2VyLkVWRU5ULCBkYXRhOiBhcmdzIH07XG5cbiAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICBkZWxldGUgdGhpcy5mbGFncztcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICB2YXIgcXVlcnkgPSB0eXBlb2YgdGhpcy5xdWVyeSA9PT0gJ29iamVjdCcgPyBwYXJzZXFzLmVuY29kZSh0aGlzLnF1ZXJ5KSA6IHRoaXMucXVlcnk7XG4gICAgICBkZWJ1Zygnc2VuZGluZyBjb25uZWN0IHBhY2tldCB3aXRoIHF1ZXJ5ICVzJywgcXVlcnkpO1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogcXVlcnl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNUfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmIChwYWNrZXQubnNwICE9PSB0aGlzLm5zcCkgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiBwYXJzZXIuQUNLLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYWNrKSB7XG4gICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG4gIH1cblxuICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICB0aGlzLmRlc3Ryb3koKTtcblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAvLyBmaXJlIGV2ZW50c1xuICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uIChjb21wcmVzcykge1xuICB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8fCB7fTtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsICh1cmksIGxvYykge1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgZ2xvYmFsLkJsb2IgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGdsb2JhbC5GaWxlID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG5mdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChpc0J1ZihkYXRhKSkge1xuICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBpZiAoKG9iai50eXBlID09PSBleHBvcnRzLkVWRU5UIHx8IG9iai50eXBlID09PSBleHBvcnRzLkFDSykgJiYgaGFzQmluKG9iai5kYXRhKSkge1xuICAgIG9iai50eXBlID0gb2JqLnR5cGUgPT09IGV4cG9ydHMuRVZFTlQgPyBleHBvcnRzLkJJTkFSWV9FVkVOVCA6IGV4cG9ydHMuQklOQVJZX0FDSztcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHZhciBzdHIgPSAnJyArIG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzICsgJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9PSBvYmoubnNwKSB7XG4gICAgc3RyICs9IG9iai5uc3AgKyAnLCc7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICAvLyBsb29rIHVwIHR5cGVcbiAgdmFyIHAgPSB7XG4gICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gIH07XG5cbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gcC50eXBlKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9PSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgIHAubnNwID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKCcsJyA9PT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5pZCA9IE51bWJlcihwLmlkKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICBwID0gdHJ5UGFyc2UocCwgc3RyLnN1YnN0cihpKSk7XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0cnlQYXJzZShwLCBzdHIpIHtcbiAgdHJ5IHtcbiAgICBwLmRhdGEgPSBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHA7IFxufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcidcbiAgfTtcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG4gICwgbGVuZ3RoID0gNjRcbiAgLCBtYXAgPSB7fVxuICAsIHNlZWQgPSAwXG4gICwgaSA9IDBcbiAgLCBwcmV2O1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gIHZhciBlbmNvZGVkID0gJyc7XG5cbiAgZG8ge1xuICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gIH0gd2hpbGUgKG51bSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHZhciBkZWNvZGVkID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gIH1cblxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLyoqXG4gKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24geWVhc3QoKSB7XG4gIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG4gIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgcmV0dXJuIG5vdyArJy4nKyBlbmNvZGUoc2VlZCsrKTtcbn1cblxuLy9cbi8vIE1hcCBlYWNoIGNoYXJhY3RlciB0byBpdHMgaW5kZXguXG4vL1xuZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG4vL1xueWVhc3QuZW5jb2RlID0gZW5jb2RlO1xueWVhc3QuZGVjb2RlID0gZGVjb2RlO1xubW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcbiIsIiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXX0=
